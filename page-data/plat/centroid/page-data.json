{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/plat/centroid",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*\n\nTODO:\n- Add more resources\n\n*/\n/*pulled from https://codeforces.com/contest/1303/submission/76216413, which I think is my most recent centroid problem*/\n/*I used the code on a successful submission to \"Xenia and Tree\" https://codeforces.com/contest/342/submission/113088188*/\n/*Note: Unfortunately, it seems like constant factor is especially important for DMOJ.*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"centroid\", title = \"Centroid Decomposition\", author = \"Siyong Huang, Benjamin Qi\", prerequisites = [\"intro-tree\"], description = \"Decomposing a tree to facilitate path computations.\", frequency = 1;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    IncompleteSection: _missingComponent(\"IncompleteSection\"),\n    Problems: _missingComponent(\"Problems\")\n  }, _props.components), {HeaderLink, MATHSPAN, FocusProblem, LanguageSection, CPPSection, JavaSection, Resources, Resource, IncompleteSection, Problems, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [\"\\n\", _jsxs(_components.h2, {\n      id: \"introduction\",\n      children: [_jsx(_components.a, {\n        href: \"#introduction\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Introduction\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"centroids\",\n      children: [_jsx(_components.a, {\n        href: \"#centroids\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Centroids\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A \", _jsx(_components.strong, {\n        children: \"centroid\"\n      }), \" of a tree is defined as a node such that when the tree is rooted\\r\\nat it, no other nodes have a subtree of size greater than \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\frac{N}{2}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\frac{N}{2}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.2173em;vertical-align:-0.345em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mopen nulldelimiter\\\"></span><span class=\\\"mfrac\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8723em;\\\"><span style=\\\"top:-2.655em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span><span style=\\\"top:-3.23em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"frac-line\\\" style=\\\"border-bottom-width:0.04em;\\\"></span></span><span style=\\\"top:-3.394em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.345em;\\\"><span></span></span></span></span></span><span class=\\\"mclose nulldelimiter\\\"></span></span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sam\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can find a centroid in a tree by starting at the root. Each step, loop\\r\\nthrough all of its children. If all of its children have subtree size less than\\r\\nor equal to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\frac{N}{2}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\frac{N}{2}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.2173em;vertical-align:-0.345em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mopen nulldelimiter\\\"></span><span class=\\\"mfrac\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8723em;\\\"><span style=\\\"top:-2.655em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span><span style=\\\"top:-3.23em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"frac-line\\\" style=\\\"border-bottom-width:0.04em;\\\"></span></span><span style=\\\"top:-3.394em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.345em;\\\"><span></span></span></span></span></span><span class=\\\"mclose nulldelimiter\\\"></span></span></span></span></span>\"\n      }), \", then it is a centroid. Otherwise, move to the child\\r\\nwith a subtree size that is more than \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\frac{N}{2}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mfrac><mi>N</mi><mn>2</mn></mfrac></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\frac{N}{2}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.2173em;vertical-align:-0.345em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mopen nulldelimiter\\\"></span><span class=\\\"mfrac\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8723em;\\\"><span style=\\\"top:-2.655em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span><span style=\\\"top:-3.23em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"frac-line\\\" style=\\\"border-bottom-width:0.04em;\\\"></span></span><span style=\\\"top:-3.394em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.345em;\\\"><span></span></span></span></span></span><span class=\\\"mclose nulldelimiter\\\"></span></span></span></span></span>\"\n      }), \" and repeat until you find a\\r\\ncentroid.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\nconst int maxn = 200010;\\r\\n\\r\\nint n;\\r\\nvector <int> adj[maxn];\\r\\nint subtree_size[maxn];\\r\\n\\r\\nint get_subtree_size(int node, int par = -1) {\\r\\n\\tint& res = subtree_size[node];\\r\\n\\tres = 1;\\r\\n\\tfor (int i : adj[node]) {\\r\\n\\t\\tif (i == par) continue;\\r\\n\\t\\tres += get_subtree_size(i, node);\\r\\n\\t}\\r\\n\\treturn res;\\r\\n}\\r\\n\\r\\nint get_centroid(int node, int par = -1) {\\r\\n\\tfor (int i : adj[node]) {\\r\\n\\t\\tif (i == par) continue;\\r\\n\\r\\n\\t\\tif (subtree_size[i] * 2 > n) {\\r\\n\\t\\t\\treturn get_centroid(i, node);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn node;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcin >> n;\\r\\n\\tfor (int i = 0; i < n - 1; i++) {\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\ta--; b--;\\r\\n\\t\\tadj[a].push_back(b);\\r\\n\\t\\tadj[b].push_back(a);\\r\\n\\t}\\r\\n\\r\\n\\tget_subtree_size(0);\\r\\n\\tcout << get_centroid(0) + 1 << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class FindCentroid {\\r\\n\\tpublic static int[] subSize;\\r\\n\\tpublic static List<Integer>[] adj;\\r\\n\\tpublic static int N;\\r\\n\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\t\\tN = io.nextInt();\\r\\n\\t\\tadj = new List[N];\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tadj[i] = new ArrayList<>();\\r\\n\\t\\t}\\r\\n\\t\\tsubSize = new int[N];\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N - 1; i++) {\\r\\n\\t\\t\\tint a = io.nextInt() - 1;\\r\\n\\t\\t\\tint b = io.nextInt() - 1;\\r\\n\\t\\t\\tadj[a].add(b);\\r\\n\\t\\t\\tadj[b].add(a);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsubtreeSize(0, -1);\\r\\n\\t\\tio.println(getCentroid(0, -1) + 1);\\r\\n\\t\\tio.close();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// Find the size of the subtree under this node.\\r\\n\\tpublic static int subtreeSize(int node, int par) {\\r\\n\\t\\tint res = 1;\\r\\n\\t\\tfor (int next : adj[node]) {\\r\\n\\t\\t\\tif (next == par) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tres += subtreeSize(next, node);\\r\\n\\t\\t}\\r\\n\\t\\treturn (subSize[node] = res);\\r\\n\\t}\\r\\n\\r\\n\\t// Find the centroid of the tree (the subtree with <= N/2 nodes)\\r\\n\\tpublic static int getCentroid(int node, int par) {\\r\\n\\t\\tfor (int next : adj[node]) {\\r\\n\\t\\t\\tif (next == par) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// Keep searching for the centroid if there are subtrees with more than N/2 nodes.\\r\\n\\t\\t\\tif (subSize[next] * 2 > N) {\\r\\n\\t\\t\\t\\treturn getCentroid(next, node);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn node;\\r\\n\\t}\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"centroid-decomposition\",\n      children: [_jsx(_components.a, {\n        href: \"#centroid-decomposition\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Centroid decomposition\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sam2\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Centroid Decomposition\"\n      }), \" is a divide and conquer technique for trees.\\r\\n\", _jsx(_components.strong, {\n        children: \"Centroid Decomposition\"\n      }), \" works by repeated splitting the tree and each of the\\r\\nresulting subgraphs at the centroid, producing \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(\\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(\\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" layers of\\r\\nsubgraphs.\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"Carpanese\",\n        title: \"Illustrated Intro to Centroid Decomposition\",\n        url: \"https://medium.com/carpanese/an-illustrated-introduction-to-centroid-decomposition-8c1989d53308\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"how to solve above problem\"\n        })\n      }), _jsx(Resource, {\n        source: \"CF\",\n        title: \"galen_colin - Centroid Decomposition\",\n        url: \"https://codeforces.com/blog/entry/81661\",\n        children: _jsx(_components.p, {\n          children: \"blog + video for above problem. LCA isn't necessary though.\"\n        })\n      }), _jsx(Resource, {\n        source: \"GFG\",\n        title: \"Centroid Decomposition of Tree\",\n        url: \"centroid-decomposition-of-tree\"\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation-1\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"General centroid code is shown below.\"\n    }), \"\\n\", _jsx(IncompleteSection, {\n      children: _jsx(_components.p, {\n        children: \"Ben - this is not easy to understand :/\"\n      })\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"bool r[MN];//removed\\r\\nint s[MN];//subtree size\\r\\nint dfs(int n, int p = 0)\\r\\n{\\r\\n\\ts[n] = 1;\\r\\n\\tfor(int x : a[n])\\r\\n\\t\\tif(x != p && !r[x])\\r\\n\\t\\t\\ts[n] += dfs(x, n);\\r\\n\\treturn s[n];\\r\\n}\\r\\nint get_centroid(int n, int ms, int p = 0)//n = node, ms = size of tree, p = parent\\r\\n{\\r\\n\\tfor(int x : a[n])\\r\\n\\t\\tif(x != p && !r[x])\\r\\n\\t\\t\\tif(s[x]*2 > ms)\\r\\n\\t\\t\\t\\treturn get_centroid(x, ms, n);\\r\\n\\treturn n;\\r\\n}\\r\\nvoid centroid(int n = 1)\\r\\n{\\r\\n\\tint C = get_centroid(n, dfs(n));\\r\\n\\r\\n\\t//do something\\r\\n\\r\\n\\tr[C] = 1;\\r\\n\\tfor(int x : a[C])\\r\\n\\t\\tif(!r[x])\\r\\n\\t\\t\\tcentroid(x);\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"private static class Centroid {\\r\\n\\tint n;\\r\\n\\tint[][] g;\\r\\n\\tint[] size;\\r\\n\\tint[] parent;\\r\\n\\tboolean[] seen;\\r\\n\\r\\n\\tCentroid(int n, int[][] g) {\\r\\n\\t\\tthis.n = n;\\r\\n\\t\\tthis.g = g;\\r\\n\\t\\tsize = new int[n];\\r\\n\\t\\tparent = new int[n];\\r\\n\\t\\tseen = new boolean[n];\\r\\n\\t\\tinitCentroid(0, -1);\\r\\n\\t}\\r\\n\\r\\n\\tprivate int getSize(int u, int v) {\\r\\n\\t\\tif (seen[u]) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\t\\tsize[u] = 1;\\r\\n\\t\\tfor (int next : g[u]) {\\r\\n\\t\\t\\tif (next != v) {\\r\\n\\t\\t\\t\\tsize[u] += getSize(next, u);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn size[u];\\r\\n\\t}\\r\\n\\r\\n\\tprivate void initCentroid(int u, int v) {\\r\\n\\t\\tgetSize(u, v);\\r\\n\\t\\tfinal int c = findCentroid(u, -1, size[u]);\\r\\n\\t\\tseen[c] = true;\\r\\n\\t\\tparent[c] = v;\\r\\n\\t\\tfor (int next : g[c]) {\\r\\n\\t\\t\\tif (!seen[next]) {\\r\\n\\t\\t\\t\\tinitCentroid(next, c);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tprivate int findCentroid(int u, int v, int currSize) {\\r\\n\\t\\tfor (int x : g[u]) {\\r\\n\\t\\t\\tif (x != v) {\\r\\n\\t\\t\\t\\tif (!seen[x] && size[x] > currSize / 2) {\\r\\n\\t\\t\\t\\t\\treturn findCentroid(x, u, currSize);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn u;\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution---xenia--tree\",\n      children: [_jsx(_components.a, {\n        href: \"#solution---xenia--tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution - Xenia & Tree\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <cstdio>\\r\\n#include <cstring>\\r\\n#include <vector>\\r\\n\\r\\ntemplate<typename T> bool ckmin(T& a, const T& b){return b<a?a=b,1:0;}\\r\\n\\r\\nconst int MN = 1e5+10, INF = 0x3f3f3f3f;\\r\\n\\r\\nint N, M, s[MN], m[MN][2], t, b, d;\\r\\nbool r[MN], red[MN];\\r\\nstd::vector<int> a[MN], v[MN];\\r\\nstruct info\\r\\n{\\r\\n\\tpublic:\\r\\n\\t\\tint n,b,d;\\r\\n};\\r\\nstd::vector<info> g[MN];\\r\\n\\r\\nint dfs(int n, int p=0)\\r\\n{\\r\\n\\ts[n]=1;\\r\\n\\tfor(auto x:a[n])\\r\\n\\t\\tif(x!=p&&!r[x])\\r\\n\\t\\t\\ts[n]+=dfs(x, n);\\r\\n\\treturn s[n];\\r\\n}\\r\\nint find(int n, int ms, int p=0)\\r\\n{\\r\\n\\tfor(auto x:a[n])\\r\\n\\t\\tif(!r[x]&&x!=p&&s[x]*2>ms)\\r\\n\\t\\t\\treturn find(x, ms, n);\\r\\n\\treturn n;\\r\\n}\\r\\nvoid dfs2(int n, int p=0)\\r\\n{\\r\\n\\tfor(auto x:a[n])\\r\\n\\t\\tif(!r[x]&&x!=p)\\r\\n\\t\\t\\t++d, dfs2(x, n), --d;\\r\\n\\tg[n].push_back({t,b,d});\\r\\n}\\r\\nvoid centroid(int n=1)\\r\\n{\\r\\n\\tn = find(n, dfs(n));\\r\\n\\tv[n].reserve(a[n].size());\\r\\n\\tfor(auto x:a[n])\\r\\n\\t\\tif(!r[x])\\r\\n\\t\\t{\\r\\n\\t\\t\\tt=n, b=v[n].size(), d=1;\\r\\n\\t\\t\\tdfs2(x, n);\\r\\n\\t\\t\\tv[n].push_back(INF);\\r\\n\\t\\t}\\r\\n\\tr[n]=1;\\r\\n\\tfor(auto x:a[n])\\r\\n\\t\\tif(!r[x])\\r\\n\\t\\t\\tcentroid(x);\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tscanf(\\\"%d%d\\\", &N, &M);\\r\\n\\tfor(int i=0,u,v;i+1<N;++i)\\r\\n\\t\\tscanf(\\\"%d%d\\\", &u, &v), a[u].push_back(v), a[v].push_back(u);\\r\\n\\tcentroid();\\r\\n\\tmemset(m, 0x3f, sizeof m);\\r\\n\\tfor(int i=0,t=1,n=1;i<=M;++i)\\r\\n\\t{\\r\\n\\t\\tif(t==1)\\r\\n\\t\\t{\\r\\n\\t\\t\\tfor(auto x:g[n])\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tint &q=v[x.n][x.b];\\r\\n\\t\\t\\t\\tif(x.d<q)\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tif(m[x.n][0]==q) m[x.n][0]=x.d;\\r\\n\\t\\t\\t\\t\\telse for(int i=0,u=x.d;i<2;++i) if(u<m[x.n][i]) std::swap(u, m[x.n][i]);\\r\\n\\t\\t\\t\\t\\tq=x.d;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tred[n]=1;\\r\\n\\t\\t\\tm[n][0]=0;\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\tint f=m[n][0];\\r\\n\\t\\t\\tfor(auto x:g[n])\\r\\n\\t\\t\\t\\tif(x.d)\\r\\n\\t\\t\\t\\t\\tckmin(f, m[x.n][v[x.n][x.b]==m[x.n][0]]+x.d);\\r\\n\\t\\t\\tprintf(\\\"%d\\\\n\\\", f);\\r\\n\\t\\t}\\r\\n\\t\\tif(i<M) scanf(\\\"%d%d\\\", &t, &n);\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", \"\\n\", _jsx(Problems, {\n      problems: \"general\"\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  author,\n  prerequisites,\n  description,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"Centroid Decomposition","author":"Siyong Huang, Benjamin Qi","contributors":null,"id":"centroid","prerequisites":["intro-tree"],"description":"Decomposing a tree to facilitate path computations.","frequency":1},"parent":{"name":"Centroid","relativePath":"5_Plat/Centroid.mdx"},"fields":{"division":"plat"},"toc":{"cpp":[{"depth":2,"value":"Introduction","slug":"introduction"},{"depth":3,"value":"Centroids","slug":"centroids"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Centroid decomposition","slug":"centroid-decomposition"},{"depth":2,"value":"Implementation","slug":"implementation-1"},{"depth":2,"value":"Solution - Xenia &amp; Tree","slug":"solution---xenia--tree"},{"depth":2,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Introduction","slug":"introduction"},{"depth":3,"value":"Centroids","slug":"centroids"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Centroid decomposition","slug":"centroid-decomposition"},{"depth":2,"value":"Implementation","slug":"implementation-1"},{"depth":2,"value":"Solution - Xenia &amp; Tree","slug":"solution---xenia--tree"},{"depth":2,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Introduction","slug":"introduction"},{"depth":3,"value":"Centroids","slug":"centroids"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Centroid decomposition","slug":"centroid-decomposition"},{"depth":2,"value":"Implementation","slug":"implementation-1"},{"depth":2,"value":"Solution - Xenia &amp; Tree","slug":"solution---xenia--tree"},{"depth":2,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[{"listId":"sam","problems":[{"uniqueId":"cses-2079","name":"Finding a Centroid","url":"https://cses.fi/problemset/task/2079","source":"CSES","difficulty":"Very Easy","isStarred":false,"tags":[],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}}]},{"listId":"sam2","problems":[{"uniqueId":"cf-342E","name":"Xenia & Tree","url":"https://codeforces.com/problemset/problem/342/E","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Centroid"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}}]},{"listId":"general","problems":[{"uniqueId":"cf-321C","name":"Ciel the Commander","url":"https://codeforces.com/contest/321/problem/C","source":"CF","difficulty":"Easy","isStarred":true,"tags":["Centroid"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"baltic-20-VillageMaximum","name":"2020 - Village (Maximum)","url":"https://codeforces.com/contest/1387/problem/B2","source":"Baltic OI","difficulty":"Easy","isStarred":true,"tags":["Centroid"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cses-2080","name":"Fixed-Length Paths I","url":"https://cses.fi/problemset/task/2080","source":"CSES","difficulty":"Easy","isStarred":true,"tags":["Centroid"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cses-2081","name":"Fixed-Length Paths II","url":"https://cses.fi/problemset/task/2081","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["Centroid","BIT"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-286","name":"Yin and Yang","url":"http://usaco.org/index.php?page=viewproblem2&cpid=286","source":"Old Gold","difficulty":"Easy","isStarred":false,"tags":["Centroid"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_yinyang.html","sketch":null}},{"uniqueId":"ioi-11-race","name":"2011 - Race","url":"https://oj.uz/problem/view/IOI11_race","source":"IOI","difficulty":"Normal","isStarred":true,"tags":["Centroid","Merging"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"https://ioinformatics.org/page/ioi-2011/37","sketch":null}},{"uniqueId":"usaco-817","name":"New Barns","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=817","source":"Plat","difficulty":"Normal","isStarred":true,"tags":["Centroid"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_newbarn_platinum_feb18.html","sketch":null}},{"uniqueId":"cf-776F","name":"Sherlock's bet to Moriarty","url":"https://codeforces.com/contest/776/problem/F","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Centroid"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-715C","name":"Digit Tree","url":"https://codeforces.com/contest/715/problem/C","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Centroid","NT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1140G","name":"Double Tree","url":"https://codeforces.com/contest/1140/problem/G","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Centroid","DP"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"joi-14-factories","name":"2014 - Factories","url":"https://oj.uz/problem/view/JOI14_factories","source":"JOI","difficulty":"Normal","isStarred":false,"tags":["Centroid"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2014/2014-open-d1-factories-review.pdf","sketch":null}},{"uniqueId":"coci-19-lampice","name":"2019 - Lampice","url":"https://dmoj.ca/problem/coci19c3p4","source":"COCI","difficulty":"Normal","isStarred":false,"tags":["Centroid","Hashing"],"solution":null},{"uniqueId":"dmoj-BobEquilibrium","name":"Bob Equilibrium","url":"https://dmoj.ca/problem/dmopc19c7p6","source":"DMOJ","difficulty":"Hard","isStarred":false,"tags":["Centroid"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"dmoj-TimeTravellerImaxblue","name":"Time Traveller Imaxblue","url":"https://dmoj.ca/problem/tc19summerh","source":"DMOJ","difficulty":"Hard","isStarred":false,"tags":["Centroid"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"joi-13-synchronization","name":"2013 - Synchronization","url":"https://oj.uz/problem/view/JOI13_synchronization","source":"JOI","difficulty":"Hard","isStarred":false,"tags":["Centroid","Small to Large"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-793","name":"Cow At Large","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=793","source":"Plat","difficulty":"Very Hard","isStarred":false,"tags":["Centroid"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}}]}]}},"pageContext":{"id":"centroid"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}