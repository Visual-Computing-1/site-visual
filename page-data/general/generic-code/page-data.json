{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/general/generic-code",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*If you absolutely insist on using `#define` for some reason, though, use it with caution and remember to `#undef` for good scope control.*/\n/*As far as preprocessor magic goes, we are in no way limited to `#define` butchery.*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"generic-code\", redirects = [\"/general/generic\"], title = \"(Optional) C++ - Writing Generic Code\", author = \"Aryansh Shrivastava, Benjamin Qi\", description = \"Writing code that can easily be reused or extended.\", prerequisites = [\"running-code-locally\"];\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    em: \"em\",\n    h3: \"h3\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Warning: _missingComponent(\"Warning\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\")\n  }, _props.components), {HeaderLink, Warning, Resources, Resource, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"templates\",\n      children: [_jsx(_components.a, {\n        href: \"#templates\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Templates\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A \", _jsx(_components.strong, {\n        children: \"template\"\n      }), \" consists of code that is assumed to be in every file. Don't be\\r\\nafraid to write your own template or don't use one at all! Below, we'll give an\\r\\nexample of what a template might look like.\"]\n    }), \"\\n\", _jsx(Warning, {\n      children: _jsx(_components.p, {\n        children: \"USACO rules prohibit the use of pre-written code, including templates.\\r\\nTherefore, make sure you are able to re-type your template in contest (or just\\r\\ndon't use one)!\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Templates in C++ can take advantange of more powerful features (e.g. macros)\\r\\nthan the other contest languages, and they can be more customized to each\\r\\ncompetitor.\"\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"AryanshS\",\n        url: \"https://sendtoaryansh.gitbook.io/informatics-notes/making-a-contest-template\",\n        title: \"Making a Contest Template\"\n      }), _jsx(Resource, {\n        source: \"Benq\",\n        url: \"https://github.com/bqi343/USACO/blob/master/Implementations/content/contest/TemplateLong.cpp\",\n        title: \"TemplateLong\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"//BeginCodeSnip{C++ Short Template}\\n#include <bits/stdc++.h> // see /general/running-code-locally\\nusing namespace std;\\n\\nusing ll = long long;\\n\\nusing vi = vector<int>;\\n#define pb push_back\\n#define all(x) begin(x), end(x)\\n#define sz(x) (int) (x).size()\\n\\nusing pi = pair<int,int>;\\n#define f first\\n#define s second\\n#define mp make_pair\\n\\nvoid setIO(string name = \\\"\\\") {\\n\\tcin.tie(0)->sync_with_stdio(0); // see /general/fast-io\\n\\tif (sz(name)) {\\n\\t\\tfreopen((name + \\\".in\\\").c_str(), \\\"r\\\", stdin); // see /general/input-output\\n\\t\\tfreopen((name + \\\".out\\\").c_str(), \\\"w\\\", stdout);\\n\\t}\\n}\\n//EndCodeSnip\\n\\r\\nint main() {\\r\\n\\tsetIO();\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This module will cover many of the features used in the code above.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"what-is-generic-code\",\n      children: [_jsx(_components.a, {\n        href: \"#what-is-generic-code\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"What Is Generic Code?\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"Aryansh\",\n        url: \"https://sendtoaryansh.gitbook.io/informatics-notes/writing-generic-code\",\n        title: \"Writing Generic Code\",\n        children: _jsx(_components.p, {\n          children: \"Integrated here for enhancement.\"\n        })\n      }), _jsx(Resource, {\n        source: \"LCPP\",\n        url: \"https://www.learncpp.com/\",\n        title: \"Learn C++\",\n        starred: true\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Generic code\"\n      }), \" is an important concept in informatics. Of course, as all\\r\\nconcepts go, you may dodge generic code and continue to write in a\\r\\nhyper-specific style. As such, begin by questioning purpose.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Generic code is \", _jsx(_components.strong, {\n        children: \"adaptable\"\n      }), \", meaning that it can be put to use immediately in\\r\\nmany ways without major changes. It can be reused, extended, and even versioned\\r\\npowerfully to save time. Time is of essence in informatics, where I refer to\\r\\nboth algorithmic time \", _jsx(_components.em, {\n        children: \"complexity\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"coding\"\n      }), \" time.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Even if you are writing a very specific data structure or algorithm, to truly\\r\\ngrasp it, a good contemplation is \\\"Can I generalize what I have learned to a\\r\\nbroader class of problems?\\\" Answer this by then attempting to generalize. That\\r\\nsaid, before you proceed, I issue the below warning:\"\n    }), \"\\n\", _jsx(Warning, {\n      children: _jsxs(_components.p, {\n        children: [\"Generic code can easily assist \", _jsx(_components.strong, {\n          children: \"black-boxing\"\n        }), \", where you write a snippet of\\r\\ncode such that you either forget its meaning or have no idea what it means in\\r\\nthe first place. This is a common pitfall, and you should avoid this as much as\\r\\npossible if you truly want to grasp a concept in informatics.\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Modern C++, a groundbreaking language in the current informatics scene, indeed\\r\\nhas several builtin features to support and streamline generic code. Here, we\\r\\nwill cover the basic important ones you will definitely want to add to your\\r\\ncoding arsenal.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"classes\",\n      children: [_jsx(_components.a, {\n        href: \"#classes\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Classes\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Classes\"\n      }), \" are by far the most important utility in extensible code. If you\\r\\never want to write a data structure that has several member functions to process\\r\\nstored data, classes are for you. Of course, classes can have public and private\\r\\nsections. For instance, consider a class \", _jsx(_components.code, {\n        children: \"Human\"\n      }), \", which maintains several\\r\\nrelevant member functions.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nclass Human {\\r\\n\\tprivate:  // internal properties\\r\\n\\t\\tint body_temp;\\r\\n\\t\\tint temper;\\r\\n\\t\\tstring name;\\r\\n\\t\\r\\n\\tpublic:  // external reactions\\r\\n\\t\\tstring get_name() {\\r\\n\\t\\t\\treturn name;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstring get_feeling() {\\r\\n\\t\\t\\tif (body_temp >= 97 && body_temp <= 99) {\\r\\n\\t\\t\\t\\treturn \\\"good\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn \\\"bad\\\";\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstring get_emotion() {\\r\\n\\t\\t\\tif (temper <= 10) {\\r\\n\\t\\t\\t\\treturn \\\"sad\\\";\\r\\n\\t\\t\\t} else if (temper <= 30) {\\r\\n\\t\\t\\t\\treturn \\\"happy\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn \\\"angry\\\";\\r\\n\\t\\t}\\r\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But how do we actually use (and reuse) this class data structure we have\\r\\ncreated? We do this by creating \", _jsx(_components.em, {\n        children: \"instances\"\n      }), \" of this class, concretely known as\\r\\n\", _jsx(_components.strong, {\n        children: \"objects\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Below is an example instance of the \", _jsx(_components.code, {\n        children: \"Human\"\n      }), \" class named \", _jsx(_components.code, {\n        children: \"sal\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"Human sal;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Of course, we will want to initialize any object of this \", _jsx(_components.code, {\n        children: \"human\"\n      }), \" class with its\\r\\nfundamental attributes (\", _jsx(_components.code, {\n        children: \"body_temperature\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"temper\"\n      }), \" from the above), but\\r\\nthe problem here is that we are unable to access them directly; they are private\\r\\nand remain uninitialized.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To partially alleviate this, we can initialize variables in the class\\r\\ndeclaration itself:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nclass Human {\\r\\n\\tprivate:  // internal properties\\r\\n\\t\\tint body_temp = 98;\\r\\n\\t\\tint temper = 25;\\r\\n\\t\\tstring name = \\\"Sal\\\";\\r\\n\\t\\r\\n\\tpublic:  // external reactions\\r\\n\\t\\tstring get_name() {\\r\\n\\t\\t\\treturn name;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstring get_feeling() {\\r\\n\\t\\t\\tif (body_temp >= 97 && body_temp <= 99) {\\r\\n\\t\\t\\t\\treturn \\\"good\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn \\\"bad\\\";\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstring get_emotion() {\\r\\n\\t\\t\\tif (temper <= 10) {\\r\\n\\t\\t\\t\\treturn \\\"sad\\\";\\r\\n\\t\\t\\t} else if (temper <= 30) {\\r\\n\\t\\t\\t\\treturn \\\"happy\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn \\\"angry\\\";\\r\\n\\t\\t}\\r\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This gives us something to work with, and we can now create \", _jsx(_components.code, {\n        children: \"sal\"\n      }), \" in \", _jsx(_components.code, {\n        children: \"main()\"\n      }), \" as\\r\\nwell as call his member functions (instantiated directly from the base \", _jsx(_components.code, {\n        children: \"Human\"\n      }), \"\\r\\nclass).\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"int main() {\\r\\n    Human sal;\\r\\n\\tcout << sal.get_name()\\r\\n\\t\\t << \\\" feels \\\" << sal.get_feeling()\\r\\n\\t\\t << \\\" and is \\\" << sal.get_emotion()\\r\\n\\t\\t << endl;\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To completely solve this, we might be forced to make these variables public, but\\r\\ninstead we can be more clever and write a \", _jsx(_components.strong, {\n        children: \"constructor\"\n      }), \" function for this\\r\\nclass, essentially a function that is automatically called whenever an instance\\r\\nof the class is created. Constructors are useful when we want to prevent\\r\\nmodification to variables we create but be able to initialize them for use,\\r\\nmaking them naturally the most viable option for proprietary software companies.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can create a constructor for the human class and require initialization of\\r\\nthe variables \", _jsx(_components.code, {\n        children: \"body_temperature\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"temper\"\n      }), \", which gives us some control over\\r\\n\", _jsx(_components.code, {\n        children: \"Sal\"\n      }), \"'s intrinsic properties as they are initialized. The overall code becomes:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nclass Human {\\r\\n\\tprivate:  // internal properties\\r\\n\\t\\tint body_temp;\\r\\n\\t\\tint temper;\\r\\n\\t\\tstring name;\\r\\n\\t\\r\\n\\tpublic:  // external reactions\\r\\n\\t\\tHuman(string name_, int body_temp_, int temper_) {\\r\\n\\t\\t\\tname = name_;\\r\\n\\t\\t\\tbody_temp = body_temp_;\\r\\n\\t\\t\\ttemper = temper_;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstring get_name() {\\r\\n\\t\\t\\treturn name;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstring get_feeling() {\\r\\n\\t\\t\\tif (body_temp >= 97 && body_temp <= 99) {\\r\\n\\t\\t\\t\\treturn \\\"good\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn \\\"bad\\\";\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tstring get_emotion() {\\r\\n\\t\\t\\tif (temper <= 10) {\\r\\n\\t\\t\\t\\treturn \\\"sad\\\";\\r\\n\\t\\t\\t} else if (temper <= 30) {\\r\\n\\t\\t\\t\\treturn \\\"happy\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn \\\"angry\\\";\\r\\n\\t\\t}\\r\\n};\\r\\n\\r\\nint main() {\\r\\n    Human sal(\\\"Sal\\\", 98, 25);\\r\\n\\tcout << sal.get_name()\\r\\n\\t\\t << \\\" feels \\\" << sal.get_feeling()\\r\\n\\t\\t << \\\" and is \\\" << sal.get_emotion()\\r\\n\\t\\t << endl;\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is immediately very extensible if we wish to create multiple instances of\\r\\n\", _jsx(_components.code, {\n        children: \"human\"\n      }), \", all with their own initial properties. In fact, we can be even more\\r\\ngeneral by creating an external function condition that easily states feelings\\r\\nand emotions for us without having to be rewritten.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"// Prints out the condition of a human to cout\\r\\nvoid condition(Human h) {\\r\\n\\tcout << h.get_name()\\r\\n\\t\\t << \\\" feels \\\" << h.get_feeling()\\r\\n\\t\\t << \\\" and is \\\" << h.get_emotion()\\r\\n\\t\\t << endl;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tHuman sal(\\\"Sal\\\", 98, 25);\\r\\n\\tHuman bob(\\\"Bob\\\", 100, 9);\\r\\n\\tHuman joe(\\\"Joe\\\", 85, 35);\\r\\n\\t// Print out the conditions of all three people\\r\\n\\tcondition(sal);\\r\\n\\tcondition(bob);\\r\\n\\tcondition(joe);\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As one very specific but useful note on constructors, when we wish to merely\\r\\ninitialize properties, we can adopt an alternative declaration that executes\\r\\nsignificantly faster than the first; using the argument name as the variable\\r\\nitself also becomes permissible and is guaranteed defined behavior:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"Human(string name, int body_temp, int temper) :\\r\\n\\t\\tname(name),\\r\\n\\t\\tbody_temp(body_temp),\\r\\n\\t\\ttemper(temper) { }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"structs\",\n      children: [_jsx(_components.a, {\n        href: \"#structs\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Structs\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Structs\"\n      }), \" are useful when we care less about keeping private properties and\\r\\nmore about having just a general reusable data structure. This means everything\\r\\nis public in a struct by default, and a \", _jsx(_components.code, {\n        children: \"human\"\n      }), \" struct, along with the\\r\\nreformatted constructor above, would look like:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"struct Human {\\r\\n\\tint body_temp;\\r\\n\\tint temper;\\r\\n\\tstring name;\\r\\n\\t\\r\\n\\tHuman(string name_, int body_temp_, int temper_) {\\r\\n\\t\\tname = name_;\\r\\n\\t\\tbody_temp = body_temp_;\\r\\n\\t\\ttemper = temper_;\\r\\n\\t}\\r\\n\\r\\n\\tstring get_name() {\\r\\n\\t\\treturn name;\\r\\n\\t}\\r\\n\\r\\n\\tstring get_feeling() {\\r\\n\\t\\tif (body_temp >= 97 && body_temp <= 99) {\\r\\n\\t\\t\\treturn \\\"good\\\";\\r\\n\\t\\t}\\r\\n\\t\\treturn \\\"bad\\\";\\r\\n\\t}\\r\\n\\r\\n\\tstring get_emotion() {\\r\\n\\t\\tif (temper <= 10) {\\r\\n\\t\\t\\treturn \\\"sad\\\";\\r\\n\\t\\t} else if (temper <= 30) {\\r\\n\\t\\t\\treturn \\\"happy\\\";\\r\\n\\t\\t}\\r\\n\\t\\treturn \\\"angry\\\";\\r\\n\\t}\\r\\n};\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Immediately, our struct is easier to manage given its open nature. It is more\\r\\nintegrated with the surrounding code, and we can do manipulations like the following:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"int main() {\\r\\n\\t// Initialize Sal\\r\\n\\tHuman sal(\\\"Sal\\\", 98, 25);\\r\\n\\tcondition(sal);  // Get Sal's initial condition\\r\\n\\tsal.name = \\\"Sally\\\";  // Sal's friends sometimes call him Sally\\r\\n\\tsal.body_temp = 102;  // Sal gets sick\\r\\n\\tsal.temper = 40;  // He develops a bad temper due to his sickness\\r\\n\\tcondition(sal);  // Now we get Sal's new condition\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, we can choose to discard the constructor altogether and opt for an\\r\\ninitializer list based on the \", _jsx(_components.em, {\n        children: \"order\"\n      }), \" of the declaration of intrinsic variables.\\r\\nIn the \", _jsx(_components.code, {\n        children: \"Human\"\n      }), \" case, the variables in order are \", _jsx(_components.code, {\n        children: \"body_temp\"\n      }), \", \", _jsx(_components.code, {\n        children: \"temper\"\n      }), \",\\r\\nand \", _jsx(_components.code, {\n        children: \"name\"\n      }), \", so we can remove the constructor and opt for an initializer list\\r\\nlike:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"human Sal{98, 25, \\\"Sal\\\"};\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Needless to say, all of this enables very clean initialization and manipulation\\r\\nof classes and structs, integral to generic code.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"templates-1\",\n      children: [_jsx(_components.a, {\n        href: \"#templates-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Templates\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"LCPP\",\n        title: \"13.1 - Function Templates\",\n        url: \"https://www.learncpp.com/cpp-tutorial/131-function-templates/\"\n      }), _jsx(Resource, {\n        source: \"LCPP\",\n        title: \"13.3 - Template Classes\",\n        url: \"https://www.learncpp.com/cpp-tutorial/133-template-classes/\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"Human\"\n      }), \" class example, though well-defined, was mostly intended to serve as\\r\\nan example of the versatility of classes and structs. We now switch to something\\r\\nsimpler. Imagine a three-dimensional point in space as the following struct and\\r\\ntwo of the said 3D points: \", _jsx(_components.code, {\n        children: \"p1\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"p2\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"struct Point3D {\\r\\n\\tint x;\\r\\n\\tint y;\\r\\n\\tint z;\\r\\n} p1{1, 2, 3}, p2{3, 4, 5};  // We can make some instances right before the ;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But what if we wanted to make a point \", _jsx(_components.code, {\n        children: \"p3\"\n      }), \" with coordinates as doubles? We would\\r\\nthen be forced to create a secondary point struct \", _jsx(_components.code, {\n        children: \"pt1\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"struct Point3D {\\r\\n\\tint x;\\r\\n\\tint y;\\r\\n\\tint z;\\r\\n} p1{1, 2, 3}, p2{3, 4, 5};\\r\\n\\r\\nstruct Point3DDouble {\\r\\n\\tdouble x;\\r\\n\\tdouble y;\\r\\n\\tdouble z;\\r\\n} p3{1.1, 2.2, 3.3};\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This might not seem too bad immediately, but imagine having to create structs\\r\\nlike this over and over again just to accommodate various type changes. We need\\r\\nsomething better.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Lo and behold, we have the \", _jsx(_components.strong, {\n        children: \"template\"\n      }), \" to come to our rescue. We can use the format\\r\\n\", _jsx(_components.code, {\n        children: \"template<...>\"\n      }), \" to specify the specific templating conditions and then simply\\r\\ndefine the struct normally. In particular, if we use a class \", _jsx(_components.code, {\n        children: \"T\"\n      }), \", we achieve:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"template<class T>\\r\\nstruct Point3D {\\r\\n\\tT x;\\r\\n\\tT y;\\r\\n\\tT z;\\r\\n};\\r\\n\\r\\nPoint3D<int> p1{1, 2, 3};\\r\\nPoint3D<int> p2{3, 4, 5};\\r\\nPoint3D<double> p3{1.1, 2.2, 3.3};\\r\\nPoint3D<long long> p4{\\r\\n\\t9223372036854775807, 9223372036854775807, 9223372036854775807\\r\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It would be narrow-minded to think that templates are in any way limited to\\r\\nclasses and structs. They can be used with functions and much more. For example,\\r\\ntake a look at this function \", _jsx(_components.code, {\n        children: \"ckmin\"\n      }), \":\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"/**\\r\\n * If b is less than a, this changes the value of a to that of b\\r\\n * and returns true. If not, the function simply returns false.\\r\\n */\\r\\ntemplate<class T>\\r\\nbool ckmin(T& a, const T& b) {\\r\\n\\tif (b < a) {\\r\\n\\t\\ta = b;\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\treturn false;\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"One interesting use case is that of the size of various containers. The size\\r\\nmember function of a container usually returns a type incompatible with \", _jsx(_components.code, {\n        children: \"int\"\n      }), \",\\r\\nbut we can easily write a templated function to fix this, handling all types\\r\\nof containers at once:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"template<class T>\\r\\nint sz(T container) {\\r\\n\\treturn (int) container.size();\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can call this through typing \", _jsx(_components.code, {\n        children: \"sz<vector<int>>(v)\"\n      }), \" where \", _jsx(_components.code, {\n        children: \"v\"\n      }), \" is a\\r\\n\", _jsx(_components.code, {\n        children: \"vector<int>\"\n      }), \", but since C++11, functions (but not classes or structs\\r\\nuntil C++14 and C++17) can actually infer template arguments, meaning\\r\\nthat we can simply use \", _jsx(_components.code, {\n        children: \"sz(v)\"\n      }), \"!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"What if we wanted to put multiple arguments in a template to handle multiple\\r\\nclasses? Consider the below secondary pair comparator struct as an example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"struct CPS {\\r\\n\\ttemplate<class T, class U>\\r\\n\\tbool operator() (const pair<T, U>& a, const pair<T, U>& b) {\\r\\n\\t\\treturn make_pair(a.second, a.first) < make_pair(b.second, b.first);\\r\\n\\t}\\r\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"And in this design, since the template arguments both apply to only a function,\\r\\nthey can be easily inferred! For instance, declaring a set of\\r\\n\", _jsx(_components.code, {\n        children: \"pair<double, int>\"\n      }), \" in C++11 is as easy as \", _jsx(_components.code, {\n        children: \"set<pair<double, int>, CPS>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"What constitutes what other kinds of types we can put in templates? As a general\\r\\nrule of thumb, until C++17, the types valid in template arguments are only\\r\\nclasses and fundamental types, of which only classes can be directly inferred in\\r\\nmany cases by functions.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In fact, we can even have templates that take a variable number of arguments,\\r\\nknown as variadic templates, or templates within templates, known as nested\\r\\ntemplates, both of which are beyond the scope of this basic exposition but can\\r\\nbe found \", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/language/parameter_pack\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"here\"\n      }), \" and\\r\\n\", _jsx(_components.a, {\n        href: \"https://blog.feabhas.com/2014/08/templates-of-templates/\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"here\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As a fun fact, just as templates give us so much control over the generality of\\r\\nthe language, a lot of the C++ standard in itself is written generically with\\r\\ntemplates under the hood.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"type-aliases-with-using\",\n      children: [_jsx(_components.a, {\n        href: \"#type-aliases-with-using\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Type Aliases With \", _jsx(_components.code, {\n        children: \"using\"\n      })]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"LCPP\",\n        title: \"6.13 - Typedefs and type aliases\",\n        url: \"https://www.learncpp.com/cpp-tutorial/typedefs-and-type-aliases/\",\n        starred: true\n      }), _jsx(Resource, {\n        source: \"Quora\",\n        title: \"Difference between 'typedef' and 'using' in C++?\",\n        url: \"https://www.quora.com/What-is-the-difference-between-typedef-and-using-in-C++\"\n      }), _jsx(Resource, {\n        source: \"CPPR\",\n        title: \"Type Alias\",\n        url: \"https://en.cppreference.com/w/cpp/language/type_alias\",\n        children: _jsx(_components.p, {\n          children: \"documention for using\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"typedef\"\n      }), \" is now rather outdated (though still used by some) because it is\\r\\nmore or less just an annoying version of \", _jsx(_components.code, {\n        children: \"using\"\n      }), \" with frustrating semantics, so\\r\\nwe will not cover it here.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"using\"\n      }), \" is a fascinating keyword, frequently used to simplify namespace\\r\\nprefixing when applicable. For instance, statements like\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"using namespace std;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"actually allow us to use an entire namespace. Of course, since\\r\\n\", _jsx(_components.code, {\n        children: \"using namespace std\"\n      }), \" is frequently limited to the competitive programming\\r\\ncommunity and looked down upon otherwise, we can use \", _jsx(_components.code, {\n        children: \"using\"\n      }), \" to invoke better\\r\\nsimplifications.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Suppose that a lot of my code uses\", _jsx(_components.code, {\n        children: \"std::cout\"\n      }), \", which I find frustrating to type.\\r\\nI can write\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"using std::cout;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"and then just live with \", _jsx(_components.code, {\n        children: \"cout\"\n      }), \". But what if I was using strings and wanted to\\r\\ntype neither \", _jsx(_components.code, {\n        children: \"std::string\"\n      }), \" nor \", _jsx(_components.code, {\n        children: \"string\"\n      }), \"? I could use \", _jsx(_components.code, {\n        children: \"using\"\n      }), \" twice to fix this:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"using std::string;  // Unnecessary if already using namespace std\\r\\nusing str = string;  // Use str as an alias for string\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Or I could compress this into a single statement:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"using str = std::string;  // str is an alias for std::string directly\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can make even more aliases, with even aliases within aliases (see \", _jsx(_components.code, {\n        children: \"ll\"\n      }), \"),\\r\\nfor environments where speed is key, such as competitive programming:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"using namespace std;\\r\\nusing ll = long long;\\r\\nusing str = string;\\r\\nusing pii = pair<int, int>;\\r\\nusing pll = pair<ll, ll>;\\r\\nusing vi = vector<int>;\\n\"\n      })\n    }), \"\\n\", _jsx(Warning, {\n      children: _jsx(_components.p, {\n        children: \"If you use too many type aliases or macros then your code will become unreadable\\r\\nto anyone besides yourself!\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, we can take \", _jsx(_components.code, {\n        children: \"using\"\n      }), \" to the next step and invoke templates! For\\r\\ninstance, if we want to be able to write \", _jsx(_components.code, {\n        children: \"arr<int, 6>\"\n      }), \" instead of\\r\\n\", _jsx(_components.code, {\n        children: \"std::array<int, 6>\"\n      }), \", we write:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"template<class T, int SZ> using arr = std::array<T, SZ>;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As another example, if we want to use \", _jsx(_components.code, {\n        children: \"ai\"\n      }), \" to mean integer array, we can make\\r\\nconstructions like \", _jsx(_components.code, {\n        children: \"ai<6>\"\n      }), \" work as well:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"template<int SZ> using ai = std::array<int, SZ>;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In general, it is important that \", _jsx(_components.code, {\n        children: \"using\"\n      }), \" declarations have strong \", _jsx(_components.strong, {\n        children: \"scope\"\n      }), \"\\r\\nguarantees, meaning that they will not work outside of their defined scope. To\\r\\nuse declarations everywhere in the program, they must be invoked in global\\r\\nscope. But, if we want to be clever and create a reusable struct and just\\r\\nspecify template arguments internally, we always have the option of:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"struct Point {\\r\\n\\tusing T = int;\\r\\n\\t/*\\r\\n\\t * Within this scope, T is an alias for int.\\r\\n\\t * Just change this declaration to change T's meaning within this struct\\r\\n\\t */\\r\\n\\tT x;\\r\\n\\tT y;\\r\\n\\tT z;\\r\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In case we want to be able to access the specific type \", _jsx(_components.code, {\n        children: \"T\"\n      }), \"'s alias meaning\\r\\noutside of \", _jsx(_components.code, {\n        children: \"Point\"\n      }), \", this too becomes very easy:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"struct Point {\\r\\n\\tusing T = int;\\r\\n\\tT x;\\r\\n\\tT y;\\r\\n\\tT z;\\r\\n};\\r\\n\\r\\nint main() {\\r\\n\\t// U becomes a copy of T from Point's scope and is now in the scope of main\\r\\n\\tusing U = Point::T;\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"macros\",\n      children: [_jsx(_components.a, {\n        href: \"#macros\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Macros\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We end this section off with \", _jsx(_components.code, {\n        children: \"#define\"\n      }), \", which is used to define \", _jsx(_components.strong, {\n        children: \"macros\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CPH\",\n        title: \"1.4 - Shortening Code\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"simple examples of macros, describes a common bug\"\n        })\n      }), _jsx(Resource, {\n        source: \"GCC\",\n        url: \"https://gcc.gnu.org/onlinedocs/cpp/Macros.html\",\n        title: \"Online Docs - Macros\",\n        children: _jsx(_components.p, {\n          children: \"reference\"\n        })\n      }), _jsx(Resource, {\n        source: \"GFG\",\n        url: \"cc-preprocessors\",\n        title: \"Macros\"\n      }), _jsx(Resource, {\n        source: \"LCPP\",\n        url: \"https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/\",\n        title: \"2.10 - Intro to the Preprocessor\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"#define\"\n      }), \" is essentially a crude find-and-replace that happens before compile\\r\\ntime (in the preprocessor stage). In this sense, it is easy to use, where\\r\\n\", _jsx(_components.code, {\n        children: \"#define NAME VALUE\"\n      }), \" would ideally find all instances of \", _jsx(_components.code, {\n        children: \"NAME\"\n      }), \" in the code and\\r\\nreplace them with \", _jsx(_components.code, {\n        children: \"VALUE\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This example defines \", _jsx(_components.code, {\n        children: \"MOD\"\n      }), \" as \", _jsx(_components.code, {\n        children: \"1e9 + 7\"\n      }), \" by find and replace.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#define MOD 1e9 + 7\\r\\n\\r\\nint main() {\\r\\n\\tcout << int(MOD) << \\\"\\\\n\\\";  // outputs 1000000007\\r\\n\\tcout << int(MOD * 2) << \\\"\\\\n\\\";  // outputs 1000000014\\r\\n\\tcout << int(2 * MOD) << \\\"\\\\n\\\";  // outputs 2000000007\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But that's obviously not a good idea. A better alternative is the following:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"const int MOD = 1e9 + 7;\\r\\n\\r\\nint main() {\\r\\n\\tcout << MOD << \\\"\\\\n\\\";\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Resources, {\n      children: _jsx(Resource, {\n        source: \"LCPP\",\n        title: \"4.13 - Const, constexpr, symbolic constants\",\n        url: \"https://www.learncpp.com/cpp-tutorial/const-constexpr-and-symbolic-constants/\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Also, \", _jsx(_components.code, {\n        children: \"using\"\n      }), \" is preferable to \", _jsx(_components.code, {\n        children: \"#define\"\n      }), \". For example, the following code with\\r\\n\", _jsx(_components.code, {\n        children: \"#define\"\n      }), \" will not compile (but it will with \", _jsx(_components.code, {\n        children: \"using\"\n      }), \").\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#define ll long long\\r\\n// using ll = long long;\\r\\n\\r\\nint main() {\\r\\n\\tcout << ll(1e18);\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The takeaway from this is to avoid \", _jsx(_components.code, {\n        children: \"#define\"\n      }), \" when possible. Of course, some competitive\\r\\nprogrammers use macros extensively. Some examples are presented below.\"]\n    }), \"\\n\", \"\\n\", _jsxs(_components.h3, {\n      id: \"pairs\",\n      children: [_jsx(_components.a, {\n        href: \"#pairs\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Pairs\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"using pi = pair<int,int>;\\r\\n#define mp make_pair\\r\\n#define f first\\r\\n#define s second\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It might be annoying to keep on typing \", _jsx(_components.code, {\n        children: \"first\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"second\"\n      }), \",\\r\\nespecially if you have nested pairs. These macros fix that.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"vectors\",\n      children: [_jsx(_components.a, {\n        href: \"#vectors\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Vectors\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"using vi = vector<int>;\\r\\n#define sz(x) int((x).size())\\r\\n#define all(x) begin(x), end(x)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We convert a size to a signed integer to avoid unsigned overflow, as\\r\\nshown by this example:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"vi x;\\r\\ncout << x.size() - 1 << \\\"\\\\n\\\"; // otutputs 18446744073709551615 (incorrect)\\r\\ncout << sz(x) - 1 << \\\"\\\\n\\\"; // outputs -1 (correct)\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"all(v)\"\n      }), \" makes sorting part or all of a vector a bit shorter.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"vi v{2, 4, 1, 5, 3};\\r\\nsort(1 + all(v));  // v is now {2, 1, 3, 4, 5}\\r\\n// This expands to sort(1 + begin(v), end(v));\\r\\nsort(all(v));  // {1, 2, 3, 4, 5}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"preprocessing-logic\",\n      children: [_jsx(_components.a, {\n        href: \"#preprocessing-logic\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Preprocessing Logic\"]\n    }), \"\\n\", \"\\n\", _jsxs(_components.p, {\n      children: [\"Ever wanted to write a program that compiles in different ways depending on some\\r\\ninitial conditions? We can use preprocessor directives like \", _jsx(_components.code, {\n        children: \"#if\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"#else\"\n      }), \",\\r\\nor \", _jsx(_components.code, {\n        children: \"#ifdef\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"#ifndef\"\n      }), \" to allow for this.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For instance, I may want my struct \", _jsx(_components.code, {\n        children: \"Point\"\n      }), \" to be two-dimensional in some cases\\r\\nand three-dimensional in others. I can do this like so:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"const bool d2 = false;  // false for 2D, true for 3D\\r\\n\\r\\ntemplate<class T>\\r\\nstruct Point {\\r\\n\\t#if(d2)\\r\\n\\t\\tT x;\\r\\n\\t\\tT y;\\r\\n\\t#else\\r\\n\\t\\tT x;\\r\\n\\t\\tT y;\\r\\n\\t\\tT z;\\r\\n\\t#endif\\r\\n};\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If we are not opposed to using \", _jsx(_components.code, {\n        children: \"#define\"\n      }), \", we could use \", _jsx(_components.code, {\n        children: \"#ifdef\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"#ifndef\"\n      }), \" to\\r\\nsee whether or not a macro is defined via \", _jsx(_components.code, {\n        children: \"#define\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"// #define 2D  // Uncomment to make Point 2D\\r\\n\\r\\ntemplate<class T>\\r\\nstruct Point {\\r\\n\\t#ifdef 2D\\r\\n\\t\\tT x;\\r\\n\\t\\tT y;\\r\\n\\t#else\\r\\n\\t\\tT x;\\r\\n\\t\\tT y;\\r\\n\\t\\tT z;\\r\\n\\t#endif\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are many clever applications of this, including versioning. Importantly,\\r\\nif we want code to run differently for different versions of C++, we can write:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#if(__cplusplus < 201703L)\\r\\n\\t/**\\r\\n\\t * \\\"Clamps\\\" v between the values of lo and hi if it's\\r\\n\\t * out of the bounds defined by those two values.\\r\\n\\t */\\r\\n\\ttemplate<class T>\\r\\n\\tconstexpr const T& clamp(const T& v, const T& lo, const T& hi) {\\r\\n\\t\\tassert(lo <= hi);\\r\\n\\t\\tif (v < lo) {\\r\\n\\t\\t\\treturn lo;\\r\\n\\t\\t} else if (hi < v) {\\r\\n\\t\\t\\treturn hi;\\r\\n\\t\\t}\\r\\n\\t\\treturn v;\\r\\n\\t}\\r\\n#endif\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"namespaces\",\n      children: [_jsx(_components.a, {\n        href: \"#namespaces\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Namespaces\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, we can write our own namespaces to separate various functions. Within a\\r\\nnamespace, we can have functions, variables, classes, and even more namespaces.\\r\\nThen, we can invoke \", _jsx(_components.code, {\n        children: \"using\"\n      }), \" declarations to use the whole namespace.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"namespace test {\\r\\n\\tconst string greeting = \\\"hi\\\";\\r\\n\\tnamespace test1 {\\r\\n\\t\\tconst int time = 2;\\r\\n\\t} using namespace test1;\\r\\n\\r\\n\\ttemplate<class T> struct TestDS {\\r\\n\\t\\tT s;\\r\\n\\r\\n\\t\\tvoid add(T x) { s += x; }\\r\\n\\r\\n\\t\\tT get() { return s; }\\r\\n\\t};\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These are fairly self-explanatory, but a more rare feature of C++11 is the\\r\\n\", _jsx(_components.code, {\n        children: \"inline namespace\"\n      }), \". Inline namespaces are not technically real namespaces but\\r\\nallow us to chunk up code and avoid having to use namespaces just to gain\\r\\naccess.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"inline namespace test {\\r\\n\\tconst string greeting = \\\"hi\\\";\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So why even have inline namespaces? We can use their features interestingly. For\\r\\ninstance, suppose we had a feature in an old version \", _jsx(_components.code, {\n        children: \"v1\"\n      }), \" of a program but now\\r\\nremoved it in the new version \", _jsx(_components.code, {\n        children: \"v2\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"namespace v1 {\\r\\n\\tconst string buggy_feature = \\\"bugs\\\";\\r\\n\\tconst string greeting = \\\"hi\\\";\\r\\n}\\r\\n\\r\\ninline namespace v2 {\\r\\n\\t// removed the buggy_feature from this new version\\r\\n\\tconst string buggy_feature = \\\"what buggy feature?\\\";\\r\\n\\tconst string greeting = \\\"hi\\\";\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcout << buggy_feature << \\\"\\\\n\\\";  // outputs \\\"what buggy feature?\\\"\\r\\n\\tcout << v1::buggy_feature << \\\"\\\\n\\\";  // outputs \\\"bugs\\\"\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, not using a namespace will automatically use \", _jsx(_components.code, {\n        children: \"v2\"\n      }), \". But if we want access to\\r\\n\", _jsx(_components.code, {\n        children: \"v1\"\n      }), \" of the \", _jsx(_components.code, {\n        children: \"buggy_feature\"\n      }), \", we can simply write \", _jsx(_components.code, {\n        children: \"v1::buggy_feature\"\n      }), \". There you\\r\\nhave it, simple and effective version control!\"]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  redirects,\n  title,\n  author,\n  description,\n  prerequisites,\n  default: MDXContent\n};\n","frontmatter":{"title":"(Optional) C++ - Writing Generic Code","author":"Aryansh Shrivastava, Benjamin Qi","contributors":null,"id":"generic-code","prerequisites":["running-code-locally"],"description":"Writing code that can easily be reused or extended.","frequency":null},"parent":{"name":"Generic_Code","relativePath":"1_General/Generic_Code.mdx"},"fields":{"division":"general"},"toc":{"cpp":[{"depth":2,"value":"Templates","slug":"templates"},{"depth":2,"value":"What Is Generic Code?","slug":"what-is-generic-code"},{"depth":2,"value":"Classes","slug":"classes"},{"depth":2,"value":"Structs","slug":"structs"},{"depth":2,"value":"Templates","slug":"templates-1"},{"depth":2,"value":"Type Aliases With using","slug":"type-aliases-with-using"},{"depth":2,"value":"Macros","slug":"macros"},{"depth":3,"value":"Pairs","slug":"pairs"},{"depth":3,"value":"Vectors","slug":"vectors"},{"depth":2,"value":"Preprocessing Logic","slug":"preprocessing-logic"},{"depth":2,"value":"Namespaces","slug":"namespaces"}],"java":[{"depth":2,"value":"Templates","slug":"templates"},{"depth":2,"value":"What Is Generic Code?","slug":"what-is-generic-code"},{"depth":2,"value":"Classes","slug":"classes"},{"depth":2,"value":"Structs","slug":"structs"},{"depth":2,"value":"Templates","slug":"templates-1"},{"depth":2,"value":"Type Aliases With using","slug":"type-aliases-with-using"},{"depth":2,"value":"Macros","slug":"macros"},{"depth":3,"value":"Pairs","slug":"pairs"},{"depth":3,"value":"Vectors","slug":"vectors"},{"depth":2,"value":"Preprocessing Logic","slug":"preprocessing-logic"},{"depth":2,"value":"Namespaces","slug":"namespaces"}],"py":[{"depth":2,"value":"Templates","slug":"templates"},{"depth":2,"value":"What Is Generic Code?","slug":"what-is-generic-code"},{"depth":2,"value":"Classes","slug":"classes"},{"depth":2,"value":"Structs","slug":"structs"},{"depth":2,"value":"Templates","slug":"templates-1"},{"depth":2,"value":"Type Aliases With using","slug":"type-aliases-with-using"},{"depth":2,"value":"Macros","slug":"macros"},{"depth":3,"value":"Pairs","slug":"pairs"},{"depth":3,"value":"Vectors","slug":"vectors"},{"depth":2,"value":"Preprocessing Logic","slug":"preprocessing-logic"},{"depth":2,"value":"Namespaces","slug":"namespaces"}]}},"moduleProblemLists":{"problemLists":[]}},"pageContext":{"id":"generic-code"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}