{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/gold/mst",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*Prim's is recommended; Kruskal's algorithm might TLE*/\n/*<Resource source=\"PAPS\" title=\"12.4 - Kruskal's\">\ndescription, example, explanation of correctness\n</Resource>*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"mst\", title = \"Minimum Spanning Trees\", author = \"Benjamin Qi, Andrew Wang, Kuan-Hung Chen\", contributors = \"Neo Wang\", prerequisites = [\"shortest-paths\", \"dsu\"], description = \"A subset of the edges of a connected, undirected, edge-weighted graph that connects all the vertices to each other of minimum total weight, where no cycles are allowed.\", frequency = 2;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    h2: \"h2\",\n    a: \"a\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    Problems: _missingComponent(\"Problems\"),\n    Info: _missingComponent(\"Info\")\n  }, _props.components), {FocusProblem, HeaderLink, Resources, Resource, MATHSPAN, LanguageSection, CPPSection, JavaSection, PySection, Problems, Info, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"To review a couple of terms:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"An \", _jsx(_components.strong, {\n          children: \"undirected edge\"\n        }), \" is an edge that goes both ways\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"connected graph\"\n        }), \" is a graph of vertices such that each vertex can reach\\r\\nevery other vertex using undirected edges.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"spanning tree\"\n        }), \" is a set of edges that forms a tree and contains every\\r\\nvertex in the original graph\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"A \", _jsx(_components.strong, {\n          children: \"minimum spanning tree\"\n        }), \" is a spanning tree such that the sum of edge\\r\\nweights are minimized\"]\n      }), \"\\n\"]\n    }), \"\\n\", \"\\n\", _jsx(FocusProblem, {\n      problem: \"standard\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"kruskals\",\n      children: [_jsx(_components.a, {\n        href: \"#kruskals\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Kruskal's\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CPH\",\n        title: \"15.1 - Kruskal's\",\n        starred: true\n      }), _jsx(Resource, {\n        source: \"cp-algo\",\n        title: \"Kruskal's\",\n        url: \"graph/mst_kruskal.html\"\n      }), _jsx(Resource, {\n        source: \"cp-algo\",\n        title: \"Kruskal's with DSU\",\n        url: \"graph/mst_kruskal_with_dsu.html\"\n      }), _jsx(Resource, {\n        source: \"CP2\",\n        title: \"4.3.2 - Kruskal's\"\n      })]\n    }), \"\\n\", \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Kruskal's Algorithm\"\n      }), \" finds the MST by greedily adding edges. For all edges\\r\\nnot yet in the MST, we can repeatedly add the edge of minimum weight to the MST\\r\\nexcept when adding edges that would forms a cycle. This can be done by sorting\\r\\nthe edges in order of non-decreasing weight. Furthermore, we can easily\\r\\ndetermine whether adding an edge will create a cycle in constant time using\\r\\n\", _jsx(_components.a, {\n        href: \"/gold/dsu\",\n        children: \"Union Find\"\n      }), \". Note that since the most expensive operation is sorting\\r\\nthe edges, the computational complexity of Kruskal's Algorithm is\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(E \\\\log E)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>E</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(E \\\\log E)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">E</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">E</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(CPPSection, {\n        children: [_jsx(Resources, {\n          children: _jsx(Resource, {\n            source: \"Benq (from KACTL)\",\n            url: \"https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/DSU/DSU%20(7.6).h\",\n            title: \"DSU\",\n            children: _jsx(_components.p, {\n              children: \"Disjoint Set Union + Kruskal\"\n            })\n          })\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include \\\"DSU.h\\\"\\r\\n\\r\\ntemplate<class T> T kruskal(int N, vector<pair<T,pi>> ed) {\\r\\n\\tsort(all(ed));\\r\\n\\tT ans = 0; DSU D; D.init(N); // edges that unite are in MST\\r\\n\\ttrav(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;\\r\\n\\treturn ans;\\r\\n}\\n\"\n          })\n        })]\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"public static HashMap<Integer, ArrayList<Integer>> MST;\\r\\npublic static PriorityQueue<Edge> pq; //contains all edges\\r\\n\\r\\n//Assumes that DSU code is included\\r\\npublic static void kruskal() {\\r\\n\\twhile (!pq.isEmpty()) {\\r\\n\\t\\tEdge e = pq.poll();\\r\\n\\t\\tif (find(e.start) != find(e.end)) {\\r\\n\\t\\t\\tMST.get(e.start).add(e.end);\\r\\n\\t\\t\\tMST.get(e.end).add(e.start);\\r\\n\\t\\t\\tunion(e.start, e.end);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nstatic class Edge implements Comparable<Edge> {\\r\\n\\tint start,\\r\\n\\tend,\\r\\n\\tweight;\\r\\n\\tpublic Edge(int s, int e, int w) {\\r\\n\\t\\tstart = s;\\r\\n\\t\\tend = e;\\r\\n\\t\\tweight = w;\\r\\n\\t}\\r\\n\\tpublic int compareTo(Edge o) {\\r\\n\\t\\tif (this.weight > o.weight) {\\r\\n\\t\\t\\treturn 1;\\r\\n\\t\\t} else if (this.weight == o.weight) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"solution---road-reparation\",\n      children: [_jsx(_components.a, {\n        href: \"#solution---road-reparation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution - Road Reparation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Notice that the road that allows for a \\\"decent route between any two cities,\\\"\\r\\nwith cost \\\"as small as possible\\\" is the definition of a minimum spanning tree.\\r\\nThus, we can use our favorite minimum spanning tree algorithm to determine the\\r\\ncost of such a tree by calculating \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\sum c\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>∑</mo><mi>c</mi></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\sum c</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mop op-symbol small-op\\\" style=\\\"position:relative;top:0em;\\\">∑</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">c</span></span></span></span>\"\n      }), \" for all edges included in the tree.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, we must also account for the impossible case, which occurs when any\\r\\nnodes cannot be connected to the tree. Recall that the minimum spanning tree\\r\\nmust contain a total of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n-1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">n-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" edges, so we can use a variable \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"cnt\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=\\\"application/x-tex\\\">cnt</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6151em;\\\"></span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mord mathnormal\\\">t</span></span></span></span>\"\n      }), \" that is\\r\\nincremented every time we add an edge to the minimum spanning tree. After\\r\\nrunning Kruskal's, if \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"cnt \\\\ne n-1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo mathvariant=\\\"normal\\\">≠</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">cnt \\\\ne n-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8889em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mord mathnormal\\\">t</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\"><span class=\\\"mrel\\\"><span class=\\\"mord vbox\\\"><span class=\\\"thinbox\\\"><span class=\\\"rlap\\\"><span class=\\\"strut\\\" style=\\\"height:0.8889em;vertical-align:-0.1944em;\\\"></span><span class=\\\"inner\\\"><span class=\\\"mord\\\"><span class=\\\"mrel\\\"></span></span></span><span class=\\\"fix\\\"></span></span></span></span></span><span class=\\\"mrel\\\">=</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \", then we know that we failed to built the\\r\\ntree properly. Furthermore, since our minimum spanning tree algorithm gurantees\\r\\nno edges are counted twice, we cannot \\\"accidentally\\\" count \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n-1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">n-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" edges.\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <algorithm>\\r\\nusing namespace std;\\r\\n\\r\\ntypedef long long ll;\\r\\ntypedef pair<int, int> pi;\\r\\ntypedef vector<int> vi;\\r\\n\\r\\n#define trav(a,x) for (auto& a: x)\\r\\n#define all(x) begin(x), end(x)\\r\\n#define mp make_pair\\r\\n#define f first\\r\\n#define s second\\r\\n\\r\\nstruct DSU {\\r\\n\\tvi e; void init(int N) { e = vi(N,-1); }\\r\\n\\t// get representive component, uses path compression\\r\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\r\\n\\tbool sameSet(int a, int b) { return get(a) == get(b); }\\r\\n\\tint size(int x) { return -e[get(x)]; }\\r\\n\\tbool unite(int x, int y) { // union by size\\r\\n\\t\\tx = get(x), y = get(y); if (x == y) return 0;\\r\\n\\t\\tif (e[x] > e[y]) swap(x,y);\\r\\n\\t\\te[x] += e[y]; e[y] = x; return 1;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nint cnt=0;\\r\\ntemplate<class T> T kruskal(int N, vector<pair<T,pi>> ed) {\\r\\n\\tsort(all(ed));\\r\\n\\tT ans = 0; DSU D; D.init(N+1); // edges that unite are in MST\\r\\n\\ttrav(a,ed)\\r\\n\\tif (D.unite(a.s.f,a.s.s)) {\\r\\n\\t\\tans += a.f;\\r\\n\\t\\tcnt++;\\r\\n\\t}\\r\\n\\treturn ans;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0);\\r\\n\\tcin.tie(0);\\r\\n\\tint n, m; cin >> n >> m;\\r\\n\\tvector<pair<ll,pi>> edge;\\r\\n\\tfor (int i = 0; i < m; i++){\\r\\n\\t\\tint a, b; ll c;\\r\\n\\t\\tcin >> a >> b >> c;\\r\\n\\t\\tedge.push_back(mp(c, mp(a, b)));\\r\\n\\t}\\r\\n\\tll ans = kruskal(n, edge);\\r\\n\\tif(cnt == n-1){\\r\\n\\t\\tcout << ans;\\r\\n\\t}\\r\\n\\telse{\\r\\n\\t\\tcout << \\\"IMPOSSIBLE\\\";\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\nclass kruskal {\\r\\n\\tstatic int comp;\\r\\n\\tstatic int disjoint[];\\r\\n\\tstatic int size[];\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tPrintWriter out = new PrintWriter(System.out);\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(sc.readLine());\\r\\n\\t\\tint N = Integer.parseInt(st.nextToken());\\r\\n\\t\\tint M = Integer.parseInt(st.nextToken());\\r\\n\\r\\n\\t\\tPriorityQueue<Edge> pq = new PriorityQueue < Edge > ();\\r\\n\\t\\tfor (int m = 0; m < M; m++) {\\r\\n\\t\\t\\tst = new StringTokenizer(sc.readLine());\\r\\n\\t\\t\\tint a = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tint b = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tint w = Integer.parseInt(st.nextToken());\\r\\n\\r\\n\\t\\t\\tpq.add(new Edge(a, b, w));\\r\\n\\t\\t}\\r\\n\\t\\tcomp = N;\\r\\n\\t\\tlong ans = 0;\\r\\n\\t\\tdisjoint = new int[N + 1];\\r\\n\\t\\tArrays.fill(disjoint, -1);\\r\\n\\t\\tsize = new int[N + 1];\\r\\n\\t\\tArrays.fill(size, 0);\\r\\n\\t\\twhile (!pq.isEmpty()) {\\r\\n\\t\\t\\tEdge e = pq.poll();\\r\\n\\t\\t\\tif (find(e.start) != find(e.end)) {\\r\\n\\t\\t\\t\\tunion(e.start, e.end);\\r\\n\\t\\t\\t\\tans += e.weight;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tout.println((comp == 1) ? ans : \\\"IMPOSSIBLE\\\");\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\tpublic static int find(int v) {\\r\\n\\t\\tif (disjoint[v] == -1) {\\r\\n\\t\\t\\treturn v;\\r\\n\\t\\t}\\r\\n\\t\\tdisjoint[v] = find(disjoint[v]);\\r\\n\\t\\treturn disjoint[v];\\r\\n\\t}\\r\\n\\tpublic static void union(int u, int v) {\\r\\n\\t\\tint uroot = find(u);\\r\\n\\t\\tint vroot = find(v);\\r\\n\\t\\tif (uroot == vroot) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tif (size[uroot] < size[vroot]) {\\r\\n\\t\\t\\tdisjoint[uroot] = vroot;\\r\\n\\t\\t\\tsize[vroot] = size[uroot] + size[vroot];\\r\\n\\t\\t\\tcomp--;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tdisjoint[vroot] = uroot;\\r\\n\\t\\t\\tsize[uroot] = size[uroot] + size[vroot];\\r\\n\\t\\t\\tcomp--;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\nclass Edge implements Comparable<Edge> {\\r\\n\\tpublic int start, end, weight;\\r\\n\\tpublic Edge(int s, int e, int w) {\\r\\n\\t\\tstart = s;\\r\\n\\t\\tend = e;\\r\\n\\t\\tweight = w;\\r\\n\\t}\\r\\n\\tpublic int compareTo(Edge o) {\\r\\n\\t\\tif (this.weight < o.weight) {\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t} else if (this.weight == o.weight) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"prims\",\n      children: [_jsx(_components.a, {\n        href: \"#prims\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Prim's\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CPH\",\n        title: \"15.3 - Prim's\",\n        starred: true\n      }), _jsx(Resource, {\n        source: \"cp-algo\",\n        title: \"Prim's\",\n        url: \"graph/mst_prim.html\"\n      }), _jsx(Resource, {\n        source: \"CP2\",\n        title: \"4.3.3 - Prim's\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Similar to Dijkstra's, \", _jsx(_components.strong, {\n        children: \"Prim's algorithm\"\n      }), \" greedily adds vertices. On each\\r\\niteration, we add the vertex that is closest to the current MST (instead of\\r\\nclosest to the source in Dijkstra's) until all vertices have been added.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The process of finding the closest vertex to the MST can be done efficiently\\r\\nusing a priority queue. After removing a vertex, we add all of its neighbors\\r\\nthat are not yet in the MST to the priority queue and repeat. To begin the\\r\\nalgorithm, we simply add any vertex to the priority queue.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"complexity\",\n      children: [_jsx(_components.a, {\n        href: \"#complexity\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Complexity\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Our implementation has complexity \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(E \\\\log E)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>E</mi><mi>log</mi><mo>⁡</mo><mi>E</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(E \\\\log E)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">E</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">E</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" since in the worst\\r\\ncase every edge will be checked and its corresponding vertex will be added to\\r\\nthe priority queue.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Alternatively, we may linearly search for the closest vertex instead of using a\\r\\npriority queue. Each linear pass runs in time \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(V)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>V</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(V)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.22222em;\\\">V</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \", and this must be\\r\\nrepeated \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"V\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\\\"application/x-tex\\\">V</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.22222em;\\\">V</span></span></span></span>\"\n      }), \" times. Thus, this version of Prim's algorithm has complexity\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(V^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>V</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(V^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.22222em;\\\">V</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \". As with Dijkstra, this complexity is preferable for dense\\r\\ngraphs (in which \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"E \\\\approx V^2\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>E</mi><mo>≈</mo><msup><mi>V</mi><mn>2</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">E \\\\approx V^2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">E</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≈</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.22222em;\\\">V</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \").\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"solution---road-reparation-1\",\n      children: [_jsx(_components.a, {\n        href: \"#solution---road-reparation-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution - Road Reparation\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <set>\\r\\nusing namespace std;\\r\\n\\r\\ntypedef long long ll;\\r\\ntypedef pair<ll, int> pl;\\r\\ntypedef vector<int> vi;\\r\\n\\r\\n#define pb push_back\\r\\n#define mp make_pair\\r\\n#define f first\\r\\n#define s second\\r\\n\\r\\n\\r\\nvector<pl> adj[200000];\\r\\nint n;\\r\\nll MAX = 100000000000L;\\r\\nll prim(){\\r\\n\\tll weight = 0;\\r\\n\\tvector<ll> min(n, MAX);\\r\\n\\tmin[0] = 0;\\r\\n\\tset<pl> q;\\r\\n\\tq.insert({0, 0});\\r\\n\\tvector<bool> visited(n, false);\\r\\n\\tfor (int i = 0; i < n; ++i) {\\r\\n\\t\\tif (q.empty()) {\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\t\\tint v = q.begin() -> s;\\r\\n\\t\\tvisited[v] = true;\\r\\n\\t\\tweight += q.begin()-> f;\\r\\n\\t\\tq.erase(q.begin());\\r\\n\\r\\n\\t\\tfor (pl e : adj[v]) {\\r\\n\\t\\t\\tif(!visited[e.s] && e.f < min[e.s]) {\\r\\n\\t\\t\\t\\tq.erase({min[e.s], e.s});\\r\\n\\t\\t\\t\\tmin[e.s] = e.f;\\r\\n\\t\\t\\t\\tq.insert({e.f, e.s});\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn weight;\\r\\n}\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0);\\r\\n\\tcin.tie(0);\\r\\n\\tint m; cin >> n >> m;\\r\\n\\tfor (int i = 0; i < m; i++){\\r\\n\\t\\tint a, b; ll c;\\r\\n\\t\\tcin >> a >> b >> c;\\r\\n\\t\\ta--; b--;\\r\\n\\t\\tadj[a].pb(mp(c, b));\\r\\n\\t\\tadj[b].pb(mp(c, a));\\r\\n\\t}\\r\\n\\tll ans = prim();\\r\\n\\tif(ans == -1){\\r\\n\\t\\tcout << \\\"IMPOSSIBLE\\\";\\r\\n\\t}\\r\\n\\telse{\\r\\n\\t\\tcout << ans;\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\nclass prim {\\r\\n\\tstatic Map<Integer, ArrayList<Edge>> tree;\\r\\n\\tstatic int N, ct;\\r\\n\\tstatic long[] dist;\\r\\n\\tstatic long max = 10000000000000000 L;\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tPrintWriter out = new PrintWriter(System.out);\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(sc.readLine());\\r\\n\\t\\tN = Integer.parseInt(st.nextToken());\\r\\n\\t\\tint M = Integer.parseInt(st.nextToken());\\r\\n\\r\\n\\t\\ttree = new HashMap<Integer, ArrayList<Edge>> ();\\r\\n\\t\\tfor (int i = 1; i <= N; i++) {\\r\\n\\t\\t\\ttree.put(i, new ArrayList<Edge> ());\\r\\n\\t\\t}\\r\\n\\t\\tfor (int m = 0; m < M; m++) {\\r\\n\\t\\t\\tst = new StringTokenizer(sc.readLine());\\r\\n\\t\\t\\tint a = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tint b = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tint w = Integer.parseInt(st.nextToken());\\r\\n\\r\\n\\t\\t\\ttree.get(a).add(new Edge(a, b, w));\\r\\n\\t\\t\\ttree.get(b).add(new Edge(b, a, w));\\r\\n\\t\\t}\\r\\n\\t\\tlong ans = prim(1);\\r\\n\\t\\tout.println((ct == N) ? ans : \\\"IMPOSSIBLE\\\");\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\tstatic long prim(int source) {\\r\\n\\t\\tdist = new long[N + 1];\\r\\n\\t\\tboolean[] visited = new boolean[N + 1];\\r\\n\\t\\tPriorityQueue<Pair> pq = new PriorityQueue<Pair> ();\\r\\n\\t\\tArrays.fill(dist, max);\\r\\n\\t\\tdist[source] = 0;\\r\\n\\t\\tlong ret = 0;\\r\\n\\t\\tpq.add(new Pair(0, source));\\r\\n\\t\\twhile (!pq.isEmpty()) {\\r\\n\\t\\t\\tPair p = pq.poll();\\r\\n\\t\\t\\tint v = p.b;\\r\\n\\t\\t\\tif (visited[v]) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tvisited[v] = true;\\r\\n\\t\\t\\tct++;\\r\\n\\t\\t\\tret += dist[v];\\r\\n\\t\\t\\tfor (Edge e: tree.get(v)) {\\r\\n\\t\\t\\t\\tif (e.weight < dist[e.end] && !visited[e.end]) {\\r\\n\\t\\t\\t\\t\\tdist[e.end] = e.weight;\\r\\n\\t\\t\\t\\t\\tpq.add(new Pair(dist[e.end], e.end));\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn ret;\\r\\n\\t}\\r\\n}\\r\\nclass Edge {\\r\\n\\tpublic int start, end, weight;\\r\\n\\tpublic Edge(int s, int e, int w) {\\r\\n\\t\\tstart = s;\\r\\n\\t\\tend = e;\\r\\n\\t\\tweight = w;\\r\\n\\t}\\r\\n}\\r\\nclass Pair implements Comparable<Pair> {\\r\\n\\tpublic long a;\\r\\n\\tpublic int b;\\r\\n\\tpublic Pair(long a, int b) {\\r\\n\\t\\tthis.a = a;\\r\\n\\t\\tthis.b = b;\\r\\n\\t}\\r\\n\\tpublic int compareTo(Pair o) {\\r\\n\\t\\tif (this.a > o.a) {\\r\\n\\t\\t\\treturn 1;\\r\\n\\t\\t} else if (this.a == o.a) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import heapq\\r\\n\\r\\ndef prim(n, G):\\r\\n\\tused = [False for _ in range(n)]\\r\\n\\tpq = [(0, 0)]\\r\\n\\ttotal_weight = 0\\r\\n\\tcount = 0\\r\\n\\twhile pq:\\r\\n\\t\\tweight, node = heapq.heappop(pq)\\r\\n\\t\\tif used[node]:\\r\\n\\t\\t\\tcontinue\\r\\n\\t\\tused[node] = True\\r\\n\\t\\ttotal_weight += weight\\r\\n\\t\\tcount += 1\\r\\n\\t\\tfor (neigh_weight, neigh_node) in G[node]:\\r\\n\\t\\t\\tif not used[neigh_node]:\\r\\n\\t\\t\\t\\theapq.heappush(pq, (neigh_weight, neigh_node))\\r\\n\\treturn total_weight if count == n else -1\\r\\n\\r\\nn, m = map(int, input().split())\\r\\nG = [[] for _ in range(n)]\\r\\nfor _ in range(m):\\r\\n\\ta, b, c = map(int, input().split())\\r\\n\\ta -= 1\\r\\n\\tb -= 1\\r\\n\\tG[a].append((c, b))\\r\\n\\tG[b].append((c, a))\\r\\n\\r\\nans = prim(n, G)\\r\\nprint(\\\"IMPOSSIBLE\\\" if ans == -1 else ans)\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"general\"\n    }), \"\\n\", _jsx(Info, {\n      children: _jsxs(_components.p, {\n        children: [\"The original problem statement for \\\"Inheritance\\\" is in Japanese. You can find a user-translated\\r\\nversion of the problem \", _jsx(_components.a, {\n          href: \"https://gist.github.com/SansPapyrus683/a17f37a4a938e13000e281e4843b73bc\",\n          target: \"_blank\",\n          rel: \"nofollow noopener noreferrer\",\n          children: \"here\"\n        }), \".\"]\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  author,\n  contributors,\n  prerequisites,\n  description,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"Minimum Spanning Trees","author":"Benjamin Qi, Andrew Wang, Kuan-Hung Chen","contributors":"Neo Wang","id":"mst","prerequisites":["shortest-paths","dsu"],"description":"A subset of the edges of a connected, undirected, edge-weighted graph that connects all the vertices to each other of minimum total weight, where no cycles are allowed.","frequency":2},"parent":{"name":"MST","relativePath":"4_Gold/MST.mdx"},"fields":{"division":"gold"},"toc":{"cpp":[{"depth":2,"value":"Kruskal&#39;s","slug":"kruskals"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Solution - Road Reparation","slug":"solution---road-reparation"},{"depth":2,"value":"Prim&#39;s","slug":"prims"},{"depth":3,"value":"Complexity","slug":"complexity"},{"depth":3,"value":"Solution - Road Reparation","slug":"solution---road-reparation-1"},{"depth":2,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Kruskal&#39;s","slug":"kruskals"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Solution - Road Reparation","slug":"solution---road-reparation"},{"depth":2,"value":"Prim&#39;s","slug":"prims"},{"depth":3,"value":"Complexity","slug":"complexity"},{"depth":3,"value":"Solution - Road Reparation","slug":"solution---road-reparation-1"},{"depth":2,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Kruskal&#39;s","slug":"kruskals"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Solution - Road Reparation","slug":"solution---road-reparation"},{"depth":2,"value":"Prim&#39;s","slug":"prims"},{"depth":3,"value":"Complexity","slug":"complexity"},{"depth":3,"value":"Solution - Road Reparation","slug":"solution---road-reparation-1"},{"depth":2,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[{"listId":"standard","problems":[{"uniqueId":"cses-1675","name":"Road Reparation","url":"https://cses.fi/problemset/task/1675","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["MST"],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/gold/mst#problem-cses-1675","sketch":null}}]},{"listId":"general","problems":[{"uniqueId":"usaco-531","name":"Superbull","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=531","source":"Old Silver","difficulty":"Easy","isStarred":false,"tags":["MST"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-623","name":"Fenced In","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=623","source":"Gold","difficulty":"Easy","isStarred":false,"tags":["MST"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_fencedin_gold_feb16.html","sketch":null}},{"uniqueId":"cf-472D","name":"Design Tutorial: Inverse the Problem","url":"https://codeforces.com/contest/472/problem/D","source":"CF","difficulty":"Easy","isStarred":false,"tags":["MST"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-1513D","name":"GCD and MST","url":"https://codeforces.com/problemset/problem/1513/D","source":"CF","difficulty":"Normal","isStarred":false,"tags":["MST","Math"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"usaco-946","name":"I Would Walk 500 Miles","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=946","source":"Gold","difficulty":"Normal","isStarred":false,"tags":["MST"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"hr-SpanningTreeFraction","name":"Spanning Tree Fraction","url":"https://www.hackerrank.com/contests/w31/challenges/spanning-tree-fraction/problem","source":"HR","difficulty":"Normal","isStarred":false,"tags":["MST","Binary Search"],"solution":{"kind":"label","label":"Check HR","labelTooltip":"The editorial tab should be right next to the discussions tab.","url":null,"sketch":null}},{"uniqueId":"cf-888G","name":"Xor-MST","url":"https://codeforces.com/contest/888/problem/G","source":"CF","difficulty":"Normal","isStarred":false,"tags":["MST"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1211","name":"Moo Network","url":"http://usaco.org/index.php?page=viewproblem2&cpid=1211","source":"Gold","difficulty":"Normal","isStarred":false,"tags":["MST"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_prob3_gold_feb22.html","sketch":null}},{"uniqueId":"joi-15-inheritance","name":"2015 - Inheritance","url":"https://joisc2015.contest.atcoder.jp/tasks/joisc2015_k","source":"JOI","difficulty":"Normal","isStarred":false,"tags":["MST","Binary Search"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1138","name":"Portals","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1138","source":"Gold","difficulty":"Normal","isStarred":false,"tags":["MST"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-625","name":"Fenced In","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=625","source":"Plat","difficulty":"Hard","isStarred":false,"tags":["MST"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_fencedin_platinum_feb16.html","sketch":null}},{"uniqueId":"coci-17-sirni","name":"2017 - Sirni","url":"https://oj.uz/problem/view/COCI17_sirni","source":"COCI","difficulty":"Hard","isStarred":false,"tags":["MST","NT"],"solution":null},{"uniqueId":"ks-checksum","name":"Checksum","url":"https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3","source":"KS","difficulty":"Hard","isStarred":false,"tags":["MST"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"apio-13-toll","name":"2013 - Toll","url":"https://oj.uz/problem/view/APIO13_toll","source":"APIO","difficulty":"Insane","isStarred":false,"tags":["MST","Bitmasks"],"solution":null},{"uniqueId":"balkan-11-timeismoney","name":"2011 - Timeismoney","url":"http://oj.uz/problem/view/balkan11_timeismoney","source":"Balkan OI","difficulty":"Insane","isStarred":true,"tags":["MST","Convex"],"solution":null}]}]}},"pageContext":{"id":"mst"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}