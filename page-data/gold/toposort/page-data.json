{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/gold/toposort",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*<Resource source=\"PAPS\" title=\"9.2 - Dynamic Programming\">\nBest Path in a DAG\n</Resource>*/\n/*However, not all problems clearly give you directed acyclic graphs (ex. [Plat - Cave Paintings](http://usaco.org/index.php?page=viewproblem2&cpid=996)). An important step in many problems is to reduce the statement into a directed acyclic graph. See the editorial of the linked problem for more information.\n\n(Ben - this last paragraph doesn't seem very helpful.)*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"toposort\", title = \"Topological Sort\", author = \"Benjamin Qi, Nathan Chen\", contributors = \"Michael Cao, Andi Qu, Andrew Wang, Qi Wang, Maggie Liu\", prerequisites = [\"bfs\", \"intro-dp\"], description = \"An ordering of vertices in a directed acyclic graph that ensures that a node is visited before every node it has a directed edge to.\", frequency = 1;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    h2: \"h2\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    h3: \"h3\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    Warning: _missingComponent(\"Warning\"),\n    PySection: _missingComponent(\"PySection\"),\n    Info: _missingComponent(\"Info\"),\n    Optional: _missingComponent(\"Optional\"),\n    Spoiler: _missingComponent(\"Spoiler\"),\n    MATHDIV: _missingComponent(\"MATHDIV\"),\n    Problems: _missingComponent(\"Problems\")\n  }, _props.components), {HeaderLink, FocusProblem, MATHSPAN, Resources, Resource, LanguageSection, CPPSection, JavaSection, Warning, PySection, Info, Optional, Spoiler, MATHDIV, Problems, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"To review, a \", _jsx(_components.strong, {\n        children: \"directed\"\n      }), \" graph consists of edges that can only be traversed in\\r\\none direction. Additionally, an \", _jsx(_components.strong, {\n        children: \"acyclic\"\n      }), \" graph defines a graph which does not\\r\\ncontain cycles, meaning you are unable to traverse across one or more edges and\\r\\nreturn to the node you started on. Putting these definitions together, a\\r\\n\", _jsx(_components.strong, {\n        children: \"directed acyclic\"\n      }), \" graph, sometimes abbreviated as DAG, is a graph which has\\r\\nedges which can only be traversed in one direction and does not contain cycles.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"topological-sort\",\n      children: [_jsx(_components.a, {\n        href: \"#topological-sort\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Topological Sort\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sample\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Topological_sorting\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"topological sort\"\n      }), \" of a\\r\\ndirected acyclic graph is a linear ordering of its vertices such that for every\\r\\ndirected edge \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\\\\to v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u\\\\to v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">→</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" from vertex \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" to vertex \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \", \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" comes before \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" in\\r\\nthe ordering.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are two common ways to topologically sort, one involving DFS and the other\\r\\ninvolving BFS.\"\n    }), \"\\n\", _jsx(Resources, {\n      children: _jsx(Resource, {\n        source: \"CSA\",\n        title: \"Topological Sorting\",\n        url: \"topological_sorting\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"interactive, both versions\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"dfs\",\n      children: [_jsx(_components.a, {\n        href: \"#dfs\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"DFS\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CPH\",\n        title: \"16.1 - Topological Sort\",\n        children: _jsx(_components.p, {\n          children: \"example walkthrough\"\n        })\n      }), _jsx(Resource, {\n        source: \"CP2\",\n        title: \"4.2.5 - Topological Sort\",\n        children: _jsx(_components.p, {\n          children: \"code\"\n        })\n      }), _jsx(Resource, {\n        source: \"cp-algo\",\n        title: \"Topological Sort\",\n        url: \"graph/topological-sort.html\",\n        children: _jsx(_components.p, {\n          children: \"code\"\n        })\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\n#define pb push_back\\r\\n\\r\\nint N; // Number of nodes\\r\\nvector<int> graph[100000], top_sort; // Assume that this graph is a DAG\\r\\nbool visited[100000];\\r\\n\\r\\nvoid dfs(int node) {\\r\\n\\tfor (int i : graph[node]) {\\r\\n\\t\\tif (!visited[i]) {\\r\\n\\t\\t\\tvisited[i] = true;\\r\\n\\t\\t\\tdfs(i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\ttop_sort.pb(node);\\r\\n}\\r\\n\\r\\nvoid compute() {\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\tif (!visited[i]) {\\r\\n\\t\\t\\tvisited[i] = true;\\r\\n\\t\\t\\tdfs(i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treverse(begin(top_sort),end(top_sort));\\r\\n\\t// The vector `top_sort` is now topologically sorted\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tint M; cin >> N >> M;\\r\\n\\tfor (int i = 0; i < M; ++i) {\\r\\n\\t\\tint a, b; cin >> a >> b;\\r\\n\\t\\tgraph[a - 1].pb(b - 1);\\r\\n\\t}\\r\\n\\tcompute();\\r\\n\\tvector<int> ind(N);\\r\\n\\tfor (int i = 0; i < N; i++) ind[top_sort[i]] = i;\\r\\n\\tfor (int i = 0; i < N; i++) for (int j: graph[i]) if (ind[j] <= ind[i]) {\\r\\n\\t\\tcout << \\\"IMPOSSIBLE\\\\n\\\"; // topological sort wasn't valid\\r\\n\\t\\texit(0);\\r\\n\\t}\\r\\n\\tfor (int i : top_sort) cout << i + 1 << \\\" \\\";\\r\\n\\tcout << \\\"\\\\n\\\";\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class CourseSchedule {\\r\\n\\tstatic List<Integer>[] graph;\\r\\n\\tstatic List<Integer> topo = new ArrayList<Integer>();\\r\\n\\tstatic int N;\\r\\n\\tstatic boolean[] visited;\\r\\n\\tpublic static void main(String[] args) throws Exception {\\r\\n\\t\\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(br.readLine());\\r\\n\\t\\tN = Integer.parseInt(st.nextToken());\\r\\n\\t\\tint M = Integer.parseInt(st.nextToken());\\r\\n\\t\\tgraph = new List[N];\\r\\n\\t\\tvisited = new boolean[N];\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tgraph[i] = new ArrayList<Integer>();\\r\\n\\t\\t}\\r\\n\\t\\tfor (int m = 0; m < M; m++) {\\r\\n\\t\\t\\tst = new StringTokenizer(br.readLine());\\r\\n\\t\\t\\tint a = Integer.parseInt(st.nextToken()) - 1;\\r\\n\\t\\t\\tint b = Integer.parseInt(st.nextToken()) - 1;\\r\\n\\t\\t\\tgraph[a].add(b);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcompute();\\r\\n\\t\\tint[] ind = new int[N];\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N; i++) ind[topo.get(i)] = i;\\r\\n\\t\\tfor (int i = 0; i < N; i++)\\r\\n\\t\\t\\tfor (int j : graph[i])\\r\\n\\t\\t\\t\\tif (ind[j] <= ind[i]) {\\r\\n\\t\\t\\t\\t\\tSystem.out.println(\\\"IMPOSSIBLE\\\"); // topological sort wasn't valid\\r\\n\\t\\t\\t\\t\\tSystem.exit(0);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\tfor (int i : topo) System.out.print(i + 1 + \\\" \\\");\\r\\n\\t}\\r\\n\\tpublic static void compute() {\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tif (!visited[i]) {\\r\\n\\t\\t\\t\\tvisited[i] = true;\\r\\n\\t\\t\\t\\tdfs(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tCollections.reverse(topo);\\r\\n\\t}\\r\\n\\tpublic static void dfs(int v) { // not always lexicographically least\\r\\n\\t\\tfor (Integer e : graph[v]) {\\r\\n\\t\\t\\tif (!visited[e]) {\\r\\n\\t\\t\\t\\tvisited[e] = true;\\r\\n\\t\\t\\t\\tdfs(e);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\ttopo.add(v);\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"finding-a-cycle\",\n      children: [_jsx(_components.a, {\n        href: \"#finding-a-cycle\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Finding a Cycle\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"dir\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can modify the algorithm above to return a directed cycle in the case where a\\r\\ntopological sort does not exist. To find the cycle, we add each node we visit\\r\\nonto the stack until we detect a node already on the stack.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, suppose that our stack currently consists of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"s_1,s_2,\\\\ldots,s_i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo separator=\\\"true\\\">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator=\\\"true\\\">,</mo><mo>…</mo><mo separator=\\\"true\\\">,</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">s_1,s_2,\\\\ldots,s_i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3011em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">1</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3011em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"minner\\\">…</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3117em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">i</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \"\\r\\nand we then visit \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u=s_j\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi><mo>=</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">u=s_j</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7167em;vertical-align:-0.2861em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3117em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.05724em;\\\">j</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.2861em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" for some \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"j\\\\le i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>j</mi><mo>≤</mo><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">j\\\\le i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.854em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≤</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n      }), \". Then\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"s_j\\\\to s_{j+1}\\\\to \\\\cdots\\\\to s_i\\\\to s_j\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>s</mi><mi>j</mi></msub><mo>→</mo><msub><mi>s</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><mo>⋯</mo><mo>→</mo><msub><mi>s</mi><mi>i</mi></msub><mo>→</mo><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">s_j\\\\to s_{j+1}\\\\to \\\\cdots\\\\to s_i\\\\to s_j</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7167em;vertical-align:-0.2861em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3117em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.05724em;\\\">j</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.2861em;\\\"><span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">→</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7167em;vertical-align:-0.2861em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3117em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mbin mtight\\\">+</span><span class=\\\"mord mtight\\\">1</span></span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.2861em;\\\"><span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">→</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.3669em;\\\"></span><span class=\\\"minner\\\">⋯</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">→</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5806em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3117em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">i</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">→</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7167em;vertical-align:-0.2861em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3117em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.05724em;\\\">j</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.2861em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" is a cycle. We can reconstruct the\\r\\ncycle without explicitly storing the stack by marking \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" as not part of the\\r\\nstack and recursively backtracking until \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" is reached again.\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <vector>\\r\\n#include <iostream>\\r\\n#include <algorithm>\\r\\nusing namespace std;\\r\\n\\r\\nbool visited[(int)1e5 + 5], on_stack[(int)1e5 + 5];\\r\\nvector<int> adj[(int)1e5 + 5];\\r\\nvector<int> cycle;\\r\\nint N, M;\\r\\nbool dfs(int n) {\\r\\n\\tvisited[n] = on_stack[n] = true;\\r\\n\\tfor (int u : adj[n]) {\\r\\n\\t\\tif(on_stack[u]) {\\r\\n\\t\\t\\tcycle.push_back(n); // start cycle\\r\\n\\t\\t\\ton_stack[n] = on_stack[u] = false;\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\telse if(!visited[u]) {\\r\\n\\t\\t\\tif(dfs(u)) { // continue cycle\\r\\n\\t\\t\\t\\tif(on_stack[n]) {\\r\\n\\t\\t\\t\\t\\tcycle.push_back(n);\\r\\n\\t\\t\\t\\t\\ton_stack[n] = false;\\r\\n\\t\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t\\t} else { // found u again\\r\\n\\t\\t\\t\\t\\tcycle.push_back(n);\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(!cycle.empty()) // finished with cycle\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\ton_stack[n] = false;\\r\\n\\treturn false;\\r\\n}\\r\\nint main()\\r\\n{\\r\\n\\t// take input, etc\\r\\n\\tcin >> N >> M;\\r\\n\\tfor (int i = 0; i < M; i++) {\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\tadj[a].push_back(b);\\r\\n\\t}\\r\\n\\tfor (int i = 1; cycle.empty() && i <= N; i++)\\r\\n\\t\\tdfs(i);\\r\\n\\tif(cycle.empty())\\r\\n\\t\\tcout << \\\"IMPOSSIBLE\\\";\\r\\n\\telse {\\r\\n\\t\\treverse(cycle.begin(), cycle.end());\\r\\n\\t\\tcout << cycle.size() + 1 << \\\"\\\\n\\\";\\r\\n\\t\\tfor(int n : cycle) cout << n << \\\" \\\";\\r\\n\\t\\tcout << cycle.at(0);\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class cycle {\\r\\n\\tstatic List<Integer>[] adj;\\r\\n\\tstatic boolean[] visited, onStack;\\r\\n\\tstatic List<Integer> cycle;\\r\\n\\tstatic int N, M;\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tPrintWriter out = new PrintWriter(System.out);\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(sc.readLine());\\r\\n\\t\\tN = Integer.parseInt(st.nextToken());\\r\\n\\t\\tM = Integer.parseInt(st.nextToken());\\r\\n\\t\\tadj = new List[N + 1];\\r\\n\\t\\tcycle = new ArrayList<Integer>();\\r\\n\\t\\tvisited = new boolean[N + 1];\\r\\n\\t\\tonStack = new boolean[N + 1];\\r\\n\\t\\tfor (int i = 0; i <= N; i++) {\\r\\n\\t\\t\\tadj[i] = new ArrayList<Integer>();\\r\\n\\t\\t}\\r\\n\\t\\tfor (int i = 0; i < M; i++) {\\r\\n\\t\\t\\tst = new StringTokenizer(sc.readLine());\\r\\n\\t\\t\\tint a = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tint b = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tadj[a].add(b);\\r\\n\\t\\t}\\r\\n\\t\\tfor (int i = 1; cycle.isEmpty() && i <= N; i++) {\\r\\n\\t\\t\\tdfs(i);\\r\\n\\t\\t}\\r\\n\\t\\tif (cycle.isEmpty())\\r\\n\\t\\t\\tout.println(\\\"IMPOSSIBLE\\\");\\r\\n\\t\\telse {\\r\\n\\t\\t\\tCollections.reverse(cycle);\\r\\n\\t\\t\\tout.println(cycle.size() + 1);\\r\\n\\t\\t\\tfor (int n: cycle) out.print(n + \\\" \\\");\\r\\n\\t\\t\\tout.print(cycle.get(0));\\r\\n\\t\\t}\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\r\\n\\tpublic static boolean dfs(int n) {\\r\\n\\t\\tvisited[n] = onStack[n] = true;\\r\\n\\t\\tfor (int u: adj[n]) {\\r\\n\\t\\t\\tif (onStack[u]) {\\r\\n\\t\\t\\t\\tcycle.add(n);\\r\\n\\t\\t\\t\\tonStack[n] = onStack[u] = false;\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t} else if (!visited[u]) {\\r\\n\\t\\t\\t\\tif (dfs(u)) {\\r\\n\\t\\t\\t\\t\\tif (onStack[n]) {\\r\\n\\t\\t\\t\\t\\t\\tcycle.add(n);\\r\\n\\t\\t\\t\\t\\t\\tonStack[n] = false;\\r\\n\\t\\t\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tcycle.add(n);\\r\\n\\t\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (!cycle.isEmpty())\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tonStack[n] = false;\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsx(Warning, {\n      children: _jsx(_components.p, {\n        children: \"This code assumes that there are no self-loops.\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"bfs\",\n      children: [_jsx(_components.a, {\n        href: \"#bfs\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"BFS\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The BFS version is known as\\r\\n\", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Kahn's Algorithm\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(CPPSection, {\n        children: [_jsxs(_components.h3, {\n          id: \"course-schedule-solution\",\n          children: [_jsx(_components.a, {\n            href: \"#course-schedule-solution\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Course Schedule Solution\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <queue>\\r\\nusing namespace std;\\r\\n\\r\\nconst int MAX_N = 100000;\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tint n, m;\\r\\n\\tcin >> n >> m;\\r\\n\\tvector<int> graph[MAX_N];\\r\\n\\tint indegree[MAX_N]{};\\r\\n\\tqueue<int> q;\\r\\n\\tfor (int i = 0; i < m; i++)\\r\\n\\t{\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\tgraph[a - 1].push_back(b - 1);\\r\\n\\t\\tindegree[b - 1]++;\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\t// locate the nodes with indegree 0 and push them into the queue\\r\\n\\t\\tif (indegree[i] == 0)\\r\\n\\t\\t{\\r\\n\\t\\t\\tq.push(i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tvector<int> order;\\r\\n\\twhile (!q.empty())\\r\\n\\t{\\r\\n\\t\\tint curr = q.front();\\r\\n\\t\\tq.pop();\\r\\n\\t\\t// add the current node to the order\\r\\n\\t\\torder.push_back(curr);\\r\\n\\t\\tfor (int next : graph[curr])\\r\\n\\t\\t{\\r\\n\\t\\t\\t// remove the current node from the graph\\r\\n\\t\\t\\tindegree[next]--;\\r\\n\\t\\t\\t// push any new nodes with indegree 0 into the queue\\r\\n\\t\\t\\tif (indegree[next] == 0)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tq.push(next);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// if there isn't a valid topological sorting\\r\\n\\tif (order.size() != n)\\r\\n\\t{\\r\\n\\t\\tcout << \\\"IMPOSSIBLE\\\" << endl;\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\tcout << order[0] + 1;\\r\\n\\tfor (int i = 1; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tcout << \\\" \\\" << order[i] + 1;\\r\\n\\t}\\r\\n\\tcout << endl;\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })]\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"public class TopoSort {\\r\\n\\tstatic int[] inDegree;\\r\\n\\tstatic List<Integer>[] edge; // adjacency list\\r\\n\\r\\n\\tstatic int N; // number of nodes\\r\\n\\r\\n\\tstatic void topological_sort() {\\r\\n\\t\\tQueue<Integer> q = new LinkedList<>();\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tif (inDegree[i] == 0) {\\r\\n\\t\\t\\t\\tq.add(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\twhile (!q.isEmpty()) {\\r\\n\\t\\t\\tint node = q.poll();\\r\\n\\r\\n\\t\\t\\tfor (int next : edge[node]) {\\r\\n\\t\\t\\t\\tinDegree[next]--;\\r\\n\\t\\t\\t\\tif(inDegree[next] == 0) q.add(next);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// Put problem-specific processing here\\r\\n\\t\\t\\t// Push in value to current ordering if no need for processing\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"from collections import deque\\r\\n\\r\\n# The code is in a function so it can run faster.\\r\\ndef main():\\r\\n\\tN, M = map(int, input().split())\\r\\n\\tadj = [[] for _ in range(N)]\\r\\n\\tfor _ in range(M):\\r\\n\\t\\ta, b = map(int, input().split())\\r\\n\\t\\ta -= 1\\r\\n\\t\\tb -= 1\\r\\n\\t\\tadj[a].append(b)\\r\\n\\r\\n\\ttopo_order = []\\r\\n\\tin_degree = [0 for _ in range(N)]\\r\\n\\tfor nodes in adj:\\r\\n\\t\\tfor node in nodes:\\r\\n\\t\\t\\tin_degree[node] += 1\\r\\n\\r\\n\\tcount = 0\\r\\n\\tqueue = deque([node for node in range(N) if in_degree[node] == 0])\\r\\n\\twhile queue:\\r\\n\\t\\tcur_node = queue.popleft()\\r\\n\\t\\ttopo_order.append(cur_node)\\r\\n\\t\\tfor neigh_node in adj[cur_node]:\\r\\n\\t\\t\\tin_degree[neigh_node] -= 1\\r\\n\\t\\t\\tif in_degree[neigh_node] == 0:\\r\\n\\t\\t\\t\\tqueue.append(neigh_node)\\r\\n\\t\\tcount += 1\\r\\n\\r\\n\\tif count != N:\\r\\n\\t\\tprint(\\\"IMPOSSIBLE\\\")\\r\\n\\telse:\\r\\n\\t\\tprint(\\\" \\\".join(map(str, [node + 1 for node in topo_order])))\\r\\n\\r\\n\\r\\nif __name__ == \\\"__main__\\\":\\r\\n\\tmain()\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsx(Info, {\n      title: \"Pro Tip\",\n      children: _jsx(_components.p, {\n        children: \"If the length of the array containing the end order does not equal the number of\\r\\nelements that need to be sorted, then there is a cycle in the graph.\"\n      })\n    }), \"\\n\", _jsxs(Optional, {\n      children: [_jsx(_components.p, {\n        children: \"We can also use Kahn's algorithm to extract the lexicographically minimum\\r\\ntopological sort by breaking ties lexographically.\"\n      }), _jsxs(_components.p, {\n        children: [\"Although the above code does not do this, one can simply replace the \", _jsx(_components.code, {\n          children: \"queue\"\n        }), \"\\r\\nwith a \", _jsx(_components.code, {\n          children: \"priority_queue\"\n        }), \" to implement this extension.\"]\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"dynamic-programming\",\n      children: [_jsx(_components.a, {\n        href: \"#dynamic-programming\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Dynamic Programming\"]\n    }), \"\\n\", _jsx(Resources, {\n      children: _jsx(Resource, {\n        source: \"CPH\",\n        title: \"16.2 - Dynamic Programming\",\n        starred: true\n      })\n    }), \"\\n\", \"\\n\", _jsxs(_components.p, {\n      children: [\"One useful property of directed acyclic graphs is, as the name suggests, that no\\r\\ncycles exist. If we consider each node in the graph as a state, we can perform\\r\\ndynamic programming on the graph if we process the states in an order that\\r\\nguarantees for every edge \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\\\\to v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi><mo>→</mo><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u\\\\to v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">→</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" that \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" is processed before \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \".\\r\\nFortunately, this is the exact definition of a topological sort!\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"dp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this task, we must find the longest path in a DAG.\"\n    }), \"\\n\", _jsxs(Spoiler, {\n      title: \"Solution\",\n      children: [_jsxs(_components.p, {\n        children: [\"Let \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"dp[v]\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\\\"false\\\">[</mo><mi>v</mi><mo stretchy=\\\"false\\\">]</mo></mrow><annotation encoding=\\\"application/x-tex\\\">dp[v]</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span><span class=\\\"mord mathnormal\\\">p</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span><span class=\\\"mclose\\\">]</span></span></span></span>\"\n        }), \" denote the length of the longest path ending at the node \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"v\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n        }), \".\\r\\nClearly\"]\n      }), _jsx(MATHDIV, {\n        className: \"math math-display\",\n        latex: \"dp[v]=\\\\max_{\\\\text{edge } u\\\\to v \\\\text{ exists}}dp[u]+1,\",\n        children: \"<span class=\\\"katex-display\\\"><span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\" display=\\\"block\\\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\\\"false\\\">[</mo><mi>v</mi><mo stretchy=\\\"false\\\">]</mo><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mtext>edge </mtext><mi>u</mi><mo>→</mo><mi>v</mi><mtext> exists</mtext></mrow></munder><mi>d</mi><mi>p</mi><mo stretchy=\\\"false\\\">[</mo><mi>u</mi><mo stretchy=\\\"false\\\">]</mo><mo>+</mo><mn>1</mn><mo separator=\\\"true\\\">,</mo></mrow><annotation encoding=\\\"application/x-tex\\\">dp[v]=\\\\max_{\\\\text{edge } u\\\\to v \\\\text{ exists}}dp[u]+1,</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span><span class=\\\"mord mathnormal\\\">p</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span><span class=\\\"mclose\\\">]</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.6382em;vertical-align:-0.8882em;\\\"></span><span class=\\\"mop op-limits\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.4306em;\\\"><span style=\\\"top:-2.3479em;margin-left:0em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord text mtight\\\"><span class=\\\"mord mtight\\\">edge </span></span><span class=\\\"mord mathnormal mtight\\\">u</span><span class=\\\"mrel mtight\\\">→</span><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.03588em;\\\">v</span><span class=\\\"mord text mtight\\\"><span class=\\\"mord mtight\\\"> exists</span></span></span></span></span><span style=\\\"top:-3em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span><span class=\\\"mop\\\">max</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8882em;\\\"><span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span><span class=\\\"mord mathnormal\\\">p</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\">u</span><span class=\\\"mclose\\\">]</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8389em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mpunct\\\">,</span></span></span></span></span>\"\n      }), _jsxs(_components.p, {\n        children: [\"or \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"1\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n        }), \" if \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"v\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n        }), \" is node \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"1\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n        }), \". If we process the states in topological order, it is\\r\\nguaranteed that \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"dp[u]\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\\\"false\\\">[</mo><mi>u</mi><mo stretchy=\\\"false\\\">]</mo></mrow><annotation encoding=\\\"application/x-tex\\\">dp[u]</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span><span class=\\\"mord mathnormal\\\">p</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\">u</span><span class=\\\"mclose\\\">]</span></span></span></span>\"\n        }), \" will already have been computed before computing\\r\\n\", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"dp[v]\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\\\"false\\\">[</mo><mi>v</mi><mo stretchy=\\\"false\\\">]</mo></mrow><annotation encoding=\\\"application/x-tex\\\">dp[v]</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span><span class=\\\"mord mathnormal\\\">p</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span><span class=\\\"mclose\\\">]</span></span></span></span>\"\n        }), \".\"]\n      }), _jsx(_components.p, {\n        children: \"Note that the implementation of this idea below uses Kahn's algorithm for\\r\\ntopological sorting:\"\n      }), _jsxs(LanguageSection, {\n        children: [_jsx(CPPSection, {\n          children: _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-cpp\",\n              children: \"#include <bits/stdc++.h>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\nint prev_flight[100000];\\r\\nint dist[100000];\\r\\nint in_degree[100000];\\r\\nvector<int> edge[100000];\\r\\nvector<int> backEdge[100000];\\r\\n\\r\\nint N, M;\\r\\n\\r\\n// Does a topological sort\\r\\nvoid compute() {\\r\\n\\tqueue<int> q;\\r\\n\\tfor(int i = 0; i < N; i++) {\\r\\n\\t\\tif(in_degree[i] == 0) {\\r\\n\\t\\t\\tq.push(i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\twhile(!q.empty()) {\\r\\n\\t\\tint node = q.front();\\r\\n\\t\\tq.pop();\\r\\n\\r\\n\\t\\tfor(int next : edge[node]) {\\r\\n\\t\\t\\tin_degree[next]--;\\r\\n\\t\\t\\tif(in_degree[next] == 0) q.push(next);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// The below block computes the DP\\r\\n\\t\\tint mx = -999999999;\\r\\n\\t\\tint mx_node = -1;\\r\\n\\t\\tfor(int prev : backEdge[node]) {\\r\\n\\t\\t\\tif(dist[prev] + 1 > mx) {\\r\\n\\t\\t\\t\\tmx = dist[prev] + 1;\\r\\n\\t\\t\\t\\tmx_node = prev;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdist[node] = mx;\\r\\n\\t\\tif(node == 0) dist[node] = 1;\\r\\n\\t\\tprev_flight[node] = mx_node;\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\r\\nint main() { // See \\\"General - Fast I/O\\\" for more information about the first two lines in the main function\\r\\n\\tios_base::sync_with_stdio(false);\\r\\n\\tcin.tie(NULL);\\r\\n\\r\\n\\tcin >> N >> M;\\r\\n\\r\\n\\tfor(int i = 0; i < N; i++) {\\r\\n\\t\\tprev_flight[i] = -1;\\r\\n\\t\\tdist[i] = -999999999;\\r\\n\\t\\tin_degree[i] = 0;\\r\\n\\t}\\r\\n\\r\\n\\tfor(int i = 0; i < M; i++) {\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\ta--, b--;\\r\\n\\t\\tin_degree[b]++;\\r\\n\\t\\tedge[a].push_back(b);\\r\\n\\r\\n\\t\\tbackEdge[b].push_back(a);\\r\\n\\t}\\r\\n\\r\\n\\tcompute();\\r\\n\\r\\n\\tstack<int> answer;\\r\\n\\tint temp = N - 1;\\r\\n\\r\\n\\tbool contains0 = false;\\r\\n\\tif(temp == 0) contains0 = true;\\r\\n\\r\\n\\twhile(temp != -1 && dist[temp] >= 0) {\\r\\n\\t\\tanswer.push(temp);\\r\\n\\t\\ttemp = prev_flight[temp];\\r\\n\\t\\tif(temp == 0) contains0 = true;\\r\\n\\t}\\r\\n\\r\\n\\tif(contains0) {\\r\\n\\t\\tcout << dist[N - 1] << \\\"\\\\n\\\";\\r\\n\\t\\twhile(!answer.empty()) {\\r\\n\\t\\t\\tcout << answer.top() + 1;\\r\\n\\t\\t\\tanswer.pop();\\r\\n\\t\\t\\tif(!answer.empty()) cout << \\\" \\\";\\r\\n\\t\\t}\\r\\n\\t\\tcout << \\\"\\\\n\\\";\\r\\n\\t} else {\\r\\n\\t\\tcout << \\\"IMPOSSIBLE\\\\n\\\";\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n}\\n\"\n            })\n          })\n        }), _jsx(JavaSection, {\n          children: _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-java\",\n              children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\n// longest_path\\r\\npublic class Main {\\r\\n\\tstatic int[] prevFlight, dist, inDegree;\\r\\n\\tstatic List<Integer>[] edge;\\r\\n\\tstatic List<Integer>[] backEdge;\\r\\n\\tstatic int N, M;\\r\\n\\r\\n\\t// does a topological sort\\r\\n\\tstatic void compute() {\\r\\n\\t\\tQueue<Integer> q = new ArrayDeque<Integer>();\\r\\n\\t\\tfor(int i = 0; i < N; i++) {\\r\\n\\t\\t\\tif(inDegree[i] == 0) {\\r\\n\\t\\t\\t\\tq.add(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\twhile(!q.isEmpty()) {\\r\\n\\t\\t\\tint node = q.poll();\\r\\n\\r\\n\\t\\t\\tfor(int next : edge[node]) {\\r\\n\\t\\t\\t\\tinDegree[next]--;\\r\\n\\t\\t\\t\\tif(inDegree[next] == 0) q.add(next);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// The below block computes the DP\\r\\n\\t\\t\\tint mx = -999999999;\\r\\n\\t\\t\\tint mx_node = -1;\\r\\n\\t\\t\\tfor(int prev : backEdge[node]) {\\r\\n\\t\\t\\t\\tif(dist[prev] + 1 > mx) {\\r\\n\\t\\t\\t\\t\\tmx = dist[prev] + 1;\\r\\n\\t\\t\\t\\t\\tmx_node = prev;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdist[node] = mx;\\r\\n\\t\\t\\tif(node == 0) dist[node] = 1;\\r\\n\\t\\t\\tprevFlight[node] = mx_node;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tpublic static void main(String[] args) throws Exception {\\r\\n\\t\\tFastIO sc = new FastIO(System.in); // View \\\"General - Fast I/O\\\" for more information about the \\\"FastIO\\\" class\\r\\n\\r\\n\\t\\tN = sc.nextInt();\\r\\n\\t\\tM = sc.nextInt();\\r\\n\\r\\n\\t\\tprevFlight = new int[N];\\r\\n\\t\\tdist = new int[N];\\r\\n\\t\\tinDegree = new int[N];\\r\\n\\t\\tedge = new List[N];\\r\\n\\t\\tbackEdge = new List[N];\\r\\n\\r\\n\\t\\tfor(int i = 0; i < N; i++) {\\r\\n\\t\\t\\tprevFlight[i] = -1;\\r\\n\\t\\t\\tdist[i] = -999999999;\\r\\n\\t\\t\\tinDegree[i] = 0;\\r\\n\\t\\t\\tedge[i] = new ArrayList<>();\\r\\n\\t\\t\\tbackEdge[i] = new ArrayList<>();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor(int i = 0; i < M; i++) {\\r\\n\\t\\t\\tint a = sc.nextInt() - 1;\\r\\n\\t\\t\\tint b = sc.nextInt() - 1;\\r\\n\\r\\n\\t\\t\\tinDegree[b]++;\\r\\n\\t\\t\\tedge[a].add(b);\\r\\n\\t\\t\\tbackEdge[b].add(a);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcompute();\\r\\n\\r\\n\\t\\tPrintWriter pw = new PrintWriter(System.out);\\r\\n\\r\\n\\t\\tArrayDeque<Integer> answer = new ArrayDeque<>(); // Acts as a Stack\\r\\n\\t\\tint temp = N - 1;\\r\\n\\r\\n\\t\\tboolean contains0 = false;\\r\\n\\t\\tif(temp == 0) contains0 = true;\\r\\n\\r\\n\\t\\twhile(temp != -1 && dist[temp] >= 0) {\\r\\n\\t\\t\\tanswer.push(temp);\\r\\n\\t\\t\\ttemp = prevFlight[temp];\\r\\n\\t\\t\\tif(temp == 0) contains0 = true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif(contains0) {\\r\\n\\t\\t\\tpw.println(dist[N - 1]);\\r\\n\\t\\t\\twhile(!answer.isEmpty()) {\\r\\n\\t\\t\\t\\tpw.print(answer.peekFirst() + 1);\\r\\n\\t\\t\\t\\tanswer.pop();\\r\\n\\t\\t\\t\\tif(!answer.isEmpty()) pw.print(\\\" \\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tpw.println();\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tpw.println(\\\"IMPOSSIBLE\\\\n\\\");\\r\\n\\t\\t}\\r\\n\\t\\tpw.close();\\r\\n\\t}\\r\\n\\r\\n\\t// BeginCodeSnip{FastIO}\\r\\n\\t// practically a necessity for Java users on CSES\\r\\n\\tstatic class FastIO {\\r\\n\\r\\n\\t\\tInputStream dis;\\r\\n\\t\\tbyte[] buffer = new byte[1 << 17];\\r\\n\\t\\tint pointer = 0;\\r\\n\\r\\n\\t\\tpublic FastIO(String fileName) throws Exception {\\r\\n\\t\\t\\tdis = new FileInputStream(fileName);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic FastIO(InputStream is) throws Exception {\\r\\n\\t\\t\\tdis = is;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint nextInt() throws Exception {\\r\\n\\t\\t\\tint ret = 0;\\r\\n\\r\\n\\t\\t\\tbyte b;\\r\\n\\t\\t\\tdo {\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t} while (b <= ' ');\\r\\n\\t\\t\\tboolean negative = false;\\r\\n\\t\\t\\tif (b == '-') {\\r\\n\\t\\t\\t\\tnegative = true;\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\twhile (b >= '0' && b <= '9') {\\r\\n\\t\\t\\t\\tret = 10 * ret + b - '0';\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn (negative) ? -ret : ret;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlong nextLong() throws Exception {\\r\\n\\t\\t\\tlong ret = 0;\\r\\n\\r\\n\\t\\t\\tbyte b;\\r\\n\\t\\t\\tdo {\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t} while (b <= ' ');\\r\\n\\t\\t\\tboolean negative = false;\\r\\n\\t\\t\\tif (b == '-') {\\r\\n\\t\\t\\t\\tnegative = true;\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\twhile (b >= '0' && b <= '9') {\\r\\n\\t\\t\\t\\tret = 10 * ret + b - '0';\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn (negative) ? -ret : ret;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tbyte nextByte() throws Exception {\\r\\n\\t\\t\\tif (pointer == buffer.length) {\\r\\n\\t\\t\\t\\tdis.read(buffer, 0, buffer.length);\\r\\n\\t\\t\\t\\tpointer = 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn buffer[pointer++];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tString next() throws Exception {\\r\\n\\t\\t\\tStringBuffer ret = new StringBuffer();\\r\\n\\r\\n\\t\\t\\tbyte b;\\r\\n\\t\\t\\tdo {\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t} while (b <= ' ');\\r\\n\\t\\t\\twhile (b > ' ') {\\r\\n\\t\\t\\t\\tret.appendCodePoint(b);\\r\\n\\t\\t\\t\\tb = nextByte();\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\treturn ret.toString();\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\t// EndCodeSnip\\r\\n}\\r\\n\\n\"\n            })\n          })\n        })]\n      })]\n    }), \"\\n\", \"\\n\", _jsxs(_components.h2, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"general\"\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  author,\n  contributors,\n  prerequisites,\n  description,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"Topological Sort","author":"Benjamin Qi, Nathan Chen","contributors":"Michael Cao, Andi Qu, Andrew Wang, Qi Wang, Maggie Liu","id":"toposort","prerequisites":["bfs","intro-dp"],"description":"An ordering of vertices in a directed acyclic graph that ensures that a node is visited before every node it has a directed edge to.","frequency":1},"parent":{"name":"TopoSort","relativePath":"4_Gold/TopoSort.mdx"},"fields":{"division":"gold"},"toc":{"cpp":[{"depth":2,"value":"Topological Sort","slug":"topological-sort"},{"depth":2,"value":"DFS","slug":"dfs"},{"depth":3,"value":"Finding a Cycle","slug":"finding-a-cycle"},{"depth":2,"value":"BFS","slug":"bfs"},{"depth":3,"value":"Course Schedule Solution","slug":"course-schedule-solution"},{"depth":2,"value":"Dynamic Programming","slug":"dynamic-programming"},{"depth":2,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Topological Sort","slug":"topological-sort"},{"depth":2,"value":"DFS","slug":"dfs"},{"depth":3,"value":"Finding a Cycle","slug":"finding-a-cycle"},{"depth":2,"value":"BFS","slug":"bfs"},{"depth":2,"value":"Dynamic Programming","slug":"dynamic-programming"},{"depth":2,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Topological Sort","slug":"topological-sort"},{"depth":2,"value":"DFS","slug":"dfs"},{"depth":3,"value":"Finding a Cycle","slug":"finding-a-cycle"},{"depth":2,"value":"BFS","slug":"bfs"},{"depth":2,"value":"Dynamic Programming","slug":"dynamic-programming"},{"depth":2,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[{"listId":"sample","problems":[{"uniqueId":"cses-1679","name":"Course Schedule","url":"https://cses.fi/problemset/task/1679","source":"CSES","difficulty":"Easy","isStarred":false,"tags":[],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/gold/toposort#problem-cses-1679","sketch":null}}]},{"listId":"dir","problems":[{"uniqueId":"cses-1678","name":"Round Trip II","url":"https://cses.fi/problemset/task/1678","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["Cycle"],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/gold/toposort#problem-cses-1678","sketch":null}}]},{"listId":"dp","problems":[{"uniqueId":"cses-1680","name":"Longest Flight Route","url":"https://cses.fi/problemset/task/1680","source":"CSES","difficulty":"Easy","isStarred":false,"tags":[],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/gold/toposort#problem-cses-1680","sketch":null}}]},{"listId":"general","problems":[{"uniqueId":"cses-1681","name":"Game Routes","url":"https://cses.fi/problemset/task/1681","source":"CSES","difficulty":"Easy","isStarred":true,"tags":["TopoSort"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"kattis-quantumsuperposition","name":"Quantum Superposition","url":"https://open.kattis.com/problems/quantumsuperposition","source":"Kattis","difficulty":"Easy","isStarred":true,"tags":["TopoSort"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1017","name":"Timeline","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1017","source":"Gold","difficulty":"Easy","isStarred":false,"tags":["TopoSort"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-919D","name":"Substring","url":"https://codeforces.com/contest/919/problem/D","source":"CF","difficulty":"Easy","isStarred":false,"tags":["TopoSort"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-510C","name":"Fox and Names","url":"https://codeforces.com/problemset/problem/510/C","source":"CF","difficulty":"Easy","isStarred":false,"tags":["TopoSort"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"usaco-838","name":"Milking Order","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=838","source":"Gold","difficulty":"Normal","isStarred":false,"tags":["TopoSort","Binary Search"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cses-1757","name":"Course Schedule II","url":"https://cses.fi/problemset/task/1757","source":"CSES","difficulty":"Hard","isStarred":false,"tags":["TopoSort"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}}]}]}},"pageContext":{"id":"toposort"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}