{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-packmen/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cf-847E\", source = \"CF\", title = \"Packmen\", author = \"Kevin Sheng\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    PySection: _missingComponent(\"PySection\")\n  }, _props.components), {MATHSPAN, LanguageSection, CPPSection, JavaSection, PySection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N\\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mi>log</mi><mo>‚Å°</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N\\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Binary search on the minimum time it will take for all the Packmen to eat all\\r\\nthe pellets. In that case, we would have to check whether the Packmen can eat\\r\\nall the pellets in \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"d\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\\\"application/x-tex\\\">d</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span></span></span></span>\"\n      }), \" units of time.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, notice a few observations:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Each Packman will eat a continuous subarray of the pellets, because a Packman\\r\\nwill visit all pellets between the leftmost and rightmost ones, and thus can\\r\\neat all pellets between them with no additional time penalty.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"No two Packmen need to eat overlapping subarrays, as the region of overlap can\\r\\nbe assigned to one of the Packman and be ignored by the other.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The leftmost Packman will eat the leftmost subarray of pellets, because if\\r\\nthis were not the case, the leftmost Packman will definitely cross over\\r\\nanother Packman. If this occurs, simply simulate (prevent) the crossing by\\r\\nreversing the directions of both Packmen instead. This ensures the leftmost\\r\\nPackman is always to the left of all other Packmen, and thus will eat a\\r\\nsubarray of pellets to the left of all others.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can repeatedly greedily assign the leftmost unprocessed Packman to the\\r\\nlargest possible subarray of pellets that includes the leftmost uneaten pellet.\\r\\nUsing this strategy, we can check whether all pellets can be eaten when the\\r\\nPackmen are limited to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"d\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\\\"application/x-tex\\\">d</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span></span></span></span>\"\n      }), \" units of time.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the below solution, we keep a sorted deque of all the pellet positions. For\\r\\neach Packman, we calculate the maximum number of pellets it can eat so that no\\r\\npellets to the left are uneaten, and then we remove the eaten pellets from the\\r\\ndeque.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, if a Packman can't eat the leftmost uneaten pellet, then the time \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"d\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\\\"application/x-tex\\\">d</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span></span></span></span>\"\n      }), \"\\r\\nwould be invalid, as we have shown previously that given a valid time \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"d\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\\\"application/x-tex\\\">d</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">d</span></span></span></span>\"\n      }), \" there\\r\\nmust exist an assignment where the leftmost Packman does eat the leftmost\\r\\nuneaten pellet.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are two main cases we consider for each Packman: one where the Packman\\r\\nfirst goes to the right and then to the left, and another where the Packman\\r\\nfirst goes to the \", _jsx(_components.em, {\n        children: \"left\"\n      }), \" and then to the right. We calculate the subarray of\\r\\npellets eaten in both of these cases and assign the larger one to the Packman.\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <string>\\r\\n#include <vector>\\r\\n#include <deque>\\r\\n#include <algorithm>\\r\\n\\r\\nusing std::cout;\\r\\nusing std::cin;\\r\\nusing std::endl;\\r\\nusing std::vector;\\r\\n\\r\\n// assumes packmen and food are all sorted and distinct (ALL the elements)\\r\\nbool all_eatable(const vector<int>& packmen, std::deque<int> food, int time) {\\r\\n\\tfor (int p : packmen) {\\r\\n\\t\\tvector<int> have_to_eat;\\r\\n\\t\\twhile (!food.empty() && food[0] < p) {\\r\\n\\t\\t\\thave_to_eat.push_back(food[0]);\\r\\n\\t\\t\\tfood.pop_front();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (have_to_eat.empty()) {\\r\\n\\t\\t\\t// ok, don't have to eat anything to the left, let's to the right as much as possible\\r\\n\\t\\t\\twhile (!food.empty() && food[0] - p <= time) {\\r\\n\\t\\t\\t\\tfood.pop_front();\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (p - have_to_eat[0] > time) {\\r\\n\\t\\t\\t\\t// oof, we can't eat the leftmost pellet, so we can't eat all of them\\r\\n\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tint left_time = p - have_to_eat[0];\\r\\n\\t\\t\\tint right_free_time = time - 2 * left_time;  // test for if we went to the left first\\r\\n\\t\\t\\tint left_first = -1;\\r\\n\\t\\t\\twhile (left_first + 1 < food.size() && food[left_first + 1] - p <= right_free_time) {\\r\\n\\t\\t\\t\\tleft_first++;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tright_free_time = time - left_time;  // test for if we went to the right first\\r\\n\\t\\t\\tint right_first = -1;\\r\\n\\t\\t\\twhile (right_first + 1 < food.size() && (food[right_first + 1] - p) * 2 <= right_free_time) {\\r\\n\\t\\t\\t\\tright_first++;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// take the maximum\\r\\n\\t\\t\\tfor (int i = 0; i < std::max(left_first, right_first) + 1; i++) {\\r\\n\\t\\t\\t\\tfood.pop_front();\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (food.empty()) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn food.empty();\\r\\n}\\r\\n\\r\\n/**\\r\\n * https://codeforces.com/contest/847/problem/E\\r\\n * 7\\r\\n * *..P*P* should output 3\\r\\n * 10\\r\\n * .**PP.*P.* should output 2\\r\\n */\\r\\nint main() {\\r\\n\\tint field_len;\\r\\n\\tcin >> field_len;\\r\\n\\tstd::string field;\\r\\n\\tcin >> field;\\r\\n\\tfor (char& c: field) {\\r\\n\\t\\tc = toupper(c);\\r\\n\\t}\\r\\n\\r\\n\\tvector<int> packmen;\\r\\n\\tstd::deque<int> food;\\r\\n\\tfor (int i = 0; i < field.length(); i++) {\\r\\n\\t\\tif (field[i] == 'P') {\\r\\n\\t\\t\\tpackmen.push_back(i);\\r\\n\\t\\t} else if (field[i] == '*') {\\r\\n\\t\\t\\tfood.push_back(i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tint lo = 0;\\r\\n\\tint hi = field.length() * 2;\\r\\n\\tint valid = -1;\\r\\n\\twhile (lo <= hi) {\\r\\n\\t\\tint mid = (lo + hi) / 2;\\r\\n\\t\\tif (all_eatable(packmen, food, mid)) {\\r\\n\\t\\t\\tvalid = mid;\\r\\n\\t\\t\\thi = mid - 1;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tlo = mid + 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tcout << valid << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.BufferedReader;\\r\\nimport java.io.IOException;\\r\\nimport java.io.InputStreamReader;\\r\\nimport java.util.ArrayList;\\r\\n\\r\\npublic class Packmen {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader read = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tread.readLine();\\r\\n\\t\\tchar[] field = read.readLine().toUpperCase().toCharArray();\\r\\n\\t\\tArrayList<Integer> packmen = new ArrayList<>();\\r\\n\\t\\tArrayList<Integer> food = new ArrayList<>();\\r\\n\\t\\tfor (int i = 0; i < field.length; i++) {\\r\\n\\t\\t\\tif (field[i] == 'P') {\\r\\n\\t\\t\\t\\tpackmen.add(i);\\r\\n\\t\\t\\t} else if (field[i] == '*') {\\r\\n\\t\\t\\t\\tfood.add(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint lo = 0;\\r\\n\\t\\tint hi = field.length * 2;\\r\\n\\t\\tint valid = -1;\\r\\n\\t\\twhile (lo <= hi) {\\r\\n\\t\\t\\tint mid = (lo + hi) / 2;\\r\\n\\t\\t\\tif (allEatable(packmen, food, mid)) {\\r\\n\\t\\t\\t\\tvalid = mid;\\r\\n\\t\\t\\t\\thi = mid - 1;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tlo = mid + 1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tSystem.out.println(valid);\\r\\n\\t}\\r\\n\\r\\n\\t// assumes everything is like sorted and distinct so my life is easier\\r\\n\\tprivate static boolean allEatable(ArrayList<Integer> packmen, ArrayList<Integer> food, int time) {\\r\\n\\t\\t/*\\r\\n\\t\\t * because java deques don't allow indexing, we instead keep a\\r\\n\\t\\t * pointer to the leftmost uneaten pellet and move it accordingly\\r\\n\\t\\t*/\\r\\n\\t\\tint foodPointer = 0;\\r\\n\\t\\tint foodAmt = food.size();  // shorthand\\r\\n\\t\\tfor (int p : packmen) {\\r\\n\\t\\t\\tArrayList<Integer> haveToEat = new ArrayList<>();\\r\\n\\t\\t\\twhile (foodPointer < foodAmt && food.get(foodPointer) < p) {\\r\\n\\t\\t\\t\\thaveToEat.add(food.get(foodPointer++));\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (haveToEat.isEmpty()) {\\r\\n\\t\\t\\t\\t// ok, don't have to eat anything to the left, let's to the right as much as possible\\r\\n\\t\\t\\t\\twhile (foodPointer < foodAmt && food.get(foodPointer) - p <= time) {\\r\\n\\t\\t\\t\\t\\tfoodPointer++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// oof, we can't eat the leftmost pellet, so we can't eat all of them\\r\\n\\t\\t\\t\\tif (p - haveToEat.get(0) > time) {\\r\\n\\t\\t\\t\\t\\treturn false;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tint leftTime = p - haveToEat.get(0);\\r\\n\\t\\t\\t\\t// try going to the left first then going to the right\\r\\n\\t\\t\\t\\tint rightFreeTime = time - 2 * leftTime;\\r\\n\\t\\t\\t\\tint leftFirst = -1;\\r\\n\\t\\t\\t\\twhile (foodPointer + leftFirst + 1 < foodAmt && food.get(foodPointer + leftFirst + 1) - p <= rightFreeTime) {\\r\\n\\t\\t\\t\\t\\tleftFirst++;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// try going to the left first\\r\\n\\t\\t\\t\\trightFreeTime = time - leftTime;\\r\\n\\t\\t\\t\\tint rightFirst = -1;\\r\\n\\t\\t\\t\\twhile (foodPointer + rightFirst + 1 < foodAmt && 2 * (food.get(foodPointer + rightFirst + 1) - p) <= rightFreeTime) {\\r\\n\\t\\t\\t\\t\\trightFirst++;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfoodPointer += Math.max(leftFirst, rightFirst) + 1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (foodPointer >= foodAmt) {\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn foodPointer >= foodAmt;\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"\\\"\\\"\\\"\\r\\nDISCLAIMER:\\r\\nTHIS SOLUTION ONLY WORKS IF YOU SUBMIT WITH PYPY\\r\\nNORMAL PYTHON FAILS ON TEST CASE 60\\r\\nhttps://codeforces.com/contest/847/problem/E\\r\\n7\\r\\n*..P*P* should output 3\\r\\n10\\r\\n.**PP.*P.* should output 2\\r\\n\\\"\\\"\\\"\\r\\nfrom typing import List\\r\\n\\r\\n\\r\\n# assumes the positions are sorted, as well that the positions are distinct\\r\\n# a deque is also usable (it is used in the c++ version), but this method was found to be faster\\r\\ndef eatable_in_time(food: List[int], packmen: List[int], time: int) -> bool:\\r\\n\\tfood_pointer = 0\\r\\n\\tfood_amt = len(food)  # convenient shorthand\\r\\n\\tfor p in packmen:\\r\\n\\t\\thave_to_eat = []\\r\\n\\t\\t# just assign this packmen all the ones to its left which haven't been eaten\\r\\n\\t\\twhile food_pointer < food_amt and food[food_pointer] < p:\\r\\n\\t\\t\\thave_to_eat.append(food[food_pointer])\\r\\n\\t\\t\\tfood_pointer += 1\\r\\n\\r\\n\\t\\tif not have_to_eat:\\r\\n\\t\\t\\twhile food_pointer < food_amt and food[food_pointer] - p <= time:\\r\\n\\t\\t\\t\\tfood_pointer += 1\\r\\n\\r\\n\\t\\telse:\\r\\n\\t\\t\\tif p - have_to_eat[0] > time:  # can't eat all of the pellets if we can't eat the leftmost one\\r\\n\\t\\t\\t\\treturn False\\r\\n\\r\\n\\t\\t\\t# try 2 diff strats- go to the left first and switch back or go to the right and switch back\\r\\n\\t\\t\\tleft_time = p - have_to_eat[0]\\r\\n\\t\\t\\tright_free_time = time - 2 * left_time\\r\\n\\t\\t\\tleft_first = -1\\r\\n\\t\\t\\twhile food_pointer + left_first + 1 < food_amt and food[food_pointer + left_first + 1] - p <= right_free_time:\\r\\n\\t\\t\\t\\tleft_first += 1\\r\\n\\r\\n\\t\\t\\tright_free_time = time - left_time\\r\\n\\t\\t\\tright_first = -1\\r\\n\\t\\t\\twhile food_pointer + right_first + 1 < food_amt and 2 * (food[food_pointer + right_first + 1] - p) <= right_free_time:\\r\\n\\t\\t\\t\\tright_first += 1\\r\\n\\t\\t\\tfood_pointer += max(left_first, right_first) + 1\\r\\n\\r\\n\\t\\tif food_pointer >= food_amt:  # ok all the food's been eaten\\r\\n\\t\\t\\treturn True\\r\\n\\treturn food_pointer >= food_amt\\r\\n\\r\\n\\r\\ninput()\\r\\nfield = input().upper()\\r\\n\\r\\nall_food = []\\r\\nall_packmen = []\\r\\nfor v, c in enumerate(field):\\r\\n\\tif c == 'P':\\r\\n\\t\\tall_packmen.append(v)\\r\\n\\telif c == '*':\\r\\n\\t\\tall_food.append(v)\\r\\n\\r\\nlo = 0\\r\\nhi = len(field) * 2\\r\\nvalid = -1\\r\\nwhile lo <= hi:\\r\\n\\tmid = (lo + hi) // 2\\r\\n\\tif eatable_in_time(all_food, all_packmen, mid):\\r\\n\\t\\tvalid = mid\\r\\n\\t\\thi = mid - 1\\r\\n\\telse:\\r\\n\\t\\tlo = mid + 1\\r\\nprint(valid)\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cf-847E","source":"CF","title":"Packmen","author":"Kevin Sheng"},"parent":{"name":"cf-847E","relativePath":"cf-847E.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"binary-search","title":"Binary Search"}}}}]},"problemInfo":{"uniqueId":"cf-847E","url":"https://codeforces.com/contest/847/problem/E"}},"pageContext":{"id":"cf-847E"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}