{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-1159-connecting-two-barns/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-1159\", source = \"USACO Silver 2021 December\", title = \"Connecting Two Barns\", author = \"Nathan Gong, Jesse Choe\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, JavaSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://usaco.org/current/data/sol_prob2_silver_dec21.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation---dfs--two-pointers\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation---dfs--two-pointers\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation - DFS + Two Pointers\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(T\\\\cdot (N + M))\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>T</mi><mo>⋅</mo><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy=\\\"false\\\">)</mo><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(T\\\\cdot (N + M))</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.13889em;\\\">T</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span><span class=\\\"mclose\\\">))</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class ConnectingTwoBarns {\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\t\\tint t = io.nextInt();\\r\\n\\t\\tfor (int test = 0; test < t; test++) {\\r\\n\\t\\t\\tint n = io.nextInt();\\r\\n\\t\\t\\tint m = io.nextInt();\\r\\n\\r\\n\\t\\t\\tList<List<Integer>> adj = new ArrayList<>();\\r\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\t\\tadj.add(new ArrayList<>());\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\t\\t\\tint a = io.nextInt() - 1;\\r\\n\\t\\t\\t\\tint b = io.nextInt() - 1;\\r\\n\\t\\t\\t\\tadj.get(a).add(b);\\r\\n\\t\\t\\t\\tadj.get(b).add(a);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// stores the component each node is in\\r\\n\\t\\t\\tint[] visited = new int[n];\\r\\n\\r\\n\\t\\t\\tint numComponents = 0;\\r\\n\\t\\t\\tArrays.fill(visited, -1);\\r\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\t\\t// run DFS on node if it hasn't been visited\\r\\n\\t\\t\\t\\tif (visited[i] == -1) {\\r\\n\\t\\t\\t\\t\\tStack<Integer> stack = new Stack<>();\\r\\n\\t\\t\\t\\t\\tstack.push(i);\\r\\n\\t\\t\\t\\t\\twhile (!stack.isEmpty()) {\\r\\n\\t\\t\\t\\t\\t\\tint curr = stack.pop();\\r\\n\\t\\t\\t\\t\\t\\tif (visited[curr] != -1) continue;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// mark node as visited\\r\\n\\t\\t\\t\\t\\t\\tvisited[curr] = numComponents;\\r\\n\\r\\n\\t\\t\\t\\t\\t\\tfor (int neighbor : adj.get(curr)) {\\r\\n\\t\\t\\t\\t\\t\\t\\tstack.push(neighbor);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tnumComponents++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// stores a list of nodes for each component\\r\\n\\t\\t\\tList<List<Integer>> components = new ArrayList<>();\\r\\n\\t\\t\\tfor (int i = 0; i < numComponents; i++) {\\r\\n\\t\\t\\t\\tcomponents.add(new ArrayList<>());\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t * add each field to its connected component; since we're iterating\\r\\n\\t\\t\\t * from 0...n-1, each component will be guaranteed to be in sorted\\r\\n\\t\\t\\t * order\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\t\\tcomponents.get(visited[i]).add(i);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// the components containing the two barns\\r\\n\\t\\t\\tList<Integer> barn1 = components.get(visited[0]);\\r\\n\\t\\t\\tList<Integer> barn2 = components.get(visited[n - 1]);\\r\\n\\t\\t\\t// min dist between each intermediate component and the two barns\\r\\n\\t\\t\\tlong[] dist1 = new long[numComponents];\\r\\n\\t\\t\\tlong[] dist2 = new long[numComponents];\\r\\n\\t\\t\\tArrays.fill(dist1, Integer.MAX_VALUE);\\r\\n\\t\\t\\tArrays.fill(dist2, Integer.MAX_VALUE);\\r\\n\\r\\n\\t\\t\\t// use two pointer to populate dist1\\r\\n\\t\\t\\tint barn1Index = 0;\\r\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\t\\tint dist = Math.abs(barn1.get(barn1Index) - i);\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t * if the distance between i and the current field in barn1's\\r\\n\\t\\t\\t\\t * component is larger than the distance between i and the next\\r\\n\\t\\t\\t\\t * field in barn1's component, increment barn1Index until this\\r\\n\\t\\t\\t\\t * no longer holds true\\r\\n\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\twhile (\\r\\n\\t\\t\\t\\t\\t// make sure we don't go out of bounds\\r\\n\\t\\t\\t\\t\\tbarn1Index < barn1.size() - 1\\r\\n\\t\\t\\t\\t\\t&& Math.abs(barn1.get(barn1Index + 1) - i) < dist\\r\\n\\t\\t\\t\\t) {\\r\\n\\t\\t\\t\\t\\tbarn1Index++;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t * we've now found the field in barn 1's component that's closest to i\\r\\n\\t\\t\\t\\t *\\r\\n\\t\\t\\t\\t * we can use this to update the minimum distance between field i's\\r\\n\\t\\t\\t\\t * component and barn 1's component\\r\\n\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\tdist1[visited[i]] = Math.min(dist, dist1[visited[i]]);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// use two pointer to populate dist2\\r\\n\\t\\t\\tint barn2Index = 0;\\r\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\t\\tint dist = Math.abs(barn2.get(barn2Index) - i);\\r\\n\\r\\n\\t\\t\\t\\twhile (\\r\\n\\t\\t\\t\\t\\tbarn2Index < barn2.size() - 1\\r\\n\\t\\t\\t\\t\\t&& Math.abs(barn2.get(barn2Index + 1) - i) < dist\\r\\n\\t\\t\\t\\t) {\\r\\n\\t\\t\\t\\t\\tbarn2Index++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tdist2[visited[i]] = Math.min(dist, dist2[visited[i]]);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// calculate minimum cost\\r\\n\\t\\t\\tlong min = Long.MAX_VALUE;\\r\\n\\t\\t\\tfor (int i = 0; i < numComponents; i++) {\\r\\n\\t\\t\\t\\tlong cost = dist1[i] * dist1[i] + dist2[i] * dist2[i];\\r\\n\\t\\t\\t\\tmin = Math.min(min, cost);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tio.println(min);\\r\\n\\t\\t}\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"alternative-implementation---dfs--binary-search\",\n      children: [_jsx(_components.a, {\n        href: \"#alternative-implementation---dfs--binary-search\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Alternative Implementation - DFS + Binary Search\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As the editorial mentioned, we can minimize the cost function by using binary search. Since each conncected component array is in sorted order (if we add the nodes of each connected component in increasing order), we can binary search on the sorted connected component array to find the closest field \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"j\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\\\"application/x-tex\\\">j</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.854em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span></span></span></span>\"\n      }), \" for each field \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n      }), \" using \", _jsx(_components.code, {\n        children: \"std::lower_bound\"\n      }), \".\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\n\\r\\nusing namespace std;\\r\\nusing ll = long long;\\r\\n\\r\\nconst int MAX_N = 1e5;\\r\\n\\r\\nvector<int> adj[MAX_N];\\r\\n// List of all the components of the farm\\r\\nvector<int> comps[MAX_N];\\r\\n// Given a node, returns the index of the component it belongs to\\r\\nint comp[MAX_N];\\r\\n\\r\\n// DFS to find the connected components\\r\\nvoid dfs(int cur, int c) {\\r\\n\\tif (comp[cur] != -1) {\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\tcomp[cur] = c;\\r\\n\\tfor (int u : adj[cur]) {\\r\\n\\t\\tdfs(u, c);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nll cost(int a, int b) {\\r\\n\\tint dist = MAX_N;\\r\\n\\tfor (int u : comps[a]) {\\r\\n\\t\\t/*\\r\\n\\t\\t * Finds the closest field in bs' connected\\r\\n\\t\\t * component to field u and updates the minimum\\r\\n\\t\\t * distance. The closest field is found by binary\\r\\n\\t\\t * searching on a sorted array (bs' connected \\r\\n\\t\\t * component).\\r\\n\\t\\t */\\r\\n\\t\\tint i = lower_bound(\\r\\n\\t\\t\\tcomps[b].begin(), comps[b].end(), u\\r\\n\\t\\t) - comps[b].begin();\\r\\n\\t\\tif (i > 0) {\\r\\n\\t\\t\\tdist = min(dist, abs(comps[b][i - 1] - u));\\r\\n\\t\\t}\\r\\n\\t\\tif (i < comps[b].size()) {\\r\\n\\t\\t\\tdist = min(dist, abs(comps[b][i] - u));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t/* \\r\\n\\t * Returns the minimum cost of building a path \\r\\n\\t * between the two components (aka dist^2)\\r\\n\\t */\\r\\n\\treturn (ll)dist * dist;\\r\\n}\\r\\n\\r\\nvoid solve() {\\r\\n\\tint n, m;\\r\\n\\tcin >> n >> m;\\r\\n\\r\\n\\t// Resets our variables for each test case\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tcomp[i] = -1;\\r\\n\\t\\tadj[i].clear();\\r\\n\\t\\tcomps[i].clear();\\r\\n\\t}\\r\\n\\r\\n\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\tadj[--a].push_back(--b);\\r\\n\\t\\tadj[b].push_back(a);\\r\\n\\t}\\r\\n\\r\\n\\t/* \\r\\n\\t * Stores the number of connected components \\r\\n\\t * (set to -1 so that we don't overcount)\\r\\n\\t */\\r\\n\\tint cur = -1;\\r\\n\\t// Uses DFS to find each connected component\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tif (comp[i] == -1) {\\r\\n\\t\\t\\tdfs(i, ++cur);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/*\\r\\n\\t * Add each field to its connected component.\\r\\n\\t * Since we're iterating from 0...n-1, each\\r\\n\\t * connected component is guaranteed to be \\r\\n\\t * in sorted order\\r\\n\\t */\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tcomps[comp[i]].push_back(i);\\r\\n\\t}\\r\\n\\r\\n\\t/*\\r\\n\\t * The initial answer is set to the cost of building\\r\\n\\t * a direct path between fields 1 and N. This also\\r\\n\\t * takes care of the case when fields 1 and N are in\\r\\n\\t * the same connected component.\\r\\n\\t */\\r\\n\\tll res = cost(comp[0], comp[n - 1]);\\r\\n\\tfor (int c = 1; c < cur; c++) {\\r\\n\\t\\t// Minimize the cost of building two paths\\r\\n\\t\\tres = min(res, cost(c, comp[0]) + cost(c, comp[n - 1]));\\r\\n\\t}\\r\\n\\tcout << res << endl;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tint t;\\r\\n\\tcin >> t;\\r\\n\\tfor (int i = 0; i < t; i++) {\\r\\n\\t\\tsolve();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-1159","source":"USACO Silver 2021 December","title":"Connecting Two Barns","author":"Nathan Gong, Jesse Choe"},"parent":{"name":"usaco-1159","relativePath":"usaco-1159.mdx"},"toc":{"cpp":[{"depth":2,"value":"Implementation - DFS + Two Pointers","slug":"implementation---dfs--two-pointers"},{"depth":2,"value":"Alternative Implementation - DFS + Binary Search","slug":"alternative-implementation---dfs--binary-search"}],"java":[{"depth":2,"value":"Implementation - DFS + Two Pointers","slug":"implementation---dfs--two-pointers"},{"depth":2,"value":"Alternative Implementation - DFS + Binary Search","slug":"alternative-implementation---dfs--binary-search"}],"py":[{"depth":2,"value":"Implementation - DFS + Two Pointers","slug":"implementation---dfs--two-pointers"},{"depth":2,"value":"Alternative Implementation - DFS + Binary Search","slug":"alternative-implementation---dfs--binary-search"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"dfs","title":"Depth First Search (DFS)"}}}}]},"problemInfo":{"uniqueId":"usaco-1159","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1159"}},"pageContext":{"id":"usaco-1159"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}