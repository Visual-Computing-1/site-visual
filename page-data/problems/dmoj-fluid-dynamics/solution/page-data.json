{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/dmoj-fluid-dynamics/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"dmoj-FluidDynamics\", source = \"DMOJ\", title = \"Fluid Dynamics\", author = \"Benjamin Qi\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\")\n  }, _props.components), {MATHSPAN, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(S\\\\sqrt{S\\\\log S})\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>S</mi><msqrt><mrow><mi>S</mi><mi>log</mi><mo>⁡</mo><mi>S</mi></mrow></msqrt><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(S\\\\sqrt{S\\\\log S})</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.085em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span><span class=\\\"mord sqrt\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.835em;\\\"><span class=\\\"svg-align\\\" style=\\\"top:-3em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"mord\\\" style=\\\"padding-left:0.833em;\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span></span></span><span style=\\\"top:-2.795em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"hide-tail\\\" style=\\\"min-width:0.853em;height:1.08em;\\\"><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl0 -0\\nc5.3,-9.3,12,-14,20,-14\\nH400000v40H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.205em;\\\"><span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \", where \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"S=N+Q\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>S</mi><mo>=</mo><mi>N</mi><mo>+</mo><mi>Q</mi></mrow><annotation encoding=\\\"application/x-tex\\\">S=N+Q</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8778em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">Q</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Maintain a linked list of convex hulls of size \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"BLOCK \\\\approx \\\\sqrt{S\\\\log S}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi><mi>L</mi><mi>O</mi><mi>C</mi><mi>K</mi><mo>≈</mo><msqrt><mrow><mi>S</mi><mi>log</mi><mo>⁡</mo><mi>S</mi></mrow></msqrt></mrow><annotation encoding=\\\"application/x-tex\\\">BLOCK \\\\approx \\\\sqrt{S\\\\log S}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span><span class=\\\"mord mathnormal\\\">L</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">OC</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">K</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≈</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.04em;vertical-align:-0.205em;\\\"></span><span class=\\\"mord sqrt\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.835em;\\\"><span class=\\\"svg-align\\\" style=\\\"top:-3em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"mord\\\" style=\\\"padding-left:0.833em;\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span></span></span><span style=\\\"top:-2.795em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"hide-tail\\\" style=\\\"min-width:0.853em;height:1.08em;\\\"><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl0 -0\\nc5.3,-9.3,12,-14,20,-14\\nH400000v40H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.205em;\\\"><span></span></span></span></span></span></span></span></span>\"\n      }), \"\\r\\neach. Each update and query takes \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(\\\\sqrt{S\\\\log S})\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msqrt><mrow><mi>S</mi><mi>log</mi><mo>⁡</mo><mi>S</mi></mrow></msqrt><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(\\\\sqrt{S\\\\log S})</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.085em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord sqrt\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.835em;\\\"><span class=\\\"svg-align\\\" style=\\\"top:-3em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"mord\\\" style=\\\"padding-left:0.833em;\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">S</span></span></span><span style=\\\"top:-2.795em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:3em;\\\"></span><span class=\\\"hide-tail\\\" style=\\\"min-width:0.853em;height:1.08em;\\\"><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl0 -0\\nc5.3,-9.3,12,-14,20,-14\\nH400000v40H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.205em;\\\"><span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" time. TL is\\r\\npretty tight ...\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nusing ll = long long;\\r\\nusing ld = long double;\\r\\nusing db = double;\\r\\nusing str = string; // yay python!\\r\\n\\r\\nusing pi = pair<int,int>;\\r\\nusing pl = pair<ll,ll>;\\r\\nusing pd = pair<db,db>;\\r\\n\\r\\nusing vi = vector<int>;\\r\\nusing vb = vector<bool>;\\r\\nusing vl = vector<ll>;\\r\\nusing vd = vector<db>;\\r\\nusing vs = vector<str>;\\r\\nusing vpi = vector<pi>;\\r\\nusing vpl = vector<pl>;\\r\\nusing vpd = vector<pd>;\\r\\n\\r\\n#define tcT template<class T\\r\\n#define tcTU tcT, class U\\r\\n// ^ lol this makes everything look weird but I'll try it\\r\\ntcT> using V = vector<T>;\\r\\ntcT, size_t SZ> using AR = array<T,SZ>;\\r\\ntcT> using PR = pair<T,T>;\\r\\n\\r\\n// pairs\\r\\n#define mp make_pair\\r\\n#define f first\\r\\n#define s second\\r\\n\\r\\n// vectors\\r\\n// oops size(x), rbegin(x), rend(x) need C++17\\r\\n#define sz(x) int((x).size())\\r\\n#define bg(x) begin(x)\\r\\n#define all(x) bg(x), end(x)\\r\\n#define rall(x) x.rbegin(), x.rend()\\r\\n#define sor(x) sort(all(x))\\r\\n#define rsz resize\\r\\n#define ins insert\\r\\n#define ft front()\\r\\n#define bk back()\\r\\n#define pb push_back\\r\\n#define eb emplace_back\\r\\n#define pf push_front\\r\\n\\r\\n#define lb lower_bound\\r\\n#define ub upper_bound\\r\\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\\r\\n\\r\\n// loops\\r\\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\\r\\n#define F0R(i,a) FOR(i,0,a)\\r\\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\\r\\n#define R0F(i,a) ROF(i,0,a)\\r\\n#define trav(a,x) for (auto& a: x)\\r\\n\\r\\nconst int MOD = 1e9+7; // 998244353;\\r\\nconst int MX = 2e5+5;\\r\\nconst ll INF = 1e18; // not too close to LLONG_MAX\\r\\nconst ld PI = acos((ld)-1);\\r\\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\\r\\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\\r\\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\\r\\n\\r\\n// bitwise ops\\r\\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\\r\\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\\r\\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\\r\\n\\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x))\\r\\nconstexpr int p2(int x) { return 1<<x; }\\r\\nconstexpr int msk2(int x) { return p2(x)-1; }\\r\\n\\r\\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\\r\\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\\r\\n\\r\\ntcT> bool ckmin(T& a, const T& b) {\\r\\n\\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\\r\\ntcT> bool ckmax(T& a, const T& b) {\\r\\n\\treturn a < b ? a = b, 1 : 0; }\\r\\n\\r\\ntcTU> T fstTrue(T lo, T hi, U f) {\\r\\n\\thi ++; assert(lo <= hi); // assuming f is increasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo)/2;\\r\\n\\t\\tf(mid) ? hi = mid : lo = mid+1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcTU> T lstTrue(T lo, T hi, U f) {\\r\\n\\tlo --; assert(lo <= hi); // assuming f is decreasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo+1)/2;\\r\\n\\t\\tf(mid) ? lo = mid : hi = mid-1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\\r\\n\\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\\r\\ntcTU> void erase(T& t, const U& u) { // don't erase\\r\\n\\tauto it = t.find(u); assert(it != end(t));\\r\\n\\tt.erase(it); } // element that doesn't exist from (multi)set\\r\\n\\r\\n// INPUT\\r\\n#define tcTUU tcT, class ...U\\r\\ntcT> void re(complex<T>& c);\\r\\ntcTU> void re(pair<T,U>& p);\\r\\ntcT> void re(V<T>& v);\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& a);\\r\\n\\r\\ntcT> void re(T& x) { cin >> x; }\\r\\nvoid re(db& d) { str t; re(t); d = stod(t); }\\r\\nvoid re(ld& d) { str t; re(t); d = stold(t); }\\r\\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\\r\\n\\r\\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\\r\\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\\r\\ntcT> void re(V<T>& x) { trav(a,x) re(a); }\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\\r\\ntcT> void rv(int n, V<T>& x) { x.rsz(n); re(x); }\\r\\n\\r\\n// TO_STRING\\r\\n#define ts to_string\\r\\nstr ts(char c) { return str(1,c); }\\r\\nstr ts(const char* s) { return (str)s; }\\r\\nstr ts(str s) { return s; }\\r\\nstr ts(bool b) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn b ? \\\"true\\\" : \\\"false\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts((int)b);\\r\\n\\t#endif\\r\\n}\\r\\ntcT> str ts(complex<T> c) {\\r\\n\\tstringstream ss; ss << c; return ss.str(); }\\r\\nstr ts(V<bool> v) {\\r\\n\\tstr res = \\\"{\\\"; F0R(i,sz(v)) res += char('0'+v[i]);\\r\\n\\tres += \\\"}\\\"; return res; }\\r\\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\\r\\n\\tstr res = \\\"\\\"; F0R(i,SZ) res += char('0'+b[i]);\\r\\n\\treturn res; }\\r\\ntcTU> str ts(pair<T,U> p);\\r\\ntcT> str ts(T v) { // containers with begin(), end()\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\tbool fst = 1; str res = \\\"{\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\", \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\tres += \\\"}\\\"; return res;\\r\\n\\t#else\\r\\n\\t\\tbool fst = 1; str res = \\\"\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\" \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\treturn res;\\r\\n\\r\\n\\t#endif\\r\\n}\\r\\ntcTU> str ts(pair<T,U> p) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn \\\"(\\\"+ts(p.f)+\\\", \\\"+ts(p.s)+\\\")\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts(p.f)+\\\" \\\"+ts(p.s);\\r\\n\\t#endif\\r\\n}\\r\\n\\r\\n// OUTPUT\\r\\ntcT> void pr(T x) { cout << ts(x); }\\r\\ntcTUU> void pr(const T& t, const U&... u) {\\r\\n\\tpr(t); pr(u...); }\\r\\nvoid ps() { pr(\\\"\\\\n\\\"); } // print w/ spaces\\r\\ntcTUU> void ps(const T& t, const U&... u) {\\r\\n\\tpr(t); if (sizeof...(u)) pr(\\\" \\\"); ps(u...); }\\r\\n\\r\\n// DEBUG\\r\\nvoid DBG() { cerr << \\\"]\\\" << endl; }\\r\\ntcTUU> void DBG(const T& t, const U&... u) {\\r\\n\\tcerr << ts(t); if (sizeof...(u)) cerr << \\\", \\\";\\r\\n\\tDBG(u...); }\\r\\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\\r\\n\\t#define dbg(...) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> [\\\" << #__VA_ARGS__ << \\\"]: [\\\", DBG(__VA_ARGS__)\\r\\n\\t#define chk(...) if (!(__VA_ARGS__)) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> function(\\\" \\\\\\r\\n\\t\\t << __FUNCTION__  << \\\") -> CHK FAILED: (\\\" << #__VA_ARGS__ << \\\")\\\" << \\\"\\\\n\\\", exit(0);\\r\\n#else\\r\\n\\t#define dbg(...) 0\\r\\n\\t#define chk(...) 0\\r\\n#endif\\r\\n\\r\\nvoid setPrec() { cout << fixed << setprecision(15); }\\r\\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\\r\\n// FILE I/O\\r\\nvoid setIn(str s) { freopen(s.c_str(),\\\"r\\\",stdin); }\\r\\nvoid setOut(str s) { freopen(s.c_str(),\\\"w\\\",stdout); }\\r\\nvoid setIO(str s = \\\"\\\") {\\r\\n\\tunsyncIO(); setPrec();\\r\\n\\t// cin.exceptions(cin.failbit);\\r\\n\\t// throws exception when do smth illegal\\r\\n\\t// ex. try to read letter into int\\r\\n\\tif (sz(s)) setIn(s+\\\".in\\\"), setOut(s+\\\".out\\\"); // for USACO\\r\\n}\\r\\n\\r\\n#pragma GCC optimize(\\\"Ofast\\\")\\r\\n#pragma GCC target(\\\"avx2\\\")\\r\\n\\r\\n// template code\\r\\n\\r\\nconst int BLOCK = 2000;\\r\\n\\r\\nint N,Q;\\r\\nll W;\\r\\n\\r\\ntypedef pl P;\\r\\ntypedef vector<P> vP;\\r\\nvP fluid;\\r\\n\\r\\nll CROSS(const P& a, const P& b) { return a.f*b.s-a.s*b.f; }\\r\\nll CROSS(const P& p, const P& a, const P& b) { return (a.f-p.f)*(b.s-p.s)-(a.s-p.s)*(b.f-p.f); }\\r\\nll cross(int a, int b, int c) { return CROSS(fluid[a],fluid[b],fluid[c]); }\\r\\nll dif(int a, int x) { return fluid[x].f*fluid[a].s-fluid[x].s*fluid[a].f; }\\r\\n\\r\\nll bs(int* v, const P& p, int lo, int hi) {\\r\\n\\tauto eval = [&](int x) { return fluid[x].f*p.f+fluid[x].s*p.s; };\\r\\n\\twhile (lo < hi) {\\r\\n\\t\\tint mid = (lo+hi)/2;\\r\\n\\t\\tif (eval(v[mid]) < eval(v[mid+1])) hi = mid;\\r\\n\\t\\telse lo = mid+1;\\r\\n\\t}\\r\\n\\treturn eval(v[lo]);\\r\\n}\\r\\n\\r\\nbool cmp(int a, int b) { return fluid[a] < fluid[b]; }\\r\\n\\r\\nstruct Hull {\\r\\n\\tint dat[BLOCK], lower[BLOCK];\\r\\n\\tint dsz = 0, usz = 0, lsz = 0;\\r\\n\\tll minDif(int x) { // get min of\\r\\n\\t\\tpl p = {-fluid[x].s,fluid[x].f};\\r\\n\\t\\treturn bs(lower,p,0,lsz-1);\\r\\n\\t}\\r\\n\\tbool bad(int x) { return minDif(x) >= W; }\\r\\n\\tvoid build() {\\r\\n\\t\\tvi xord; F0R(i,dsz) xord.pb(dat[i]);\\r\\n\\t\\tsort(all(xord),cmp); usz = lsz = 0;\\r\\n\\t\\tfor (int i: xord) {\\r\\n\\t\\t\\twhile (lsz > 1 && cross(lower[lsz-2],lower[lsz-1],i) <= 0) lsz --;\\r\\n\\t\\t\\tlower[lsz++] = i;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tvoid prin(int* a, int& b) {\\r\\n\\t\\tF0R(i,b) dbg(a[i]);\\r\\n\\t\\tdbg(\\\"----\\\");\\r\\n\\t}\\r\\n\\tvoid INS(int* a, int& b, int pos, int label) {\\r\\n\\t\\tROF(i,pos+1,b+1) a[i] = a[i-1];\\r\\n\\t\\ta[pos] = label;\\r\\n\\t\\tb ++;\\r\\n\\t}\\r\\n\\tvoid ERASE(int* a, int &b, int l, int r) {\\r\\n\\t\\tint dif = r-l; if (dif <= 0) return;\\r\\n\\t\\tFOR(i,r,b) a[i-dif] = a[i];\\r\\n\\t\\tb -= dif;\\r\\n\\t}\\r\\n\\tvoid insLower(int label) {\\r\\n\\t\\tint pos = lb(lower,lower+lsz,label,cmp)-lower;\\r\\n\\t\\tif (pos && pos < lsz) {\\r\\n\\t\\t\\tif (cross(lower[pos-1],lower[pos],label) >= 0) return;\\r\\n\\t\\t}\\r\\n\\t\\tINS(lower,lsz,pos,label);\\r\\n\\t\\t{\\r\\n\\t\\t\\tint nex = pos+1;\\r\\n\\t\\t\\twhile (nex+1 < lsz && cross(lower[pos],lower[nex],lower[nex+1]) <= 0) nex ++;\\r\\n\\t\\t\\tERASE(lower,lsz,pos+1,nex);\\r\\n\\t\\t}\\r\\n\\t\\t{\\r\\n\\t\\t\\tint nex = pos-1;\\r\\n\\t\\t\\twhile (nex > 0 && cross(lower[nex-1],lower[nex],lower[pos]) <= 0) nex --;\\r\\n\\t\\t\\tERASE(lower,lsz,nex+1,pos);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tvoid ins(int label) {\\r\\n\\t\\tint i = dsz;\\r\\n\\t\\twhile (i && dif(dat[i-1],label) >= W) i --;\\r\\n\\t\\tINS(dat,dsz,i,label);\\r\\n\\t\\tinsLower(label);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nvector<Hull> hull;\\r\\nvi NEX, PRE;\\r\\nint lst = -1;\\r\\n\\r\\nint num;\\r\\n\\r\\nint ad() {\\r\\n\\thull.pb(Hull()); NEX.pb(-1), PRE.pb(-1);\\r\\n\\treturn sz(hull)-1;\\r\\n}\\r\\n\\r\\nvoid link(int a, int b) {\\r\\n\\tNEX[a] = b;\\r\\n\\tif (b == -1) lst = a;\\r\\n\\telse PRE[b] = a;\\r\\n}\\r\\n\\r\\nint ti = 0;\\r\\n\\r\\nvoid split(int cur) {\\r\\n\\tint SZ = hull[cur].dsz; assert(SZ <= BLOCK);\\r\\n\\tif (SZ != BLOCK) return;\\r\\n\\tint CUR = ad();\\r\\n\\tint aft = NEX[cur];\\r\\n\\tlink(cur,CUR); link(CUR,aft);\\r\\n\\tint* v = hull[cur].dat; int m = SZ/2;\\r\\n\\t++ti;\\r\\n\\tassert(hull[CUR].dsz == 0);\\r\\n\\tFOR(i,m,SZ) {\\r\\n\\t\\tint t = v[i];\\r\\n\\t\\thull[CUR].dat[hull[CUR].dsz++] = t;\\r\\n\\t}\\r\\n\\thull[cur].dsz = m; assert(hull[CUR].dsz == m);\\r\\n\\thull[cur].build(); hull[CUR].build(); // split block into two\\r\\n}\\r\\n\\r\\nvoid ins(int v, int c) {\\r\\n\\tnum ++;\\r\\n\\tint label = sz(fluid); fluid.pb({v,c});\\r\\n\\tint cur = lst, pre = -1;\\r\\n\\twhile (cur != -1 && hull[cur].bad(label)) { pre = cur; cur = PRE[cur]; }\\r\\n\\tif (cur == -1) {\\r\\n\\t\\tif (pre == -1) {\\r\\n\\t\\t\\tassert(sz(fluid) == 1);\\r\\n\\t\\t\\tlst = pre = ad();\\r\\n\\t\\t}\\r\\n\\t\\tcur = pre;\\r\\n\\t}\\r\\n\\thull[cur].ins(label);split(cur);\\r\\n}\\r\\n\\r\\nint get(int k) {\\r\\n\\tk = num+1-k; assert(k);\\r\\n\\tfor (int cur = lst; ; cur = PRE[cur]) {\\r\\n\\t\\tassert(cur != -1);\\r\\n\\t\\tint* v = hull[cur].dat, SZ = hull[cur].dsz;\\r\\n\\t\\tif (SZ >= k) return v[SZ-k];\\r\\n\\t\\tk -= SZ;\\r\\n\\t}\\r\\n\\texit(5);\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tclock_t beg = clock();\\r\\n\\tsetIO(); re(N,Q,W);\\r\\n\\tF0R(i,N) {\\r\\n\\t\\tint v,c; re(v,c);\\r\\n\\t\\tins(v,c);\\r\\n\\t}\\r\\n\\tdbg(\\\"DONE WITH INSERTS\\\",(db)(clock()-beg)/CLOCKS_PER_SEC);\\r\\n\\tF0R(i,Q) {\\r\\n\\t\\tstr s; re(s);\\r\\n\\t\\tif (s == \\\"INSERT\\\") {\\r\\n\\t\\t\\tint v,c; re(v,c);\\r\\n\\t\\t\\tins(v,c);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tint k; re(k);\\r\\n\\t\\t\\tint p = get(k);\\r\\n\\t\\t\\tps(fluid[p].f,fluid[p].s);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tdbg((db)(clock()-beg)/CLOCKS_PER_SEC);\\r\\n}\\n\"\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"dmoj-FluidDynamics","source":"DMOJ","title":"Fluid Dynamics","author":"Benjamin Qi"},"parent":{"name":"dmoj-FluidDynamics","relativePath":"dmoj-FluidDynamics.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"sqrt","title":"Square Root Decomposition"}}}}]},"problemInfo":{"uniqueId":"dmoj-FluidDynamics","url":"https://dmoj.ca/problem/dmopc19c7p7"}},"pageContext":{"id":"dmoj-FluidDynamics"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}