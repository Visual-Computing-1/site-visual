{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-916-the-great-revegetation/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-916\", source = \"USACO Bronze 2019 February\", title = \"The Great Revegetation\", author = \"Ryan Chou, Brad Ma\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    PySection: _missingComponent(\"PySection\")\n  }, _props.components), {HeaderLink, LanguageSection, JavaSection, MATHSPAN, PySection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"solution-1\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 1\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_revegetate_bronze_feb19.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.StringTokenizer;\\r\\n\\r\\npublic class Revegetation {\\r\\n\\tstatic final int MAXIMUM = 151;\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tKattio io = new Kattio(\\\"revegetate\\\");\\r\\n\\t\\r\\n\\t\\tint[] grassA = new int[MAXIMUM];\\r\\n\\t\\tint[] grassB = new int[MAXIMUM];\\r\\n\\r\\n\\t\\t// stores the identity of adjacent verticies\\r\\n\\t\\tint[] G = new int[MAXIMUM];\\r\\n\\r\\n\\t\\tint n = io.nextInt();\\r\\n\\t\\tint m = io.nextInt();\\r\\n\\r\\n\\t\\tfor (int x = 0; x < m; x++) {\\r\\n\\t\\t\\tgrassA[x] = io.nextInt();\\r\\n\\t\\t\\tgrassB[x] = io.nextInt();\\r\\n\\r\\n\\t\\t\\t// put the smaller in A, the larger in B\\r\\n\\t\\t\\tif (grassA[x] > grassB[x]) {\\r\\n\\t\\t\\t\\tint temp = grassA[x];\\r\\n\\t\\t\\t\\tgrassA[x] = grassB[x];\\r\\n\\t\\t\\t\\tgrassB[x] = temp;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 1; i <= n; i++) {  // for each vertex\\r\\n\\t\\t\\tint j = 0;\\r\\n\\t\\t\\tfor (j = 1; j <= 4; j++) {  // check which colors are free\\r\\n\\t\\t\\t\\tboolean ok = true;\\r\\n\\t\\t\\t\\tfor (int k = 0; k < m; k++) {\\r\\n\\t\\t\\t\\t\\tif (grassB[k] == i && G[grassA[k]] == j) {\\r\\n\\t\\t\\t\\t\\t\\tok = false;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (ok) {\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tG[i] = j;\\r\\n\\t\\t\\tio.print(j);\\r\\n\\t\\t}\\r\\n\\t\\tio.println();\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-2\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-2\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 2\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can iterate through the favorite pastures, and increment one to the pasture with the greater index, making the result minimal. All pastures start with\\r\\nthe seed choice as one, this makes it so that we don't have to worry about decreasing or increasing more to a certain pasture. We'll also cycle through the\\r\\nprevious favorite pastures to make sure that our new alteration doesn't interfere with any of the other cow's favorite pastures.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation---solution-2\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation---solution-2\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation - Solution 2\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\nsys.stdin = open('revegetate.in', 'r')\\r\\nsys.stdout = open('revegetate.out', 'w')\\r\\n\\r\\npasture_num, cow_num = map(int, input().split())\\r\\npastures = []\\r\\nans = [1] * pasture_num\\r\\n\\r\\nfor _ in range(cow_num):\\r\\n\\tpast1, past2 = sorted(map(int, input().split()))\\r\\n\\t# Subtract one so that the indexes start from 0\\r\\n\\tpastures.append([past1 - 1, past2 - 1])\\r\\n\\r\\n# Assign the pastures at the front first.\\r\\npastures.sort()\\r\\nfor a, b in pastures:\\r\\n\\t# If they're not unique.\\r\\n\\tif ans[a] == ans[b]:\\r\\n\\t\\t# Increment one to the pasture closer to the end.\\r\\n\\t\\t# 100 is larger than 001.\\r\\n\\t\\tans[b] += 1\\r\\n\\r\\n\\t\\t# All favorite pastures up to the current one.\\r\\n\\t\\tfor i, j in pastures[:pastures.index([a, b])]:\\r\\n\\t\\t\\t# Increment again if requirement isn't satisfied.\\r\\n\\t\\t\\t# This also means that either i == b or j == b, \\r\\n\\t\\t\\t# since the only reason they would become equal again\\t\\r\\n\\t\\t\\t# is if they had a pasture in common.\\r\\n\\t\\t\\tif ans[i] == ans[j]:\\r\\n\\t\\t\\t\\tans[b] += 1\\r\\nprint(''.join(map(str, ans)))\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-916","source":"USACO Bronze 2019 February","title":"The Great Revegetation","author":"Ryan Chou, Brad Ma"},"parent":{"name":"usaco-916","relativePath":"usaco-916.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2","slug":"solution-2"},{"depth":2,"value":"Implementation - Solution 2","slug":"implementation---solution-2"}],"java":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2","slug":"solution-2"},{"depth":2,"value":"Implementation - Solution 2","slug":"implementation---solution-2"}],"py":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2","slug":"solution-2"},{"depth":2,"value":"Implementation - Solution 2","slug":"implementation---solution-2"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"intro-graphs","title":"Introduction to Graphs"}}}}]},"problemInfo":{"uniqueId":"usaco-916","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=916"}},"pageContext":{"id":"usaco-916"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}