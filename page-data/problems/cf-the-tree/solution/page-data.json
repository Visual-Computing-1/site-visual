{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-the-tree/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cf-1017G\", source = \"CF\", title = \"The Tree\", author = \"Dustin Miao\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"solution\",\n      children: [_jsx(_components.a, {\n        href: \"#solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.a, {\n        href: \"https://codeforces.com/blog/entry/61081\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"official editorial\"\n      }), \" mentions using \", _jsx(_components.a, {\n        href: \"/plat/hld\",\n        children: \"Heavy-Light Decomposition\"\n      }), \" to solve this problem, but never discusses the solution.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In each node, store a \", _jsx(_components.strong, {\n        children: \"propagation factor\"\n      }), \". This is essentially how much black has spread from the node, or equivalently, the number of operations of type 1 that has been performed. White nodes have a propagation factor of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"-1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">−</span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" and black nodes have a propagation factor that is greater than or equal to zero. An operation of type 1 now directly corresponds with increasing the propagation factor of a node by \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now consider operation 3 (and ignore operation 2 for now). How do we determine if a given node is black? Firstly, note that if the current node has a non-negative propagation factor, then it must be black. If instead its parent had a propagation factor greater than or equal to one, then the node would also be black.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In general, consider if operation 3 was called on some node \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \". Let \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" be any node that lies on the path from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" to the root. If the sum of propagation factors from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" is non-negative, then \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" must be black. What this means is that enough operations of type 1 have been applied from that node (and possibly other nodes on the path from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \") such that \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" has been made black.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For operations of type 2, we can easily clear a given subtree by taking advantage of the fact that HLD is really just a specific euler tour. Thus, a subtree of a node lies in a contiguous range in the heavy-light decomposition. We can clear a subtree by using lazy propagation and setting all nodes in a range to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"-1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">−</span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \". Next, we have to adjust the propagation factors of all nodes above \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \", where the operation was performed, which may take up to linear time. A simple trick is to subtract a factor of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"q - 1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>q</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">q - 1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7778em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">q</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" from node \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \", where \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"q\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>q</mi></mrow><annotation encoding=\\\"application/x-tex\\\">q</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">q</span></span></span></span>\"\n      }), \" is the value of a operation of type 3. This ensures that any query within \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \"'s subtree will correctly evaluate to white after the update.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note that for query operations, we need to find the maximum suffix sum for each path. This can be done by maintaining the maximum suffix sum as well as the actual sum in each segment tree node.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(n + q\\\\log^2n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo>+</mo><mi>q</mi><msup><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(n + q\\\\log^2n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.1484em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">q</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\"><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8984em;\\\"><span style=\\\"top:-3.1473em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nusing ll = long long\\r\\nusing pll = pair<ll, ll>;\\r\\n#define FF first\\r\\n#define SS second\\r\\n\\t\\r\\nconst int MAXN = 1e5 + 1;\\r\\n\\r\\nint N, Q;\\r\\nvector<int> G[MAXN];\\r\\n\\r\\n// Segment Tree:\\r\\nnamespace sgt {\\r\\n\\tpll T[MAXN * 4];  // {value, sum}\\r\\n\\tbool L[MAXN * 4];  // set tag\\r\\n\\r\\n\\tpll merge(pll l, pll r) {\\r\\n\\t\\tif (l.SS == -LLONG_MAX) {\\r\\n\\t\\t\\treturn r;\\r\\n\\t\\t}\\r\\n\\t\\tif (r.SS == -LLONG_MAX) {\\r\\n\\t\\t\\treturn l;\\r\\n\\t\\t}\\r\\n\\t\\treturn {max(l.FF + r.SS, r.FF), l.SS + r.SS};\\r\\n\\t}\\r\\n\\t\\r\\n\\tvoid build(int t = 1, int tl = 0, int tr = N - 1) {\\r\\n\\t\\tif (tl == tr) {\\r\\n\\t\\t\\tT[t].FF = T[t].SS = -1;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint tm = (tl + tr) >> 1;\\r\\n\\t\\tbuild(t << 1, tl, tm);\\r\\n\\t\\tbuild(t << 1 | 1, tm + 1, tr);\\r\\n\\t\\tT[t] = merge(T[t << 1], T[t << 1 | 1]);\\r\\n\\t}\\r\\n\\r\\n\\tvoid pushdown(int t, int tl, int tr) {\\r\\n\\t\\tif (!L[t]) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tint tm = (tl + tr) >> 1;\\r\\n\\t\\tT[t << 1] = {-1, -(tm - tl + 1)};\\r\\n\\t\\tT[t << 1 | 1] = {-1, -(tr - tm)};\\r\\n\\t\\tL[t << 1] = L[t << 1 | 1] = 1;\\r\\n\\t\\tL[t] = 0;\\r\\n\\t}\\r\\n\\r\\n\\tvoid update_range(int l, int r, int t = 1, int tl = 0, int tr = N - 1) {\\r\\n\\t\\tif (r < tl || tr < l) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tif (l <= tl && tr <= r) {\\r\\n\\t\\t\\tT[t] = {-1, -(tr - tl + 1)};\\r\\n\\t\\t\\tL[t] = 1;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tpushdown(t, tl, tr);\\r\\n\\r\\n\\t\\tint tm = (tl + tr) >> 1;\\r\\n\\t\\tupdate_range(l, r, t << 1, tl, tm);\\r\\n\\t\\tupdate_range(l, r, t << 1 | 1, tm + 1, tr);\\r\\n\\t\\tT[t] = merge(T[t << 1], T[t << 1 | 1]);\\r\\n\\t}\\r\\n\\r\\n\\tvoid update_point(int i, int v, int t = 1, int tl = 0, int tr = N - 1) {\\r\\n\\t\\tif (tl == tr) {\\r\\n\\t\\t\\tT[t].FF += v;\\r\\n\\t\\t\\tT[t].SS += v;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tpushdown(t, tl, tr);\\r\\n\\r\\n\\t\\tint tm = (tl + tr) >> 1;\\r\\n\\t\\tif (i <= tm) {\\r\\n\\t\\t\\tupdate_point(i, v, t << 1, tl, tm);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tupdate_point(i, v, t << 1 | 1, tm + 1, tr);\\r\\n\\t\\t}\\r\\n\\t\\tT[t] = merge(T[t << 1], T[t << 1 | 1]);\\r\\n\\t}\\r\\n\\r\\n\\tpll query(int l, int r, int t = 1, int tl = 0, int tr = N - 1) {\\r\\n\\t\\tif (r < tl || tr < l) {\\r\\n\\t\\t\\treturn {-LLONG_MAX, -LLONG_MAX};\\r\\n\\t\\t}\\r\\n\\t\\tif (l <= tl && tr <= r) {\\r\\n\\t\\t\\treturn T[t];\\r\\n\\t\\t}\\r\\n\\t\\tpushdown(t, tl, tr);\\r\\n\\r\\n\\t\\tint tm = (tl + tr) >> 1;\\r\\n\\t\\treturn merge(query(l, r, t << 1, tl, tm), query(l, r, t << 1 | 1, tm + 1, tr));\\r\\n\\t}\\r\\n}\\r\\n\\r\\n\\t\\r\\n// Heavy-Light Decomposition:\\r\\nnamespace hld {\\r\\n\\tint par[MAXN], hvy[MAXN], dep[MAXN], root[MAXN], lpos[MAXN], rpos[MAXN];\\r\\n\\r\\n\\t// initialize par, hvy, dep\\r\\n\\tint dfs1(int u) {\\r\\n\\t\\tint sze = 1, msub = 0;\\r\\n\\t\\tfor (int v : G[u]) {\\r\\n\\t\\t\\tpar[v] = u;\\r\\n\\t\\t\\tdep[v] = dep[u] + 1;\\r\\n\\t\\t\\tint sub = dfs1(v);\\r\\n\\t\\t\\tif (sub > msub) {\\r\\n\\t\\t\\t\\thvy[u] = v, msub = sub;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tsze += sub;\\r\\n\\t\\t}\\r\\n\\t\\treturn sze;\\r\\n\\t}\\r\\n\\r\\n\\t// initialize root, lpos, rpos\\r\\n\\tvoid dfs2(int u) {\\r\\n\\t\\tstatic int t = -1;\\r\\n\\r\\n\\t\\tlpos[u] = ++t;\\r\\n\\t\\tif (hvy[u] != -1) {\\r\\n\\t\\t\\troot[hvy[u]] = root[u];\\r\\n\\t\\t\\tdfs2(hvy[u]);\\r\\n\\t\\t}\\r\\n\\t\\tfor (int v : G[u]) \\r\\n\\t\\t\\tif (v != hvy[u]) {\\r\\n\\t\\t\\t\\troot[v] = v;\\r\\n\\t\\t\\t\\tdfs2(v);\\r\\n\\t\\t\\t}\\r\\n\\t\\trpos[u] = t;\\r\\n\\t}\\r\\n\\r\\n\\tvoid init() {\\r\\n\\t\\tfill_n(hvy, MAXN, -1);\\r\\n\\t\\tpar[1] = -1;\\r\\n\\t\\tdep[1] = 0;\\r\\n\\t\\tdfs1(1);\\r\\n\\t\\troot[1] = 1;\\r\\n\\t\\tdfs2(1);\\r\\n\\t\\tsgt::build();\\r\\n\\t}\\r\\n\\r\\n\\tpll query(int u) {\\r\\n\\t\\tpll ans = {-LLONG_MAX, -LLONG_MAX};\\r\\n\\t\\twhile (u != -1) {\\r\\n\\t\\t\\tans = sgt::merge(sgt::query(lpos[root[u]], lpos[u]), ans);\\r\\n\\t\\t\\tu = par[root[u]];\\r\\n\\t\\t}\\r\\n\\t\\treturn ans;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcin >> N >> Q;\\r\\n\\tfor (int i = 2; i <= N; i++) {\\r\\n\\t\\tint p; cin >> p;\\r\\n\\t\\tG[p].push_back(i);\\r\\n\\t}\\r\\n\\r\\n\\thld::init();\\r\\n\\twhile (Q--) {\\r\\n\\t\\tint t, u;\\r\\n\\t\\tcin >> t >> u;\\r\\n\\t\\tif (t == 1) {\\r\\n\\t\\t\\tsgt::update_point(hld::lpos[u], 1);\\r\\n\\t\\t} else if (t == 2) {\\r\\n\\t\\t\\tsgt::update_range(hld::lpos[u], hld::rpos[u]);\\r\\n\\t\\t\\tint q = hld::query(u).FF;\\r\\n\\t\\t\\tif (q >= 0) {\\r\\n\\t\\t\\t\\tsgt::update_point(hld::lpos[u], -q - 1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else if (t == 3) {\\r\\n\\t\\t\\tif (hld::query(u).FF >= 0) {\\r\\n\\t\\t\\t\\tcout << \\\"black\\\\n\\\";\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcout << \\\"white\\\\n\\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cf-1017G","source":"CF","title":"The Tree","author":"Dustin Miao"},"parent":{"name":"cf-1017G","relativePath":"cf-1017G.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"hld","title":"Heavy-Light Decomposition"}}}},{"node":{"module":{"frontmatter":{"id":"sqrt","title":"Square Root Decomposition"}}}}]},"problemInfo":{"uniqueId":"cf-1017G","url":"https://codeforces.com/contest/1017/problem/G"}},"pageContext":{"id":"cf-1017G"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}