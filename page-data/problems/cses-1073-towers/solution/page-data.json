{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1073-towers/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1073\", source = \"CSES\", title = \"Towers\", author = \"Nathan Gong, Benjamin Qi, Danh Ta Chi Thanh\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    a: \"a\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    PySection: _missingComponent(\"PySection\")\n  }, _props.components), {MATHSPAN, HeaderLink, LanguageSection, CPPSection, JavaSection, PySection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Greedy approach: always add the next cube on top of the tower with the smallest\\r\\npossible cube on top (or create a new tower if this isn't possible).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Equivalent to longest non-decreasing subsequence!\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It's important to note that we cannot use brute force to find the tower with the\\r\\nsmallest possible cube on top because that will yield a time complexity of\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \", which is too slow.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-1---binary-search--dynamic-array\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-1---binary-search--dynamic-array\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 1 - Binary Search + Dynamic Array\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N\\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mi>log</mi><mo>‚Å°</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N\\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can store existing towers using a dynamic array, where each tower's value is\\r\\nthe size of the cube on top. For each cube, we can run upper bound binary search\\r\\non the array to find the tower with the smallest top cube that's strictly larger\\r\\nthan the current cube. If we find a suitable tower, we add the cube to the top\\r\\nand change the tower's value to the size of the cube. If no such tower exists,\\r\\nappend a new tower to the end of the array. By doing so, we maintain the tower\\r\\narray in a sorted order (try and prove this for yourself). Our answer will be\\r\\nthe size of the array after all cubes have been processed.\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nusing vi = vector<int>;\\r\\n#define pb push_back\\r\\n#define sz(x) (int)(x).size()\\r\\n\\r\\nint n;\\r\\nvi x; // stores towers in non-decreasing order\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0); cin.tie(0);\\r\\n\\tcin >> n;\\r\\n\\tfor (int i = 0; i < n; ++i) {\\r\\n\\t\\tint z; cin >> z;\\r\\n\\t\\tint lo = 0, hi = sz(x);\\r\\n\\t\\twhile (lo < hi) {\\r\\n\\t\\t\\tint mid = (lo + hi) / 2;\\r\\n\\t\\t\\tif (x[mid] > z) hi = mid;\\r\\n\\t\\t\\telse lo = mid + 1;\\r\\n\\t\\t}\\r\\n\\t\\tif (lo == sz(x)) x.pb(z); // create new tower\\r\\n\\t\\telse x[lo] = z; // add to tower\\r\\n\\t}\\r\\n\\tcout << sz(x);\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class Towers {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\t\\tint n = io.nextInt();\\r\\n\\t\\tint[] cubes = new int[n];\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tcubes[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Stores towers in non-decreasing order\\r\\n\\t\\tList<Integer> towers = new ArrayList<>();\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\t// Upper bound binary search\\r\\n\\t\\t\\tint lo = 0;\\r\\n\\t\\t\\tint hi = towers.size();\\r\\n\\t\\t\\twhile (lo < hi) {\\r\\n\\t\\t\\t\\tint mid = (lo + hi) / 2;\\r\\n\\t\\t\\t\\tif (cubes[i] >= towers.get(mid)) lo = mid + 1;\\r\\n\\t\\t\\t\\telse hi = mid;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// If there aren't any suitable towers, append new tower to end of\\r\\n\\t\\t\\t// array\\r\\n\\t\\t\\tif (lo == towers.size()) {\\r\\n\\t\\t\\t\\ttowers.add(cubes[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// If there exists a satisfying tower, add the cube to that tower\\r\\n\\t\\t\\t// and update the top element of the tower\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\ttowers.set(lo, cubes[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tio.println(towers.size());\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"input()\\r\\n# Store the topmost cube of each tower\\r\\ntowers = []\\r\\nfor cube in map(int, input().split()):\\r\\n\\t# Binary search\\r\\n\\tleft = 0\\r\\n\\tright = len(towers) - 1\\r\\n\\ttower_idx = -1\\r\\n\\twhile left <= right:\\r\\n\\t\\tmid = (left + right) // 2\\r\\n\\t\\tif towers[mid] <= cube:\\r\\n\\t\\t\\tleft = mid + 1\\r\\n\\t\\telse:\\r\\n\\t\\t\\tright = mid - 1\\r\\n\\t\\t\\ttower_idx = mid\\r\\n\\r\\n\\t# If there exists a satisfying tower, add the cube to that tower and update\\r\\n\\t# the top element of the tower\\r\\n\\tif tower_idx != -1:\\r\\n\\t\\ttowers[tower_idx] = cube\\r\\n\\t# If there aren't any suitable towers, append new tower to end of array\\r\\n\\telse:\\r\\n\\t\\ttowers.append(cube)\\r\\nprint(len(towers))\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-2---multiset\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-2---multiset\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 2 - Multiset\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N\\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mi>log</mi><mo>‚Å°</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N\\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this approach, we store the towers using an ordered multiset (which can be\\r\\nrepresented as a\\r\\n\", _jsx(_components.a, {\n        href: \"/silver/intro-sorted-sets?lang=java#multisets\",\n        children: \"TreeMap\"\n      }), \" in\\r\\nJava), where each tower's value is the size of the cube on top. For each cube,\\r\\nwe can use built-in methods (\", _jsx(_components.code, {\n        children: \"upper_bound\"\n      }), \" in C++, \", _jsx(_components.code, {\n        children: \"higherKey\"\n      }), \" in Java) to find\\r\\nthe smallest-valued tower with a value strictly greater than the cube. If we\\r\\nfind a suitable tower, we add the cube to the top and change the tower's value\\r\\nto the size of the cube by removing the tower's previous value from the set and\\r\\nadding it's new value into it. If no such tower exists, we add a new tower to\\r\\nthe set. Our answer will be the total number of towers in the multiset (this\\r\\ntakes some extra work to find in Java) after all cubes have been processed.\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0);\\r\\n\\tcin.tie(0);\\r\\n\\tint n, k;\\r\\n\\tcin >> n;\\r\\n\\tmultiset<int> ans;\\r\\n\\tfor (int i = 0; i < n; ++i) {\\r\\n\\t\\tcin >> k;\\r\\n\\t\\tauto it = ans.upper_bound(k);\\r\\n\\t\\t// Find the tower having the element that is just larger than k to add\\r\\n\\t\\t// k to. If it doesn't exist then we create a new tower.\\r\\n\\t\\tif (it == ans.end()) ans.insert(k);\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// If there exists a satisfying tower, add k to that tower and\\r\\n\\t\\t\\t// update the top element of the tower\\r\\n\\t\\t\\tans.erase(it);\\r\\n\\t\\t\\tans.insert(k);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tcout << ans.size();\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class Towers {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\t\\tint n = io.nextInt();\\r\\n\\t\\tint[] cubes = new int[n];\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tcubes[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Maps tower value to frequency\\r\\n\\t\\tTreeMap<Integer, Integer> towers = new TreeMap<>();\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\t// If there are no suitable towers, add another tower to the set\\r\\n\\t\\t\\tif (towers.higherKey(cubes[i]) == null) {\\r\\n\\t\\t\\t\\ttowers.put(cubes[i], towers.getOrDefault(cubes[i], 0) + 1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// If there exists a satisfying tower, add the cube to that tower\\r\\n\\t\\t\\t// and update the top element of the tower\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tint size = towers.higherKey(cubes[i]);\\r\\n\\t\\t\\t\\ttowers.put(size, towers.get(size) - 1);\\r\\n\\t\\t\\t\\tif (towers.get(size) == 0) {\\r\\n\\t\\t\\t\\t\\ttowers.remove(size);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\ttowers.put(cubes[i], towers.getOrDefault(cubes[i], 0) + 1);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t// Calculate total number of towers\\r\\n\\t\\tint ans = 0;\\r\\n\\t\\tfor (int i : towers.values()) {\\r\\n\\t\\t\\tans += i;\\r\\n\\t\\t}\\r\\n\\t\\tio.println(ans);\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"from bisect import bisect\\r\\n\\r\\ninput()\\r\\n# Store the topmost cube of each tower\\r\\ntowers = []\\r\\nfor cube in map(int, input().split()):\\r\\n\\ttower_idx = bisect(towers, cube)\\r\\n\\r\\n\\t# If there exists a satisfying tower, add the cube to that tower and update\\r\\n\\t# the top element of the tower\\r\\n\\tif tower_idx < len(towers):\\r\\n\\t\\ttowers[tower_idx] = cube\\r\\n\\t# If there aren't any suitable towers, append new tower to end of array\\r\\n\\telse:\\r\\n\\t\\ttowers.append(cube)\\r\\nprint(len(towers))\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1073","source":"CSES","title":"Towers","author":"Nathan Gong, Benjamin Qi, Danh Ta Chi Thanh"},"parent":{"name":"cses-1073","relativePath":"cses-1073.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution 1 - Binary Search + Dynamic Array","slug":"solution-1---binary-search--dynamic-array"},{"depth":2,"value":"Solution 2 - Multiset","slug":"solution-2---multiset"}],"java":[{"depth":2,"value":"Solution 1 - Binary Search + Dynamic Array","slug":"solution-1---binary-search--dynamic-array"},{"depth":2,"value":"Solution 2 - Multiset","slug":"solution-2---multiset"}],"py":[{"depth":2,"value":"Solution 1 - Binary Search + Dynamic Array","slug":"solution-1---binary-search--dynamic-array"},{"depth":2,"value":"Solution 2 - Multiset","slug":"solution-2---multiset"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"lis","title":"Longest Increasing Subsequence"}}}},{"node":{"module":{"frontmatter":{"id":"greedy-sorting","title":"Greedy Algorithms with Sorting"}}}}]},"problemInfo":{"uniqueId":"cses-1073","url":"https://cses.fi/problemset/task/1073"}},"pageContext":{"id":"cses-1073"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}