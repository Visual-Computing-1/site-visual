{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/apio-2011find-the-path/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"apio-11-FindThePath\", source = \"APIO 2011\", title = \"Find the Path\", author = \"Albert Ye, Andi Qu\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    Spoiler: _missingComponent(\"Spoiler\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, Spoiler, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"solution\",\n      children: [_jsx(_components.a, {\n        href: \"#solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time complexity\"\n      }), \": \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2 \\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2 \\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The framing of the problem means that it is most likely a Dijkstra problem; the\\r\\nhardest part is designing the nodes and edges.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To form the edges, we look at the possible movements that we can take. Firstly,\\r\\nwe can jump off of the current rectangle and potentially reach a new rectangle.\\r\\nSecondly, we can move along our current rectangle.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this case, every point on the border of a Deehive is a vertex, and edges\\r\\nconnect adjacent points on Deehives as well as jumps between Deehives. However,\\r\\nthis would be too many (up to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"10^9\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">10^9</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">9</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \") verticies and edges!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To optimize, we can use coordinate compression. Consider the set of significant\\r\\nlattices lines: those passing through corners (and edges) of Deehives, the start\\r\\npoint, or end point. Let significant lattice points be all intersections of\\r\\nthese lines.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It can be shown that any path (between two significant lattice points) through\\r\\nTooDee can be transformed to use only significant lattice lines without\\r\\nincreasing the length of the path.\"\n    }), \"\\n\", _jsxs(Spoiler, {\n      title: \"Reasoning\",\n      children: [_jsxs(_components.p, {\n        children: [\"Suppose a Dee were to perform a \\\"jump\\\" between two Deehives. This jump starts\\r\\nfrom a significant lattice line and ends at another parallel significant lattice\\r\\nline (This is because edges of deehives are significant). If the Dee does not\\r\\nalready jump along a significant lattice line, then the jump must have occurred\\r\\ninside a \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"1 \\\\times k\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn><mo>×</mo><mi>k</mi></mrow><annotation encoding=\\\"application/x-tex\\\">1 \\\\times k</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">×</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span></span></span></span>\"\n        }), \" rectangle of significant lattice squares.\"]\n      }), _jsxs(_components.p, {\n        children: [\"Consider the first and last corners of this rectangle visited by the Dee. There\\r\\nis no increase in distance if the Dee instead took the shortest route along the\\r\\nborder of this rectangle, traversing only along significant lattice lines. Note\\r\\nthat this will always be possible if the initial jump is possible, because no\\r\\nDeehive can cover the border of the \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"1 \\\\times k\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn><mo>×</mo><mi>k</mi></mrow><annotation encoding=\\\"application/x-tex\\\">1 \\\\times k</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">×</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span></span></span></span>\"\n        }), \" rectangle without covering the\\r\\ninternal region as well.\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Build the graph along the significant lattice grid and run Dijkstra's algorithm\\r\\nto find the shortest path.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"code\",\n      children: [_jsx(_components.a, {\n        href: \"#code\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Code\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\n#define FOR(i, x, y) for (int i = x; i < y; i++)\\r\\ntypedef long long ll;\\r\\nusing namespace std;\\r\\n\\r\\nstruct Rect {\\r\\n\\tint x1, y1, x2, y2;\\r\\n\\tRect(int a = 0, int b = 0, int c = 0, int d = 0): x1(a), y1(b), x2(c), y2(d) {\\r\\n\\t\\tif (x1 > x2) swap(x1, x2);\\r\\n\\t\\tif (y1 > y2) swap(y1, y2);\\r\\n\\t}\\r\\n} rects[1005];\\r\\n\\r\\nvector<int> xs, ys;\\r\\n\\r\\nint idx(int val, vector<int> vec) { return lower_bound(vec.begin(), vec.end(), val) - vec.begin(); }\\r\\n\\r\\nstruct Node {\\r\\n\\tint x, y;\\r\\n\\toperator int() const { return x * ys.size() + y; }\\r\\n\\tNode(int a = 0, int b = 0): x(a), y(b) {}\\r\\n};\\r\\n\\r\\nbool cmp_x(pair<Node, int> a, pair<Node, int> b) {\\r\\n\\tif (a.first.y == b.first.y) return a.first.x < b.first.x;\\r\\n\\treturn a.first.y < b.first.y;\\r\\n}\\r\\nbool cmp_y(pair<Node, int> a, pair<Node, int> b) {\\r\\n\\tif (a.first.x == b.first.x) return a.first.y < b.first.y;\\r\\n\\treturn a.first.x < b.first.x;\\r\\n}\\r\\n\\r\\nll dist(Node a, Node b) { return abs(xs[a.x] - xs[b.x]) + abs(ys[a.y] - ys[b.y]); }\\r\\n\\r\\nvector<Node> graph[5000001];\\r\\nbool visited[5000001];\\r\\n\\r\\nll dijkstra(Node src, Node dest) {\\r\\n\\tpriority_queue<pair<ll, Node>> pq;\\r\\n\\tpq.push({0, src});\\r\\n\\twhile (pq.size()) {\\r\\n\\t\\tll d = pq.top().first;\\r\\n\\t\\tNode curr = pq.top().second;\\r\\n\\t\\tpq.pop();\\r\\n\\t\\tif (curr == dest) return -d;\\r\\n\\t\\tif (!visited[curr]) {\\r\\n\\t\\t\\tvisited[curr] = true;\\r\\n\\t\\t\\tfor (Node i : graph[curr]) pq.push({d - dist(curr, i), i});\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn -1;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0);\\r\\n\\tcin.tie(0);\\r\\n\\tint t;\\r\\n\\tcin >> t;\\r\\n\\twhile (t--) {\\r\\n\\t\\tint sx, sy, dx, dy;\\r\\n\\t\\tcin >> sx >> sy >> dx >> dy;\\r\\n\\t\\tint n;\\r\\n\\t\\tcin >> n;\\r\\n\\t\\tFOR(i, 0, n) {\\r\\n\\t\\t\\tint a, b, c, d;\\r\\n\\t\\t\\tcin >> a >> b >> c >> d;\\r\\n\\t\\t\\trects[i] = Rect(a, b, c, d);\\r\\n\\t\\t}\\r\\n\\t\\trects[n++] = Rect(sx, sy, sx, sy);\\r\\n\\t\\trects[n++] = Rect(dx, dy, dx, dy);\\r\\n\\r\\n\\t\\t// Coordinate compression\\r\\n\\t\\txs.clear(); ys.clear();\\r\\n\\t\\tFOR(i, 0, n) {\\r\\n\\t\\t\\txs.push_back(rects[i].x1); xs.push_back(rects[i].x2);\\r\\n\\t\\t\\tys.push_back(rects[i].y1); ys.push_back(rects[i].y2);\\r\\n\\t\\t}\\r\\n\\t\\tsort(xs.begin(), xs.end());\\r\\n\\t\\txs.erase(unique(xs.begin(), xs.end()), xs.end());\\r\\n\\t\\tsort(ys.begin(), ys.end());\\r\\n\\t\\tys.erase(unique(ys.begin(), ys.end()), ys.end());\\r\\n\\r\\n\\t\\tFOR(i, 0, n) {\\r\\n\\t\\t\\trects[i].x1 = idx(rects[i].x1, xs);\\r\\n\\t\\t\\trects[i].x2 = idx(rects[i].x2, xs);\\r\\n\\t\\t\\trects[i].y1 = idx(rects[i].y1, ys);\\r\\n\\t\\t\\trects[i].y2 = idx(rects[i].y2, ys);\\r\\n\\t\\t}\\r\\n\\t\\tsx = idx(sx, xs); sy = idx(sy, ys);\\r\\n\\t\\tdx = idx(dx, xs); dy = idx(dy, ys);\\r\\n\\r\\n\\t\\t// Reset the graph\\r\\n\\t\\tFOR(i, 0, xs.size() * ys.size()) {\\r\\n\\t\\t\\tgraph[i].clear();\\r\\n\\t\\t\\tvisited[i] = false;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Connect adjancent points on rectangles\\r\\n\\t\\tFOR(i, 0, n) {\\r\\n\\t\\t\\tFOR(x, rects[i].x1, rects[i].x2) for (int y : {rects[i].y1, rects[i].y2}) {\\r\\n\\t\\t\\t\\tgraph[Node(x, y)].push_back(Node(x + 1, y));\\r\\n\\t\\t\\t\\tgraph[Node(x + 1, y)].push_back(Node(x, y));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tFOR(y, rects[i].y1, rects[i].y2) for (int x : {rects[i].x1, rects[i].x2}) {\\r\\n\\t\\t\\t\\tgraph[Node(x, y)].push_back(Node(x, y + 1));\\r\\n\\t\\t\\t\\tgraph[Node(x, y + 1)].push_back(Node(x, y));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Line sweep to connect points between different rectangles\\r\\n\\t\\tvector<pair<Node, int>> x_events;\\r\\n\\t\\tFOR(i, 0, n) {\\r\\n\\t\\t\\tFOR(y, rects[i].y1, rects[i].y2 + 1) {\\r\\n\\t\\t\\t\\tx_events.push_back({{rects[i].x1, y}, 1});\\r\\n\\t\\t\\t\\tx_events.push_back({{rects[i].x2, y}, -1});\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tsort(x_events.begin(), x_events.end(), cmp_x);\\r\\n\\t\\tint cnt = 0;\\r\\n\\t\\tFOR(i, 0, x_events.size()) {\\r\\n\\t\\t\\tif (!cnt && i && x_events[i].first.y == x_events[i - 1].first.y) {\\r\\n\\t\\t\\t\\tgraph[x_events[i].first].push_back(x_events[i - 1].first);\\r\\n\\t\\t\\t\\tgraph[x_events[i - 1].first].push_back(x_events[i].first);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcnt += x_events[i].second;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvector<pair<Node, int>> y_events;\\r\\n\\t\\tFOR(i, 0, n) {\\r\\n\\t\\t\\tFOR(x, rects[i].x1, rects[i].x2 + 1) {\\r\\n\\t\\t\\t\\ty_events.push_back({{x, rects[i].y1}, 1});\\r\\n\\t\\t\\t\\ty_events.push_back({{x, rects[i].y2}, -1});\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tsort(y_events.begin(), y_events.end(), cmp_y);\\r\\n\\t\\tcnt = 0;\\r\\n\\t\\tFOR(i, 0, y_events.size()) {\\r\\n\\t\\t\\tif (!cnt && i && y_events[i].first.x == y_events[i - 1].first.x) {\\r\\n\\t\\t\\t\\tgraph[y_events[i].first].push_back(y_events[i - 1].first);\\r\\n\\t\\t\\t\\tgraph[y_events[i - 1].first].push_back(y_events[i].first);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcnt += y_events[i].second;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Dijkstra\\r\\n\\t\\tll ans = dijkstra({sx, sy}, {dx, dy});\\r\\n\\t\\tif (~ans) cout << ans << '\\\\n';\\r\\n\\t\\telse cout << \\\"No Path\\\\n\\\";\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"apio-11-FindThePath","source":"APIO 2011","title":"Find the Path","author":"Albert Ye, Andi Qu"},"parent":{"name":"apio-11-FindThePath","relativePath":"apio-11-FindThePath.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Code","slug":"code"}],"java":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Code","slug":"code"}],"py":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Code","slug":"code"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"shortest-paths","title":"Shortest Paths with Non-Negative Edge Weights"}}}}]},"problemInfo":{"uniqueId":"apio-11-FindThePath","url":"https://dmoj.ca/problem/apio11p2"}},"pageContext":{"id":"apio-11-FindThePath"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}