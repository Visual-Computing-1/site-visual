{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/ioi-2009mecho/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"ioi-09-mecho\", source = \"IOI 2009\", title = \"Mecho\", author = \"Neha Sane\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://ioinformatics.org/files/ioi2009solutions.pdf#page=51\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"explanation\",\n      children: [_jsx(_components.a, {\n        href: \"#explanation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Explanation\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Assuming that Mecho can reach his cave before the bees, it is guaranteed that Mecho\\r\\ncan do this if he eats for any time between 0 and x. Any time greater than x would\\r\\nallow the bees to catch Mecho.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"From this observation, we find out that we can binary search on the eating time to\\r\\nfind the latest possible time Mecho can leave. For time x, which is the amount of\\r\\ntime Mecho eats for, we check if Mecho can reach his cave before the bees. If he\\r\\ncan, then binary search on times greater than x, otherwise, binary search on times\\r\\nsmaller than x. Do this until a single eating time is left. To see if Mecho can\\r\\nreach his cave before the bees, he needs to have a path on which every square is a\\r\\ngrassy patch, and is reachable by Mecho before the bees.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Run one BFS for the bees, and record the time taken for the bees to reach every\\r\\npossible node in the graph.Then run another BFS for Mecho, where a node will only\\r\\nbe visited by Mecho if it is a grassy patch and the bees took more time reach the\\r\\nnode than Mecho. If both these conditions are fulfilled, then we can say that Mecho\\r\\nreached the node before the bees. At the end of the BFS, check if Mecho reached any\\r\\nof the four nodes surrounding his cave. If he did, then Mecho successfully reached\\r\\nthe cave while eating for x time. Otherwise, Mecho will have to eat for less than x\\r\\ntime.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Output the maximum waiting time found out by the binary search. If Mecho cannot reach\\r\\nthe cave even when he ate for 0 units of time, then there is no path from his\\r\\nstarting position to the cave. In this case, output -1.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2\\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mi>log</mi><mo>‚Å°</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2\\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nconst int MAX_N = 800;\\r\\nvector<string> field(MAX_N);\\r\\nint n, s;\\r\\n\\r\\nbool valid_sq(int x, int y) {\\r\\n\\treturn x >= 0 && x < n && y >= 0 && y < n\\r\\n\\t\\t&& (field[x][y] == 'G' || field[x][y] == 'M');\\r\\n}\\r\\n\\r\\nbool mecho_reached(int mecho_dis, int bees_dis){\\r\\n\\treturn mecho_dis / s < bees_dis;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcin >> n >> s;\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tcin >> field[i];\\r\\n\\t}\\r\\n\\t\\r\\n\\tvector<pair<int, int>> hives;\\r\\n\\tint mechox, mechoy, home_x, home_y;\\r\\n\\t// find x and y coordinates for for Mecho, the bees and the cave\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tfor (int j = 0; j < n; j++) {\\r\\n\\t\\t\\tif (field[i][j] == 'M') {\\r\\n\\t\\t\\t\\tmechox = i;\\r\\n\\t\\t\\t\\tmechoy = j;\\r\\n\\t\\t\\t} else if (field[i][j] == 'H') {\\r\\n\\t\\t\\t\\thives.push_back({i, j});\\r\\n\\t\\t\\t} else if (field[i][j] == 'D') {\\r\\n\\t\\t\\t\\thome_x = i;\\r\\n\\t\\t\\t\\thome_y = j;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tint dx[] = {-1, 0, 1, 0};\\r\\n\\tint dy[] = {0, -1, 0, 1};\\r\\n\\r\\n\\t// binary search on waiting time\\r\\n\\tint l = 0;\\r\\n\\tint r = n * n;\\r\\n\\twhile (l <= r) {\\r\\n\\t\\tvector<vector<bool>> bees_visited(n, vector<bool>(n));\\r\\n\\t\\tvector<vector<bool>> mecho_visited(n, vector<bool>(n));\\r\\n\\t\\tvector<vector<int>> bees_time(n, vector<int>(n));\\r\\n\\t\\tvector<vector<int>> mecho_time(n, vector<int>(n));\\r\\n\\t\\tqueue<pair<int, int>> q;\\r\\n\\t\\t\\r\\n\\t\\tint eating_time = (l + r) / 2;\\r\\n\\r\\n\\t\\t// move bees\\r\\n\\t\\tfor (auto i : hives) {\\r\\n\\t\\t\\tq.push({i.first, i.second});\\r\\n\\t\\t\\tbees_visited[i.first][i.second] = true;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\twhile (!q.empty()) {\\r\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\r\\n\\t\\t\\tq.pop();\\r\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\r\\n\\t\\t\\t\\tif (valid_sq(nx, ny) && !bees_visited[nx][ny]) {\\r\\n\\t\\t\\t\\t\\tbees_time[nx][ny] = bees_time[x][y] + 1;    \\r\\n\\t\\t\\t\\t\\tq.push({nx, ny});\\r\\n\\t\\t\\t\\t\\tbees_visited[nx][ny] = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t\\r\\n\\t\\t// move Mecho\\r\\n\\t\\tq.push({mechox, mechoy});\\r\\n\\t\\tmecho_visited[mechox][mechoy] = true;\\r\\n\\t\\tif (bees_time[mechox][mechoy] <= eating_time) {\\r\\n\\t\\t\\tq.pop();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\twhile (!q.empty()) {\\r\\n\\t\\t\\tint x = q.front().first, y = q.front().second;\\r\\n\\t\\t\\tq.pop();\\r\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\t\\tint nx = x + dx[i], ny = y + dy[i];\\r\\n\\t\\t\\t\\t/* \\r\\n\\t\\t\\t\\t * check if mecho reaces node[x][y] before the bees\\r\\n\\t\\t\\t\\t * divide the time mecho takes to reach a node by s, since \\r\\n\\t\\t\\t\\t * mecho walks s steps at a time.\\r\\n\\t\\t\\t\\t * substract the eating time from the time taken for the \\r\\n\\t\\t\\t\\t * bees to reach the node, because that time was used by \\r\\n\\t\\t\\t\\t * mecho for eating\\r\\n\\t\\t\\t\\t*/\\r\\n\\t\\t\\t\\tif (valid_sq(nx, ny) && !mecho_visited[nx][ny] && \\r\\n\\t\\t\\t\\t\\tmecho_reached(mecho_time[x][y] + 1, bees_time[nx][ny]\\r\\n\\t\\t\\t\\t\\t- eating_time)) {\\r\\n\\t\\t\\t\\t\\t\\tmecho_visited[nx][ny] = true;\\r\\n\\t\\t\\t\\t\\t\\tq.push({nx, ny});\\r\\n\\t\\t\\t\\t\\t\\tmecho_time[nx][ny] = mecho_time[x][y] + 1;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\r\\n\\t\\t// check if mecho reached a node surrounding his cave before the bees\\r\\n\\t\\tbool reached = false;\\r\\n\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\tint nx = home_x + dx[i], ny = home_y + dy[i];\\r\\n\\t\\t\\tif (valid_sq(nx, ny) && mecho_reached(mecho_time[nx][ny], \\r\\n\\t\\t\\t\\tbees_time[nx][ny] - eating_time) && mecho_visited[nx][ny]) {\\r\\n\\t\\t\\t\\t\\treached = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif (reached) {\\r\\n\\t\\t\\tl = eating_time + 1;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tr = eating_time - 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tcout << l - 1 << '\\\\n';\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"ioi-09-mecho","source":"IOI 2009","title":"Mecho","author":"Neha Sane"},"parent":{"name":"ioi-09-mecho","relativePath":"ioi-09-mecho.mdx"},"toc":{"cpp":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"bfs","title":"Breadth First Search (BFS)"}}}}]},"problemInfo":{"uniqueId":"ioi-09-mecho","url":"https://oj.uz/problem/view/IOI09_mecho"}},"pageContext":{"id":"ioi-09-mecho"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}