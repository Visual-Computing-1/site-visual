{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/kattis-birthday-party/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"kattis-birthday\", source = \"VT HSPC 2014\", title = \"Birthday Party\", author = \"Michael Cao, Nathan Gong\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    pre: \"pre\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"In this problem, we're given some people who have others numbers, and are asked\\r\\nwhether if some pair of friends lose each others numbers it will be impossible\\r\\nto invite everyone.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"generating-the-graph\",\n      children: [_jsx(_components.a, {\n        href: \"#generating-the-graph\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Generating the Graph\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Once we've dissected the text in the problem statement, we can apply the\\r\\nfollowing definitions:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Define a person \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"x\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n          }), \" as a node.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"If two nodes \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"a\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span></span></span></span>\"\n          }), \" and \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"b\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n          }), \" have each other's numbers, connect them with an\\r\\nundirected edge.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Everyone can be invited to the party if there exists exactly one connected\\r\\ncomponent in the graph.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now the problem becomes: given a graph with \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"p \\\\: (1 \\\\leq p \\\\leq 100)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>p</mi><mtext> </mtext><mo stretchy=\\\"false\\\">(</mo><mn>1</mn><mo>≤</mo><mi>p</mi><mo>≤</mo><mn>100</mn><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">p \\\\: (1 \\\\leq p \\\\leq 100)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">p</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\">1</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≤</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8304em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">p</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≤</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord\\\">100</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" nodes and\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"c \\\\: (0 \\\\leq c \\\\leq 5000)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>c</mi><mtext> </mtext><mo stretchy=\\\"false\\\">(</mo><mn>0</mn><mo>≤</mo><mi>c</mi><mo>≤</mo><mn>5000</mn><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">c \\\\: (0 \\\\leq c \\\\leq 5000)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\">0</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≤</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7719em;vertical-align:-0.136em;\\\"></span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≤</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord\\\">5000</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" edges, can you remove some edge to break the graph\\r\\ninto more than one connected component?\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"applying-dfs\",\n      children: [_jsx(_components.a, {\n        href: \"#applying-dfs\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Applying DFS\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Since the constraints on edges (and nodes) is small, we can run\\r\\n\", _jsx(_components.a, {\n        href: \"/silver/dfs/\",\n        children: \"DFS\"\n      }), \" on the graph. For each edge, let's run a DFS while ensuring\\r\\nwe don't traverse that edge. If we can't visit some node, then the answer is\\r\\n\\\"YES\\\". Otherwise, if we're able to visit every node for each edge that gets\\r\\nremoved, the answer is \\\"NO\\\" (notice the problem asks whether it's impossible to\\r\\ninvite everyone).\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"ignoring-edges\",\n      children: [_jsx(_components.a, {\n        href: \"#ignoring-edges\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Ignoring Edges\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The easiest way to ignore edges in a graph is to represent the graph with an\\r\\nadjacency matrix (we can do this because the number of nodes is very small).\\r\\nTo ignore an edge that connects two nodes \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \", we can simply set\\r\\n\", _jsx(_components.code, {\n        children: \"adj[a][b]\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"adj[b][a]\"\n      }), \" to false. Later, when we want to add the edge back,\\r\\nwe can update \", _jsx(_components.code, {\n        children: \"adj[a][b]\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"adj[b][a]\"\n      }), \" to true.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\nusing ll = long long;\\r\\nusing vi = vector<int>;\\r\\n#define pb push_back\\r\\n#define rsz resize\\r\\n#define all(x) begin(x), end(x)\\r\\n#define sz(x) (int)(x).size()\\r\\nusing pi = pair<int,int>;\\r\\n#define f first\\r\\n#define s second\\r\\n#define mp make_pair\\r\\nvoid setIO(string name = \\\"\\\") { // name is nonempty for USACO file I/O\\r\\n\\tios_base::sync_with_stdio(0); cin.tie(0); // see Fast Input & Output\\r\\n\\tif(sz(name)){\\r\\n\\t\\tfreopen((name+\\\".in\\\").c_str(), \\\"r\\\", stdin); // see Input & Output\\r\\n\\t\\tfreopen((name+\\\".out\\\").c_str(), \\\"w\\\", stdout);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint n, m;\\r\\n// Adjacency matrix\\r\\nbool adj[105][105];\\r\\nbool vis[105];\\r\\n\\r\\nvoid dfs(int v) {\\r\\n\\tvis[v] = true;\\r\\n\\tfor (int to = 0; to < n; to++) {\\r\\n\\t\\tif (adj[v][to] && !vis[to]) {\\r\\n\\t\\t\\tdfs(to);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nvoid solve() {\\r\\n\\tmemset(adj, false, sizeof(adj));\\r\\n\\tvector<pi> edges;\\r\\n\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\tint u, v;\\r\\n\\t\\tcin >> u >> v;\\r\\n\\t\\tadj[u][v] = true;\\r\\n\\t\\tadj[v][u] = true;\\r\\n\\t\\tedges.pb(mp(u, v));\\r\\n\\t}\\r\\n\\tfor (pi x : edges) {\\r\\n\\t\\tadj[x.f][x.s] = false;\\r\\n\\t\\tadj[x.s][x.f] = false;\\r\\n\\t\\tmemset(vis, false, sizeof(vis));\\r\\n\\t\\tdfs(0);\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tif (!vis[i]) {\\r\\n\\t\\t\\t\\tcout << \\\"Yes\\\" << '\\\\n';\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tadj[x.f][x.s] = true;\\r\\n\\t\\tadj[x.s][x.f] = true;\\r\\n\\t}\\r\\n\\tcout << \\\"No\\\" << '\\\\n';\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tsetIO();\\r\\n\\twhile (cin >> n >> m && (n || m)) {\\r\\n\\t\\tsolve();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\n\\r\\npublic class BirthdayParty {\\r\\n\\tstatic int p, c;\\r\\n\\tstatic boolean[][] adj;\\r\\n\\tstatic boolean[] vis;\\r\\n\\t\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tScanner sc = new Scanner(System.in);\\r\\n\\r\\n\\t\\twhile (true) {\\r\\n\\t\\t\\tboolean allConnected = true;\\r\\n\\t\\t\\tp = sc.nextInt();\\r\\n\\t\\t\\tc = sc.nextInt();\\r\\n\\r\\n\\t\\t\\tif (p == 0 && c == 0) break;\\r\\n\\r\\n\\t\\t\\t// Adjacency matrix\\r\\n\\t\\t\\tadj = new boolean[p][p];\\r\\n\\t\\t\\tEdge[] edges = new Edge[c];\\r\\n\\t\\t\\tfor (int i = 0; i < c; i++) {\\r\\n\\t\\t\\t\\tint a = sc.nextInt();\\r\\n\\t\\t\\t\\tint b = sc.nextInt();\\r\\n\\t\\t\\t\\tadj[a][b] = true;\\r\\n\\t\\t\\t\\tadj[b][a] = true;\\r\\n\\t\\t\\t\\tedges[i] = new Edge(a, b);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tfor (Edge edge : edges) {\\r\\n\\t\\t\\t\\t// Remove the current edge we're looking at from the graph\\r\\n\\t\\t\\t\\tadj[edge.a][edge.b] = false;\\r\\n\\t\\t\\t\\tadj[edge.b][edge.a] = false;\\r\\n\\r\\n\\t\\t\\t\\tvis = new boolean[p];\\r\\n\\t\\t\\t\\tdfs(0);\\r\\n\\r\\n\\t\\t\\t\\tfor (int i = 0; i < p; i++) {\\r\\n\\t\\t\\t\\t\\t// If a node wasn't visited after the dfs, that means that\\r\\n\\t\\t\\t\\t\\t// the nodes aren't all in one connected component\\r\\n\\t\\t\\t\\t\\tif (!vis[i]) {\\r\\n\\t\\t\\t\\t\\t\\tallConnected = false;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t// Add the edge back to the graph\\r\\n\\t\\t\\t\\tadj[edge.a][edge.b] = true;\\r\\n\\t\\t\\t\\tadj[edge.b][edge.a] = true;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tif (allConnected) {\\r\\n\\t\\t\\t\\tSystem.out.println(\\\"No\\\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tSystem.out.println(\\\"Yes\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tstatic void dfs(int pos) {\\r\\n\\t\\tvis[pos] = true;\\r\\n\\t\\tfor (int to = 0; to < p; to++) {\\r\\n\\t\\t\\tif (adj[pos][to] && !vis[to]) {\\r\\n\\t\\t\\t\\tdfs(to);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tstatic class Edge {\\r\\n\\t\\tint a, b;\\r\\n\\r\\n\\t\\tEdge(int a, int b) {\\r\\n\\t\\t\\tthis.a = a;\\r\\n\\t\\t\\tthis.b = b;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"kattis-birthday","source":"VT HSPC 2014","title":"Birthday Party","author":"Michael Cao, Nathan Gong"},"parent":{"name":"kattis-birthday","relativePath":"kattis-birthday.mdx"},"toc":{"cpp":[{"depth":2,"value":"Generating the Graph","slug":"generating-the-graph"},{"depth":2,"value":"Applying DFS","slug":"applying-dfs"},{"depth":2,"value":"Ignoring Edges","slug":"ignoring-edges"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Generating the Graph","slug":"generating-the-graph"},{"depth":2,"value":"Applying DFS","slug":"applying-dfs"},{"depth":2,"value":"Ignoring Edges","slug":"ignoring-edges"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Generating the Graph","slug":"generating-the-graph"},{"depth":2,"value":"Applying DFS","slug":"applying-dfs"},{"depth":2,"value":"Ignoring Edges","slug":"ignoring-edges"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"dfs","title":"Depth First Search (DFS)"}}}}]},"problemInfo":{"uniqueId":"kattis-birthday","url":"https://open.kattis.com/problems/birthday"}},"pageContext":{"id":"kattis-birthday"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}