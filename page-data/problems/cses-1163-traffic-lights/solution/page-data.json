{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1163-traffic-lights/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1163\", source = \"CSES\", title = \"Traffic Lights\", author = \"Danh Ta Chi Thanh, Ben Dodge, Kevin Sheng\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    Warning: _missingComponent(\"Warning\")\n  }, _props.components), {MATHSPAN, HeaderLink, LanguageSection, CPPSection, JavaSection, Warning, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In this problem, we are given an empty interval of length \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \" spanning from 0 to\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \", and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" points are added to the interval chronologically. We want to find\\r\\nthe largest gap between the points after each step.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://codeforces.com/blog/entry/83295\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Unofficial Editorial (C++)\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-1\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 1\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's create a set and a multiset. The set will store\\r\\nthe positions of the traffic lights, while the multiset will keep track of the\\r\\n\\\"gaps\\\" between the lights. The multiset keeps expanding because more lights are\\r\\nadded, and you just need to print the length of the longest passage without\\r\\ntraffic lights after each addition (i.e. the max element of that multiset). This\\r\\nelement is the last element by default.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note that when placing a new traffic light on the road, that light will split\\r\\nthe gap between two adjacent lights into two smaller pieces, so you also have to\\r\\nremove the length of that gap in the multiset and add two new lengths to the\\r\\nmultiset.\"\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\n//constant initialization\\r\\nconst int maxn=2e5+10;\\r\\n\\r\\n//variables used for the current problem\\r\\nint x,n,p; set<int> lights; multiset<int> dist;\\r\\n\\r\\nvoid solve() {\\r\\n\\tcin >> x >> n;\\r\\n\\tlights.insert(0); lights.insert(x);\\r\\n\\tdist.insert(x);\\r\\n\\tfor (int i=0;i<n;++i){\\r\\n\\t\\tcin >> p;\\r\\n\\t\\tauto it1 = lights.upper_bound(p),it2 = it1; --it2;\\r\\n\\t\\tdist.erase(dist.find(*it1-*it2));\\r\\n\\t\\tdist.insert(p-*it2); dist.insert(*it1-p);\\r\\n\\t\\tlights.insert(p);\\r\\n\\t\\tauto ans = dist.end(); --ans;\\r\\n\\t\\tcout << *ans << \\\" \\\";\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main(){\\r\\n\\tios_base::sync_with_stdio(false);\\r\\n\\tcin.tie(nullptr);\\r\\n\\tsolve();\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-2---going-backwards\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-2---going-backwards\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 2 - Going Backwards\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We'll start by trying to find the maximum gap once all the traffic lights are\\r\\nadded. This is the last number we'll output, so we'll add it to the end of our\\r\\noutput array. Then, we'll remove traffic lights in the reverse order to how they\\r\\nwere added, and find the gap each removal creates.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This gap is just the distance between the two street coordinates (either a\\r\\ntraffic light or the beginning or ending of the street) next to a given traffic\\r\\nlight stored in our set, so we can use our set to find these values and subtract\\r\\nthem to get our gap.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But this gap may not be the maximum gap. We'll compare this to the gap we found\\r\\nonce all the traffic lights are added, and set the max gap to the greater value.\\r\\nWe'll then set the next lowest element in the output array to this value, which\\r\\nwill represent the greatest gap prior to adding the traffic light we just\\r\\nremoved.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(JavaSection, {\n        children: [_jsx(Warning, {\n          children: _jsx(_components.p, {\n            children: \"Due to the small CSES time limit, it's possible that standard input/output will occasionally TLE.\"\n          })\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class TrafficLights {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tKattio io = new Kattio(); \\r\\n\\t\\r\\n\\t\\tint streetLength = io.nextInt();\\r\\n\\t\\tint lightNum = io.nextInt();\\r\\n\\r\\n\\t\\t// Using an array to read values since we can't get values from sets in Java\\r\\n\\t\\tint[] opArray = new int[lightNum];\\r\\n\\t\\tNavigableSet<Integer> streetPositions = new TreeSet<>();\\r\\n\\t\\t// Initialize the set with beginning and ending values\\r\\n\\t\\tstreetPositions.add(0);\\r\\n\\t\\tstreetPositions.add(streetLength);\\r\\n\\r\\n\\t\\tfor (int i = 0; i < lightNum; i++) {\\r\\n\\t\\t\\tint nextTrafficLight = io.nextInt();\\r\\n\\t\\t\\topArray[i] = nextTrafficLight;\\r\\n\\t\\t\\tstreetPositions.add(nextTrafficLight);\\r\\n\\t\\t}\\r\\n\\t\\tint[] gapsArray = new int[lightNum];\\r\\n\\t\\tint prev = 0;\\r\\n\\t\\tint maxGap = 0;\\r\\n\\t\\t// Find the longest passage once all the streetlights are added\\r\\n\\t\\tfor (int i : streetPositions) {\\r\\n\\t\\t\\tmaxGap = Math.max(i - prev, maxGap);\\r\\n\\t\\t\\tprev = i;\\r\\n\\t\\t}\\r\\n\\t\\tgapsArray[lightNum - 1] = maxGap;\\r\\n\\t\\t/*\\r\\n\\t\\t * Remove the streetlights in reverse order to how they were added, then find\\r\\n\\t\\t * the gap created by removing each. Find the biggest current gap, and \\r\\n\\t\\t * add it to the next lowest index in answer.\\r\\n\\t\\t */\\r\\n\\t\\tfor (int i = lightNum - 1; i > 0; i--) {\\r\\n\\t\\t\\tstreetPositions.remove(opArray[i]);\\r\\n\\t\\t\\tint low = streetPositions.lower(opArray[i]);\\r\\n\\t\\t\\tint high = streetPositions.higher(opArray[i]);\\r\\n\\t\\t\\tmaxGap = Math.max(maxGap, high - low);\\r\\n\\t\\t\\tgapsArray[i - 1] = maxGap;\\r\\n\\t\\t}\\r\\n\\t\\t//  Use StringBuilder to print out the array quicker\\r\\n\\t\\tStringBuilder sb = new StringBuilder();\\r\\n\\t\\tfor (int i : gapsArray) {\\r\\n\\t\\t\\tsb.append(i).append(\\\" \\\");\\r\\n\\t\\t}\\r\\n\\t\\tio.println(sb);\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })]\n      }), _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <set>\\r\\n#include <algorithm>\\r\\n\\r\\nusing std::cout;\\r\\nusing std::endl;\\r\\nusing std::vector;\\r\\n\\r\\nint main() {\\r\\n\\tint street_len;\\r\\n\\tint light_num;\\r\\n\\tstd::cin >> street_len >> light_num;\\r\\n\\tvector<int> lights(light_num);\\r\\n\\tfor (int& l : lights) {\\r\\n\\t\\tstd::cin >> l;\\r\\n\\t}\\r\\n\\t// Initialize the set with beginning and ending values\\r\\n\\tstd::set<int> street_pos{0, street_len};\\r\\n\\tfor (int l : lights) {\\r\\n\\t\\tstreet_pos.insert(l);\\r\\n\\t}\\r\\n\\r\\n\\tvector<int> gaps(light_num);\\r\\n\\tint prev = 0;\\r\\n\\tint max_gap = 0;\\r\\n\\t// Find the longest passage once all the streetlights are added\\r\\n\\tfor (int p : street_pos) {\\r\\n\\t\\tmax_gap = std::max(max_gap, p - prev);\\r\\n\\t\\tprev = p;\\r\\n\\t}\\r\\n\\tgaps.back() = max_gap;\\r\\n\\r\\n\\t/*\\r\\n\\t * Remove the streetlights in reverse order to how they were added, then find\\r\\n\\t * the gap created by removing each. Find the biggest current gap, and \\r\\n\\t * add it to the next lowest index in answer.\\r\\n\\t */\\r\\n\\tfor (int i = light_num - 1; i > 0; i--) {\\r\\n\\t\\tstreet_pos.erase(lights[i]);\\r\\n\\t\\tauto high_it = street_pos.upper_bound(lights[i]);\\r\\n\\t\\tint high = *high_it;\\r\\n\\t\\tint low = *(--high_it);\\r\\n\\t\\tmax_gap = std::max(max_gap, high - low);\\r\\n\\t\\tgaps[i - 1] = max_gap;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfor (int i = 0; i < gaps.size() - 1; i++) {\\r\\n\\t\\tcout << gaps[i] << ' ';\\r\\n\\t}\\r\\n\\tcout << gaps.back() << endl;\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1163","source":"CSES","title":"Traffic Lights","author":"Danh Ta Chi Thanh, Ben Dodge, Kevin Sheng"},"parent":{"name":"cses-1163","relativePath":"cses-1163.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2 - Going Backwards","slug":"solution-2---going-backwards"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2 - Going Backwards","slug":"solution-2---going-backwards"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2 - Going Backwards","slug":"solution-2---going-backwards"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"intro-sorted-sets","title":"More Operations on Sorted Sets"}}}}]},"problemInfo":{"uniqueId":"cses-1163","url":"https://cses.fi/problemset/task/1163"}},"pageContext":{"id":"cses-1163"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}