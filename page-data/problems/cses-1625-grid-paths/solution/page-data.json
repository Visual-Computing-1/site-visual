{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1625-grid-paths/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1625\", source = \"CSES\", title = \"Grid Paths\", author = \"Vivian Han\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    em: \"em\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Warning: _missingComponent(\"Warning\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    Info: _missingComponent(\"Info\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, Warning, MATHSPAN, Info, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"explanation\",\n      children: [_jsx(_components.a, {\n        href: \"#explanation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Explanation\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Adapted from /CPH.pdf#page=61\"\n    }), \"\\n\", _jsx(Warning, {\n      title: \"Run times\",\n      children: _jsxs(_components.p, {\n        children: [\"Please note: the running times and number of recursive calls listed are for a\\r\\nseparate but very similar problem (# paths from upper left to \", _jsx(_components.em, {\n          children: \"lower right\"\n        }), \"\\r\\ncorner on a 7x7 grid). They may not be entirely accurate, but they illustrate\\r\\nthe effect of each optimization. The data is also C++ specific, so Java and\\r\\nPython users will experience significantly different runtimes. The consequences\\r\\nof this discrepancy which will be addressed later in the explanation.\"]\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"basic-algorithm\",\n      children: [_jsx(_components.a, {\n        href: \"#basic-algorithm\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Basic Algorithm\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first version of the algorithm does not contain any optimizations. We simply\\r\\nuse backtracking to generate all possible paths from the upper-left corner to\\r\\nthe lower-right corner and count the number of such paths.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Running time: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"483\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>483</mn></mrow><annotation encoding=\\\"application/x-tex\\\">483</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">483</span></span></span></span>\"\n        }), \" seconds\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Number of recursive calls: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"76\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>76</mn></mrow><annotation encoding=\\\"application/x-tex\\\">76</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">76</span></span></span></span>\"\n        }), \" billion\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"optimization-1\",\n      children: [_jsx(_components.a, {\n        href: \"#optimization-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Optimization 1\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If the path reaches the lower-right square before it has visited all other\\r\\nsquares of the grid, it is clear that it will not be possible to complete the\\r\\nsolution. Using this observation, we can terminate the search immediately if we\\r\\nreach the lower-right square too early.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Running time: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"119\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>119</mn></mrow><annotation encoding=\\\"application/x-tex\\\">119</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">119</span></span></span></span>\"\n        }), \" seconds\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Number of recursive calls: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"20\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>20</mn></mrow><annotation encoding=\\\"application/x-tex\\\">20</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">20</span></span></span></span>\"\n        }), \" billion\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"optimization-2\",\n      children: [_jsx(_components.a, {\n        href: \"#optimization-2\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Optimization 2\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If the path touches a wall and can turn either left or right, the grid splits\\r\\ninto two parts that contain unvisited squares. In this case, we cannot visit all\\r\\nsquares anymore, so we can terminate the search.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Running time: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"1.8\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1.8</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1.8</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1.8</span></span></span></span>\"\n        }), \" seconds\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Number of recursive calls: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"221\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>221</mn></mrow><annotation encoding=\\\"application/x-tex\\\">221</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">221</span></span></span></span>\"\n        }), \" million\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"optimization-3\",\n      children: [_jsx(_components.a, {\n        href: \"#optimization-3\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Optimization 3\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The idea of Optimization 2 can be generalized: if the path cannot continue\\r\\nforward but can turn either left or right, the grid splits into two parts that\\r\\nboth contain unvisited squares. It is clear that we cannot visit all squares\\r\\nanymore, so we can terminate the search.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Running time: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"0.6\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0.6</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0.6</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0.6</span></span></span></span>\"\n        }), \" seconds\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Number of recursive calls: \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"69\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>69</mn></mrow><annotation encoding=\\\"application/x-tex\\\">69</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">69</span></span></span></span>\"\n        }), \" million\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now is a good moment to stop optimizing the algorithm and see what we have\\r\\nachieved. The running time of the original algorithm was \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"483\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>483</mn></mrow><annotation encoding=\\\"application/x-tex\\\">483</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">483</span></span></span></span>\"\n      }), \" seconds, and now\\r\\nafter the optimizations, the running time is only \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0.6\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0.6</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0.6</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0.6</span></span></span></span>\"\n      }), \" seconds. Thus, the\\r\\nalgorithm became nearly \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"1000\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1000</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1000</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1000</span></span></span></span>\"\n      }), \" times faster after the optimizations.\"]\n    }), \"\\n\", _jsx(Info, {\n      children: _jsx(_components.p, {\n        children: \"In backtracking, the search tree is usually\\r\\nlarge and even simple observations can effectively prune the search. Especially\\r\\nuseful are optimizations that occur during the first steps of the algorithm,\\r\\ni.e., at the top of the search tree.\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For C++ users, this will be enough pruning to make the program run in time under\\r\\nworst case conditions. However, for Java and Python users, this is still too\\r\\nslow (Java takes around \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"1.2\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1.2</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1.2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1.2</span></span></span></span>\"\n      }), \" seconds for the worst case). Thus, we will need to\\r\\nfurther optimize our search.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"optimization-4\",\n      children: [_jsx(_components.a, {\n        href: \"#optimization-4\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Optimization 4\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If the path creates a dead end that is not the bottom left corner, either the\\r\\npath will fail to visit all squares (the path may stop at the dead end or pass\\r\\nover it, sealing a square off) or the path will end in the wrong location. Thus,\\r\\nwe want to avoid creating dead ends. For example, if the square to the left of\\r\\nour current location is blocked on three sides (including our current location),\\r\\nthen the next step must be to the left in order to avoid creating a dead end.\\r\\nAfter this optimization, the program runs in under \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" second.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\nusing namespace std;\\r\\n\\r\\nconst int DIR_LEN = 4;\\r\\nint dr[DIR_LEN] = {-1, 0, 1, 0};\\r\\nint dc[DIR_LEN] = {0, 1, 0, -1};\\r\\nconst int PATH_LEN = 48;  // length of all possible paths\\r\\nint p[PATH_LEN];\\r\\nconst int GRID_SIZE = 9;  \\r\\n// added border to all four sides so a 7x7 becomes a 9x9\\r\\nbool onPath[GRID_SIZE][GRID_SIZE];\\r\\n\\r\\nint tryPath(int pathIdx, int curR, int curC) {\\r\\n\\t// Optimization 3\\r\\n\\tif ((onPath[curR][curC - 1] && onPath[curR][curC + 1])\\r\\n\\t\\t&& (!onPath[curR - 1][curC] && !onPath[curR + 1][curC])) return 0;\\r\\n\\tif ((onPath[curR - 1][curC] && onPath[curR + 1][curC])\\r\\n\\t\\t&& (!onPath[curR][curC - 1] && !onPath[curR][curC + 1])) return 0;\\r\\n\\r\\n\\tif (curR == 7 && curC == 1) {  // reached endpoint before visiting all\\r\\n\\t\\tif (pathIdx == PATH_LEN) return 1;\\r\\n\\t\\treturn 0;\\r\\n\\t}\\r\\n\\r\\n\\tif (pathIdx == PATH_LEN) return 0;\\r\\n\\r\\n\\tint ret = 0;\\r\\n\\tonPath[curR][curC] = true;\\r\\n\\r\\n\\t// turn already determined:\\r\\n\\tif (p[pathIdx] < 4) {\\r\\n\\t\\tint nxtR = curR + dr[p[pathIdx]];\\r\\n\\t\\tint nxtC = curC + dc[p[pathIdx]];\\r\\n\\t\\tif (!onPath[nxtR][nxtC]) ret += tryPath(pathIdx + 1, nxtR, nxtC);\\r\\n\\t} \\r\\n\\t// see Java solution for optimization 4 implementation\\r\\n\\telse {  // iterate through all four possible turns\\r\\n\\t\\tfor (int i = 0; i < DIR_LEN; i++) {\\r\\n\\t\\t\\tint nxtR = curR + dr[i];\\r\\n\\t\\t\\tint nxtC = curC + dc[i];\\r\\n\\t\\t\\tif (onPath[nxtR][nxtC]) continue;\\r\\n\\t\\t\\tret += tryPath(pathIdx + 1, nxtR, nxtC);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// reset and return\\r\\n\\tonPath[curR][curC] = false;\\r\\n\\treturn ret;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tstring line;\\r\\n\\tgetline(cin, line);\\r\\n\\r\\n\\t// convert path to ints\\r\\n\\tfor (int i = 0; i < PATH_LEN; i++) {\\r\\n\\t\\tchar cur = line[i];\\r\\n\\r\\n\\t\\tif (cur == 'U') p[i] = 0;\\r\\n\\t\\telse if (cur == 'R') p[i] = 1;\\r\\n\\t\\telse if (cur == 'D') p[i] = 2;\\r\\n\\t\\telse if (cur == 'L') p[i] = 3;\\r\\n\\t\\telse p[i] = 4; //cur == '?'\\r\\n\\t}\\r\\n\\r\\n\\t// set borders of grid\\r\\n\\tfor (int i = 0; i < GRID_SIZE; i++) {\\r\\n\\t\\tonPath[0][i] = true;\\r\\n\\t\\tonPath[8][i] = true;\\r\\n\\t\\tonPath[i][0] = true;\\r\\n\\t\\tonPath[i][8] = true;\\r\\n\\t}\\r\\n\\t// initialize the inside of the grid to be completely empty\\r\\n\\tfor (int i = 1; i <= 7; i++) {\\r\\n\\t\\tfor (int j = 1; j <= 7; j++) {\\r\\n\\t\\t\\tonPath[i][j] = false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tint startIdx = 0;\\r\\n\\tint startR = 1;\\r\\n\\tint startC = 1;  // always start path at (1, 1)\\r\\n\\tint ans = tryPath(startIdx, startR, startC);\\r\\n\\tcout << ans << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.Scanner;\\r\\n\\r\\npublic class GridPaths {\\r\\n\\r\\n\\tstatic boolean[][] onPath = new boolean[9][9];  \\r\\n\\t// added border to all four sides so a 7x7 becomes a 9x9\\r\\n\\tstatic int[] dr = {-1, 0, 1, 0};  // transitions to up, right, down, left\\r\\n\\tstatic int[] dc = {0, 1, 0, -1};  // for row and column, respectively\\r\\n\\tstatic int[] p = new int[48];  // all possible paths have length 48\\r\\n\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tScanner in = new Scanner(System.in);\\r\\n\\t\\tString line = in.nextLine();\\r\\n\\r\\n\\t\\t// convert path to ints\\r\\n\\t\\tfor (int i = 0; i < p.length; i++) {\\r\\n\\t\\t\\tchar cur = line.charAt(i);\\r\\n\\r\\n\\t\\t\\tif (cur == 'U') p[i] = 0;\\r\\n\\t\\t\\telse if (cur == 'R') p[i] = 1;\\r\\n\\t\\t\\telse if (cur == 'D') p[i] = 2;\\r\\n\\t\\t\\telse if (cur == 'L') p[i] = 3;\\r\\n\\t\\t\\telse p[i] = 4; //cur == '?'\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// set borders of grid\\r\\n\\t\\tfor (int i = 0; i < 9; i++) {\\r\\n\\t\\t\\tonPath[0][i] = true;\\r\\n\\t\\t\\tonPath[8][i] = true;\\r\\n\\t\\t\\tonPath[i][0] = true;\\r\\n\\t\\t\\tonPath[i][8] = true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint ans = tryPath(0, 1, 1);\\r\\n\\t\\tSystem.out.println(ans);\\r\\n\\t}\\r\\n\\r\\n\\tpublic static int tryPath(int pathIdx, int curR, int curC) {\\r\\n\\t\\t// Optimization 3\\r\\n\\t\\tif ((onPath[curR][curC - 1] && onPath[curR][curC + 1])\\r\\n\\t\\t\\t&& (!onPath[curR - 1][curC] && !onPath[curR+1][curC])) return 0;\\r\\n\\t\\tif ((onPath[curR - 1][curC] && onPath[curR + 1][curC])\\r\\n\\t\\t\\t&& (!onPath[curR][curC - 1] && !onPath[curR][curC + 1])) return 0;\\r\\n\\r\\n\\t\\t// Optimization 1\\r\\n\\t\\tif (curR == 7 && curC == 1) {  // reached endpoint\\r\\n\\t\\t\\tif (pathIdx == p.length) return 1;  // visited every cell -> valid!\\r\\n\\t\\t\\treturn 0;  // didn't visit every cell (path length is too short)\\r\\n\\t\\t}  \\r\\n\\t\\t// visited all cells, but didn't end up in the correct locaiton\\r\\n\\t\\tif (pathIdx == p.length) return 0;\\r\\n\\r\\n\\t\\tint ret = 0;  // cumulative count for this \\\"starting position\\\"\\r\\n\\t\\tonPath[curR][curC] = true;\\r\\n\\r\\n\\t\\t// turn already determined, try going in that direction\\r\\n\\t\\tif (p[pathIdx] < 4) {\\r\\n\\t\\t\\tint nxtR = curR + dr[p[pathIdx]];\\r\\n\\t\\t\\tint nxtC = curC + dc[p[pathIdx]];\\r\\n\\t\\t\\tif (!onPath[nxtR][nxtC]) {\\r\\n\\t\\t\\t\\tret += tryPath(pathIdx + 1, nxtR, nxtC);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t// now search for dead ends (Optimization 4)\\r\\n\\t\\telse if ((curC > 2) && onPath[curR][curC - 2]\\r\\n\\t\\t\\t&& (onPath[curR - 1][curC - 1] || onPath[curR + 1][curC - 1])\\r\\n\\t\\t\\t&& (!onPath[curR][curC - 1])) { \\r\\n\\t\\t\\t// potential dead end on the left:\\r\\n\\t\\t\\tint nxtR = curR;\\r\\n\\t\\t\\tint nxtC = curC - 1;\\r\\n\\t\\t\\tret += tryPath(pathIdx + 1, nxtR, nxtC);\\r\\n\\t\\t}\\r\\n\\t\\telse if ((curC < 6) && onPath[curR][curC + 2]\\r\\n\\t\\t\\t&& (onPath[curR - 1][curC + 1] || onPath[curR + 1][curC + 1] )\\r\\n\\t\\t\\t&& (!onPath[curR][curC + 1])) {  \\r\\n\\t\\t\\t// potential dead end on the right:\\r\\n\\t\\t\\tint nxtR = curR;\\r\\n\\t\\t\\tint nxtC = curC + 1;\\r\\n\\t\\t\\tret += tryPath(pathIdx + 1, nxtR, nxtC);\\r\\n\\t\\t}\\r\\n\\t\\telse if ((curR > 2) && onPath[curR - 2][curC] \\r\\n\\t\\t\\t&& onPath[curR - 1][curC - 1] && (!onPath[curR - 1][curC])) {  \\r\\n\\t\\t\\t// potential dead end upwards\\r\\n\\t\\t\\t// note: I didn't include all possible scenarios because\\r\\n\\t\\t\\t// it wasn't necessary in order for the program to run in time\\r\\n\\t\\t\\tint nxtR = curR - 1;\\r\\n\\t\\t\\tint nxtC = curC;\\r\\n\\t\\t\\tret += tryPath(pathIdx + 1, nxtR, nxtC);\\r\\n\\t\\t}\\r\\n\\t\\t// iterate through all four possible turns\\r\\n\\t\\telse { \\r\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\t\\tint nxtR = curR + dr[i];\\r\\n\\t\\t\\t\\tint nxtC = curC + dc[i];\\r\\n\\t\\t\\t\\tif (onPath[nxtR][nxtC]) continue;\\r\\n\\t\\t\\t\\tret += tryPath(pathIdx + 1, nxtR, nxtC);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n    \\r\\n\\t\\t// reset and return\\r\\n\\t\\tonPath[curR][curC] = false;\\r\\n\\t\\treturn ret;\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1625","source":"CSES","title":"Grid Paths","author":"Vivian Han"},"parent":{"name":"cses-1625","relativePath":"cses-1625.mdx"},"toc":{"cpp":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":3,"value":"Basic Algorithm","slug":"basic-algorithm"},{"depth":3,"value":"Optimization 1","slug":"optimization-1"},{"depth":3,"value":"Optimization 2","slug":"optimization-2"},{"depth":3,"value":"Optimization 3","slug":"optimization-3"},{"depth":3,"value":"Optimization 4","slug":"optimization-4"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":3,"value":"Basic Algorithm","slug":"basic-algorithm"},{"depth":3,"value":"Optimization 1","slug":"optimization-1"},{"depth":3,"value":"Optimization 2","slug":"optimization-2"},{"depth":3,"value":"Optimization 3","slug":"optimization-3"},{"depth":3,"value":"Optimization 4","slug":"optimization-4"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":3,"value":"Basic Algorithm","slug":"basic-algorithm"},{"depth":3,"value":"Optimization 1","slug":"optimization-1"},{"depth":3,"value":"Optimization 2","slug":"optimization-2"},{"depth":3,"value":"Optimization 3","slug":"optimization-3"},{"depth":3,"value":"Optimization 4","slug":"optimization-4"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"complete-rec","title":"Complete Search with Recursion"}}}}]},"problemInfo":{"uniqueId":"cses-1625","url":"https://cses.fi/problemset/task/1625"}},"pageContext":{"id":"cses-1625"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}