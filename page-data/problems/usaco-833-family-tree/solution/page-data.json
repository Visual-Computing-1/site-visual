{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-833-family-tree/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-833\", source = \"USACO Bronze 2018 Open\", title = \"Family Tree\", author = \"Danh Ta Chi Thanh, Ryan Chou, Chuyang Wang\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    Warning: _missingComponent(\"Warning\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, PySection, JavaSection, CPPSection, Warning, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"solution\",\n      children: [_jsx(_components.a, {\n        href: \"#solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_family_bronze_open18.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"By finding the closest common ancestor and the distances from the ancestor to the two cows, we can uniquely identify their relationship.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^3)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^3)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">3</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\n\\r\\nsys.stdin = open('family.in', 'r')\\r\\nsys.stdout = open('family.out', 'w')\\r\\n\\r\\nrel_num, cow_a, cow_b = input().split()\\r\\nrelations = []\\r\\n\\r\\nfor i in range(int(rel_num)):     \\r\\n\\trelations.append(input().split())\\r\\n\\r\\n\\r\\n# gets the mother of the cow (if it exists)\\r\\ndef mother(cow):\\r\\n\\tfor r in relations:\\r\\n\\t\\tif r[1] == cow:\\r\\n\\t\\t\\treturn r[0]\\r\\n\\treturn None\\r\\n\\r\\n# returns the distance between cow and cow2 (-1 if no relation)\\r\\ndef direct_anc_dist(cow, cow2):\\r\\n\\tdist = 0\\r\\n\\twhile cow2 != None:\\r\\n\\t\\tif cow == cow2:\\r\\n\\t\\t\\treturn dist\\r\\n\\t\\tcow2 = mother(cow2)\\r\\n\\t\\tdist += 1\\r\\n\\treturn -1\\r\\n\\r\\n\\r\\n# distance from a to the common ancestor\\r\\nda = 0\\r\\ncow = cow_a\\r\\nwhile cow != None:\\r\\n\\t# if we found a common ancestor\\r\\n\\tif direct_anc_dist(cow, cow_b) != -1:\\r\\n\\t\\tbreak\\r\\n\\tcow = mother(cow)\\r\\n\\tda += 1\\r\\n\\r\\n# if a common ancestor does not exist\\r\\nif cow == None:\\r\\n\\tprint('NOT RELATED')\\r\\n\\tsys.exit()\\r\\n\\r\\n\\\"\\\"\\\"\\r\\nsince we found a common ancestor, cow.\\r\\nwe can call direct_anc() to get the distance\\r\\nfrom b to the common ancestor.\\r\\n\\\"\\\"\\\"\\r\\ndb = direct_anc_dist(cow, cow_b)\\r\\n\\t\\r\\n\\\"\\\"\\\"\\r\\nif they're related by a common ancestor, \\r\\nbut not by a mother or aunt, we can return\\r\\nCOUSINS.\\r\\n\\\"\\\"\\\"\\r\\nif da > 1 and db > 1:\\r\\n\\tprint('COUSINS')\\r\\n\\tsys.exit()\\r\\n\\r\\n# if the distance from each cow to their common \\r\\n# ancestor is one, they're siblings,\\r\\nelif da == 1 and db == 1:\\r\\n\\tprint('SIBLINGS')\\r\\n\\tsys.exit()\\r\\nelse:\\r\\n\\tif da > db:\\r\\n\\t\\tda, db = db, da\\r\\n\\t\\tcow_b, cow_a = cow_a, cow_b\\r\\n\\tprint(cow_a, 'is the ', end='')\\r\\n\\r\\n\\t# we subtract two because 1 is in place of mother\\r\\n\\t# and 2 is in place of grandmother\\r\\n\\tfor _ in range(db - 2):\\r\\n\\t\\tprint(\\\"great-\\\", end='')\\r\\n\\tif da == 0 and db > 1:\\r\\n\\t\\tprint('grand-', end='')\\r\\n\\tif da == 0:\\r\\n\\t\\tprint('mother ', end='')\\r\\n\\telse:\\r\\n\\t\\tprint('aunt ', end='')\\r\\n\\tprint('of', cow_b)\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class FamilyTree {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader in = new BufferedReader(new FileReader(\\\"family.in\\\"));\\r\\n\\t\\tPrintWriter out = new PrintWriter(\\\"family.out\\\");\\r\\n\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(in.readLine());\\r\\n\\t\\tint relNum = Integer.parseInt(st.nextToken());\\r\\n\\t\\tString cowX = st.nextToken();\\r\\n\\t\\tString cowY = st.nextToken();\\r\\n\\t\\tString[][] relations = new String[relNum][];\\r\\n\\t\\tfor (int i = 0; i < relNum; i++) {\\r\\n\\t\\t\\trelations[i] = in.readLine().split(\\\" \\\");\\r\\n\\t\\t}\\r\\n\\t\\tin.close();\\r\\n\\r\\n\\t\\t// minimum distance between the shared ancestor and X and Y\\r\\n\\t\\tint minXDist = 0;\\r\\n\\t\\tint minYDist = 0;\\r\\n\\t\\tString commonAncestor = cowX;\\r\\n\\t\\t// try to find the common ancestor of X and Y (or if there isn't one)\\r\\n\\t\\twhile (commonAncestor != null) {\\r\\n\\t\\t\\tif (getAncestorDistance(commonAncestor, cowY, relations) != -1) {\\r\\n\\t\\t\\t\\tminYDist = getAncestorDistance(commonAncestor, cowY, relations);\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tcommonAncestor = getMother(commonAncestor, relations);\\r\\n\\t\\t\\tminXDist++;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if X and Y don't have common ancestors, they aren't related\\r\\n\\t\\tif (commonAncestor == null) {\\r\\n\\t\\t\\tout.println(\\\"NOT RELATED\\\");\\r\\n\\t\\t}\\r\\n\\t\\t// if both distances are greater than one they're cousins\\r\\n\\t\\telse if (minXDist > 1 && minYDist > 1) {\\r\\n\\t\\t\\tout.println(\\\"COUSINS\\\");\\r\\n\\t\\t}\\r\\n\\t\\t// both distances of 1 means they're siblings\\r\\n\\t\\telse if (minXDist == 1 && minYDist == 1) {\\r\\n\\t\\t\\tout.println(\\\"SIBLINGS\\\");\\r\\n\\t\\t}\\r\\n\\t\\t// if one itself is the ancestor then it's a (great-...) mother relationship\\r\\n\\t\\telse if (minXDist == 0 || minYDist == 0) {\\r\\n\\t\\t\\tboolean xIsAncestor = minXDist == 0;\\r\\n\\t\\t\\tout.print(String.format(\\\"%s is the \\\", commonAncestor));\\r\\n\\t\\t\\tfor (int i = 0; i < (xIsAncestor ? minYDist : minXDist) - 2; i++) {\\r\\n\\t\\t\\t\\tout.print(\\\"great-\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif ((xIsAncestor ? minYDist : minXDist) > 1) {\\r\\n\\t\\t\\t\\tout.print(\\\"grand-\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tout.println(String.format(\\\"mother of %s\\\", xIsAncestor ? cowY : cowX));\\r\\n\\t\\t}\\r\\n\\t\\t// otherwise, there's a (great-great-...) aunt relationship\\r\\n\\t\\telse {\\r\\n\\t\\t\\tboolean auntIsX = minXDist == 1;\\r\\n\\t\\t\\tout.print(String.format(\\\"%s is the \\\", auntIsX ? cowX : cowY));\\r\\n\\t\\t\\tfor (int i = 0; i < (auntIsX ? minYDist : minXDist) - 2; i++) {\\r\\n\\t\\t\\t\\tout.print(\\\"great-\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tout.println(String.format(\\\"aunt of %s\\\", auntIsX ? cowY : cowX));\\r\\n\\t\\t}\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\r\\n\\t// finds the mother of given child among those pairs (returns null if no mother)\\r\\n\\tprivate static String getMother(String child, String[][] relations) {\\r\\n\\t\\tfor (String[] pair : relations) {\\r\\n\\t\\t\\tif (child.equals(pair[1])) {\\r\\n\\t\\t\\t\\treturn pair[0];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn null;\\r\\n\\t}\\r\\n\\r\\n\\t// returns the distance between start and end (-1 if no relation)\\r\\n\\tprivate static int getAncestorDistance(\\r\\n\\t\\tString start,\\r\\n\\t\\tString end, \\r\\n\\t\\tString[][] relations\\r\\n\\t) {\\r\\n\\t\\tint dist = 0;\\r\\n\\t\\twhile (end != null) {\\r\\n\\t\\t\\tif (end.equals(start)) {\\r\\n\\t\\t\\t\\treturn dist;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdist++;\\r\\n\\t\\t\\tend = getMother(end, relations);\\r\\n\\t\\t}\\r\\n\\t\\treturn -1;\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <fstream>\\r\\n#include <string>\\r\\n#include <vector>\\r\\n\\r\\nusing std::vector;\\r\\nusing std::string;\\r\\nusing Relation = std::pair<string, string>;\\r\\n\\r\\n// finds the mother of given child among those pairs (returns null if no mother)\\r\\nstring mother(const string& child, const vector<Relation>& relations) {\\r\\n\\tfor (const Relation& r : relations) {\\r\\n\\t\\tif (r.second == child) {\\r\\n\\t\\t\\treturn r.first;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn \\\"\\\";\\r\\n}\\r\\n\\r\\n// returns the distance between start and end (-1 if no relation)\\r\\nint ancestor_dist(\\r\\n\\tconst string& start,\\r\\n\\tstring end,  // we're going to reassign this variable so no reference\\r\\n\\tconst vector<Relation>& relations) {\\r\\n\\tint dist = 0;\\r\\n\\twhile (end != \\\"\\\") {\\r\\n\\t\\tif (end == start) {\\r\\n\\t\\t\\treturn dist;\\r\\n\\t\\t}\\r\\n\\t\\tdist++;\\r\\n\\t\\tend = mother(end, relations);\\r\\n\\t}\\r\\n\\treturn -1;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tstd::ifstream read(\\\"family.in\\\");\\r\\n\\tint rel_num;\\r\\n\\tstring cow_x;\\r\\n\\tstring cow_y;\\r\\n\\tread >> rel_num >> cow_x >> cow_y;\\r\\n\\tvector<Relation> relations(rel_num);\\r\\n\\tfor (int r = 0; r < rel_num; r++) {\\r\\n\\t\\tread >> relations[r].first >> relations[r].second;\\r\\n\\t}\\r\\n\\r\\n\\t// minimum distance between the shared ancestor and X and Y\\r\\n\\tint min_x_dist = 0;\\r\\n\\tint min_y_dist = 0;\\r\\n\\tstring common_ancestor = cow_x;\\r\\n\\t// try to find the common ancestor of X and Y (or if there isn't one)\\r\\n\\twhile (!common_ancestor.empty()) {\\r\\n\\t\\tif (ancestor_dist(common_ancestor, cow_y, relations) != -1) {\\r\\n\\t\\t\\tmin_y_dist = ancestor_dist(common_ancestor, cow_y, relations);\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\t\\tcommon_ancestor = mother(common_ancestor, relations);\\r\\n\\t\\tmin_x_dist++;\\r\\n\\t\\t// written << common_ancestor << '\\\\n';\\r\\n\\t}\\r\\n\\r\\n\\tstd::ofstream written(\\\"family.out\\\");\\r\\n\\t// if X and Y don't have common ancestors, they aren't related\\r\\n\\tif (common_ancestor.empty()) {\\r\\n\\t\\twritten << \\\"NOT RELATED\\\\n\\\";\\r\\n\\t}\\r\\n\\t// if both distances are greater than one they're cousins\\r\\n\\telse if (min_x_dist > 1 && min_y_dist > 1) {\\r\\n\\t\\twritten << \\\"COUSINS\\\\n\\\";\\r\\n\\t}\\r\\n\\t// both distances of 1 means they're siblings\\r\\n\\telse if (min_x_dist == 1 && min_y_dist == 1) {\\r\\n\\t\\twritten << \\\"SIBLINGS\\\\n\\\";\\r\\n\\t}\\r\\n\\t// if one itself is the ancestor then it's a (great-...) mother relationship\\r\\n\\telse if (min_x_dist == 0 || min_y_dist == 0) {\\r\\n\\t\\tbool x_is_ancestor = min_x_dist == 0;\\r\\n\\t\\tint ancestor_dist = x_is_ancestor ? min_y_dist : min_x_dist;\\r\\n\\t\\twritten << (x_is_ancestor ? cow_x : cow_y) << \\\" is the \\\";\\r\\n\\t\\tfor (int i = 0; i < ancestor_dist - 2; i++) {\\r\\n\\t\\t\\twritten << \\\"great-\\\";\\r\\n\\t\\t}\\r\\n\\t\\tif (ancestor_dist > 1) {\\r\\n\\t\\t\\twritten << \\\"grand-\\\";\\r\\n\\t\\t}\\r\\n\\t\\twritten << \\\"mother of \\\" << (x_is_ancestor ? cow_y : cow_x) << '\\\\n';\\r\\n\\t}\\r\\n\\t// otherwise, there's a (great-great-...) aunt relationship\\r\\n\\telse {\\r\\n\\t\\tbool x_is_aunt = min_x_dist == 1;\\r\\n\\t\\twritten << (x_is_aunt ? cow_x : cow_y) << \\\" is the \\\";\\r\\n\\t\\tfor (int i = 0; i < (x_is_aunt ? min_y_dist : min_x_dist) - 2; i++) {\\r\\n\\t\\t\\twritten << \\\"great-\\\";\\r\\n\\t\\t}\\r\\n\\t\\twritten << \\\"aunt of \\\" << (x_is_aunt ? cow_y : cow_x) << '\\\\n';\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"alternative-solution---bfs\",\n      children: [_jsx(_components.a, {\n        href: \"#alternative-solution---bfs\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Alternative Solution - BFS\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note: This is an \", _jsx(_components.strong, {\n        children: \"alternative\"\n      }), \" solution and makes use of concepts outside the\\r\\nscope of Bronze. Breadth-first search is \", _jsx(_components.strong, {\n        children: \"not necessary\"\n      }), \" to know for the\\r\\nbronze division.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N \\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mi>log</mi><mo>‚Å°</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N \\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This problem can also be solved by using BFS to find the common ancestors and\\r\\nthe distance between the two cows and their nearest common ancestor.\"\n    }), \"\\n\", _jsx(Warning, {\n      children: _jsx(_components.p, {\n        children: \"No Bronze / Silver problem has required knowledge of BFS, so feel free to skip\\r\\nthis solution if you find it unfamiliar and come back later.\"\n      })\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class FamilyTree {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader in = new BufferedReader(new FileReader(\\\"family.in\\\"));\\r\\n\\t\\tPrintWriter out = new PrintWriter(\\\"family.out\\\");\\r\\n\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(in.readLine());\\r\\n\\t\\tint N = Integer.parseInt(st.nextToken());\\r\\n\\t\\tString X = st.nextToken(), Y = st.nextToken();\\r\\n\\t\\tMap<String, String> adjacencyList = new HashMap<String, String>();\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tst = new StringTokenizer(in.readLine());\\r\\n\\t\\t\\tString mother = st.nextToken(), child = st.nextToken();\\r\\n\\t\\t\\t// store the mother-child relationship as a directed graph\\r\\n\\t\\t\\t// in an adjacency list, where the arrow points to the mother\\r\\n\\t\\t\\t// e.g.: child -> mother -> grandmother\\r\\n\\t\\t\\t// note that the outdegree of each node is maximal 1 in this question\\r\\n\\t\\t\\tadjacencyList.put(child, mother);\\r\\n\\t\\t}\\r\\n\\t\\tin.close();\\r\\n\\r\\n\\t\\t// distance from node X and node Y to other nodes\\r\\n\\t\\t// e.g.: xDistance.get(node) = the distance between node and x\\r\\n\\t\\tMap<String, Integer> xDistance = new HashMap<String, Integer>(), \\r\\n\\t\\t\\tyDistance = new HashMap<String, Integer>();\\r\\n\\t\\txDistance.put(X, 0);\\r\\n\\t\\tyDistance.put(Y, 0);\\r\\n\\r\\n\\t\\t// calculate the distances between X and its ancestors\\r\\n\\t\\tString current = X;\\r\\n\\t\\twhile (adjacencyList.containsKey(current)) {\\r\\n\\t\\t\\tString mother = adjacencyList.get(current);\\r\\n\\t\\t\\txDistance.put(mother, xDistance.get(current) + 1);\\r\\n\\t\\t\\tcurrent = mother;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// cf. above, this time for Y\\r\\n\\t\\tcurrent = Y;\\r\\n\\t\\twhile (adjacencyList.containsKey(current)) {\\r\\n\\t\\t\\tString mother = adjacencyList.get(current);\\r\\n\\t\\t\\tyDistance.put(mother, yDistance.get(current) + 1);\\r\\n\\t\\t\\tcurrent = mother;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// minimum distance between shared ancestors of X and Y\\r\\n\\t\\tint minXDist = Integer.MAX_VALUE, minYDist = Integer.MAX_VALUE;\\r\\n\\t\\tString ancestor = null;\\r\\n\\t\\t// iterate through the ancestors of X\\r\\n\\t\\t// and test if Y also has this node as ancestor\\r\\n\\t\\tfor (var pair : xDistance.entrySet()) {\\r\\n\\t\\t\\tif (yDistance.containsKey(pair.getKey())\\r\\n\\t\\t\\t\\t\\t// we update the minimum distance if there is an ancestor\\r\\n\\t\\t\\t\\t\\t// with less distance to X or Y than current minimum\\r\\n\\t\\t\\t\\t\\t&& (minXDist > pair.getValue() || minYDist > yDistance.get(pair.getKey()))) {\\r\\n\\t\\t\\t\\tancestor = pair.getKey();\\r\\n\\t\\t\\t\\tminXDist = pair.getValue();\\r\\n\\t\\t\\t\\tminYDist = yDistance.get(pair.getKey());\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if there's no shared ancestor, then X and Y are not related\\r\\n\\t\\tif (ancestor == null)\\r\\n\\t\\t\\tout.println(\\\"NOT RELATED\\\");\\r\\n\\t\\t// if X or Y itself is the ancestor, then it's a mother-child relationship\\r\\n\\t\\telse if (ancestor.equals(X) || ancestor.equals(Y)) { \\r\\n\\t\\t\\tout.print(String.format(\\\"%s is the \\\", ancestor));\\r\\n\\t\\t\\tfor (int i = 0; i < (ancestor.equals(X) ? minYDist : minXDist) - 2; i++)\\r\\n\\t\\t\\t\\tout.print(\\\"great-\\\");\\r\\n\\t\\t\\tif ((ancestor.equals(X) ? minYDist : minXDist) > 1)\\r\\n\\t\\t\\t\\tout.print(\\\"grand-\\\");\\r\\n\\t\\t\\tout.println(String.format(\\\"mother of %s\\\", ancestor.equals(X) ? Y : X));\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (minXDist == 1 || minYDist == 1) {\\r\\n\\t\\t\\t\\t// if X and Y both have a distance 1 to their ancestor,\\r\\n\\t\\t\\t\\t// then the ancestor is their mother, so they are siblings\\r\\n\\t\\t\\t\\tif (minXDist == 1 && minYDist == 1)\\r\\n\\t\\t\\t\\t\\tout.println(\\\"SIBLINGS\\\");\\r\\n\\t\\t\\t\\t// if the distance between the ancestor and X or Y is only 1,\\r\\n\\t\\t\\t\\t// then it's an aunt relationship\\r\\n\\t\\t\\t\\telse {\\r\\n\\t\\t\\t\\t\\tboolean auntIsX = minXDist == 1;\\r\\n\\t\\t\\t\\t\\tout.print(String.format(\\\"%s is the \\\", auntIsX ? X : Y));\\r\\n\\t\\t\\t\\t\\tfor (int i = 0; i < (auntIsX ? minYDist : minXDist) - 2; i++)\\r\\n\\t\\t\\t\\t\\t\\tout.print(\\\"great-\\\");\\r\\n\\t\\t\\t\\t\\tout.println(String.format(\\\"aunt of %s\\\", auntIsX ? Y : X));\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t// otherwise, they are cousins as defined in the question\\r\\n\\t\\t\\t} else\\r\\n\\t\\t\\t\\tout.println(\\\"COUSINS\\\");\\r\\n\\t\\t}\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"//BeginCodeSnip{C++ Short Template}\\n#include <bits/stdc++.h> // see /general/running-code-locally\\nusing namespace std;\\n\\nusing ll = long long;\\n\\nusing vi = vector<int>;\\n#define pb push_back\\n#define all(x) begin(x), end(x)\\n#define sz(x) (int) (x).size()\\n\\nusing pi = pair<int,int>;\\n#define f first\\n#define s second\\n#define mp make_pair\\n\\nvoid setIO(string name = \\\"\\\") {\\n\\tcin.tie(0)->sync_with_stdio(0); // see /general/fast-io\\n\\tif (sz(name)) {\\n\\t\\tfreopen((name + \\\".in\\\").c_str(), \\\"r\\\", stdin); // see /general/input-output\\n\\t\\tfreopen((name + \\\".out\\\").c_str(), \\\"w\\\", stdout);\\n\\t}\\n}\\n//EndCodeSnip\\n\\r\\nint main() {\\r\\n\\tsetIO(\\\"family\\\");\\r\\n\\tint N;\\r\\n\\tstring c[3];\\r\\n\\tcin >> N >> c[1] >> c[2];\\r\\n\\tmap<string,int> dist[3];\\r\\n\\tdist[1][c[1]] = 0;\\r\\n\\tdist[2][c[2]] = 0;\\r\\n\\r\\n\\tmap<string,string> edge; //edge list\\r\\n\\r\\n\\tfor (int i = 0; i < N; ++i) {\\r\\n\\t\\tstring u, v;\\r\\n\\t\\tcin >> v >> u;\\r\\n\\t\\t// If v is a mother of u, then there is an edge from node u to node v.\\r\\n\\t\\tedge[u] = v;\\r\\n\\t}\\r\\n\\r\\n\\tfor (int k = 1; k <= 2; ++k) {\\r\\n\\t\\t// BFS on directed tree\\r\\n\\t\\t// to find the ancestors of both cows and the distance to them\\r\\n\\t\\tstring node = c[k];\\r\\n\\t\\twhile (true) {\\r\\n\\t\\t\\tauto E = edge.find(node);\\r\\n\\t\\t\\tif (E != edge.end()) {\\r\\n\\t\\t\\t\\tdist[k][E->s] = dist[k][node] + 1;\\r\\n\\t\\t\\t\\tnode = E->s;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse break;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tstring ancestor;\\r\\n\\tint d1 = 105, d2 = 105;\\r\\n\\t// Finding the common ancestor with shortest distance\\r\\n\\tfor (auto& D1 : dist[1]) {\\r\\n\\t\\tauto D2 = dist[2].find(D1.f);\\r\\n\\t\\tif (D2 != dist[2].end() && (d1 > D1.s || d2 > D2->s)) {\\r\\n\\t\\t\\tancestor = D1.f;\\r\\n\\t\\t\\td1 = D1.s;\\r\\n\\t\\t\\td2 = D2->s;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (ancestor.empty()) cout << \\\"NOT RELATED\\\";\\r\\n\\r\\n\\telse if (ancestor == c[2] || ancestor == c[1]) {\\r\\n\\t\\tif (ancestor == c[1]) swap(c[1],c[2]), swap(d1,d2);\\r\\n\\t\\tcout << c[2] << \\\" is the \\\";\\r\\n\\t\\tif (d1 >= 2) {\\r\\n\\t\\t\\tfor (int i = 0; i < d1 - 2; ++i) cout << \\\"great-\\\";\\r\\n\\t\\t\\tcout << \\\"grand-\\\";\\r\\n\\t\\t}\\r\\n\\t\\tcout << \\\"mother of \\\" << c[1];\\r\\n\\t}\\r\\n\\r\\n\\telse {\\r\\n\\t\\tif (d2 < d1) swap(d2,d1), swap(c[2],c[1]);\\r\\n\\t\\tif (d1 == 1) {\\r\\n\\t\\t\\tif (d2 == 1) cout << \\\"SIBLINGS\\\";\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tcout << c[1] << \\\" is the \\\";\\r\\n\\t\\t\\t\\tfor (int i = 0; i < d2 - 2; ++i) cout << \\\"great-\\\";\\r\\n\\t\\t\\t\\tcout << \\\"aunt of \\\" << c[2];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse cout << \\\"COUSINS\\\";\\r\\n\\t}\\r\\n\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-833","source":"USACO Bronze 2018 Open","title":"Family Tree","author":"Danh Ta Chi Thanh, Ryan Chou, Chuyang Wang"},"parent":{"name":"usaco-833","relativePath":"usaco-833.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Alternative Solution - BFS","slug":"alternative-solution---bfs"}],"java":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Alternative Solution - BFS","slug":"alternative-solution---bfs"}],"py":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Alternative Solution - BFS","slug":"alternative-solution---bfs"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"intro-tree","title":"Introduction to Tree Algorithms"}}}},{"node":{"module":{"frontmatter":{"id":"intro-graphs","title":"Introduction to Graphs"}}}}]},"problemInfo":{"uniqueId":"usaco-833","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=833"}},"pageContext":{"id":"usaco-833"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}