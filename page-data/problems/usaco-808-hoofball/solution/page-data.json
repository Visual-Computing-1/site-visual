{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-808-hoofball/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-808\", source = \"USACO Bronze 2018 February\", title = \"Hoofball\", author = \"Ryan Chou, Ben Dodge\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, PySection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_hoofball_bronze_feb18.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"explanation\",\n      children: [_jsx(_components.a, {\n        href: \"#explanation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Explanation\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, let's realize that Farmer John will need another ball in one of two cases:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"A cow is a source cow, or a cow that Farmer John first passses to.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Two cows are close together, so they pass a ball back and forth endlessly and another ball is needed for other cows to hold.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, each time this occurs we can count it and return this total count as our answer once we're done.\\r\\nWe can do this first by finding which cow, if any, every cow passes the ball to.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\n\\r\\nsys.stdin = open('hoofball.in', 'r')\\r\\nsys.stdout = open('hoofball.out', 'w')\\r\\n\\r\\nn = int(input())\\r\\ncows = sorted(list(map(int, input().strip().split())))\\r\\nballs = [0] * n\\r\\nans = 0\\r\\n\\r\\ndef nearestneighbor(ind):\\r\\n\\tlnbr, rnbr = -1, -1\\r\\n\\tldist, rdist = 1000, 1000\\r\\n\\tfor i in range(n):\\r\\n\\t\\t\\\"\\\"\\\"\\r\\n\\t\\tIf the cow we're looking at is on the left\\r\\n\\t\\tand it's closer to the target than the previous one.\\r\\n\\t\\t\\\"\\\"\\\"\\r\\n\\t\\tif cows[i] < cows[ind] and cows[ind] - cows[i] < ldist:\\r\\n\\t\\t\\tlnbr = i\\r\\n\\t\\t\\tldist = cows[ind] - cows[i]\\r\\n\\tfor i in range(n):\\r\\n\\t\\t# same thing, but for the right.\\r\\n\\t\\tif cows[i] > cows[ind] and cows[i] - cows[ind] < rdist:\\r\\n\\t\\t\\trnbr = i\\r\\n\\t\\t\\trdist = cows[i] - cows[ind]\\r\\n\\treturn lnbr if ldist <= rdist else rnbr\\r\\n    \\r\\nfor i in range(n):\\r\\n\\t# all cows who receive a ball\\r\\n\\tballs[nearestneighbor(i)] += 1\\r\\nfor i in range(n):\\r\\n\\t\\\"\\\"\\\"\\r\\n\\tif the cow isn't passed to by any of the neighbors,\\r\\n\\tthen we have to give it a ball.\\r\\n\\t\\\"\\\"\\\"\\r\\n\\tif balls[i] == 0:\\r\\n\\t\\tans += 1\\r\\n\\t\\\"\\\"\\\"\\r\\n\\tIf we find two cows which only pass to each other,\\r\\n\\twe have to give them one as well.\\r\\n\\t\\\"\\\"\\\"\\r\\n\\tif (i < nearestneighbor(i) and nearestneighbor(nearestneighbor(i)) == i\\r\\n\\t\\tand balls[i] == 1 and balls[nearestneighbor(i)] == 1):\\r\\n\\t\\tans += 1\\r\\n    \\r\\nprint(ans)\\n\"\n          })\n        })\n      }), _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <fstream>\\r\\nusing namespace std;\\r\\n\\r\\nconst int MAX_N = 100;\\r\\nconst int MAX_X = 1000;\\r\\n\\r\\nint N, cows[MAX_N], cowsPassingTo[MAX_N];\\r\\n\\r\\n// Which cow does a given cow pass to?\\r\\nint passToCow(int cow) {\\r\\n\\tint leftCow = -1;\\r\\n\\tint rightCow = -1;\\r\\n\\tint leftRange = MAX_X;\\r\\n\\tint rightRange = MAX_X;\\r\\n\\t// For each cow, find closest cows to it on the left and right\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\tif (cows[i] < cows[cow] && cows[cow] - cows[i] < leftRange) {\\r\\n\\t\\t\\tleftCow = i;\\r\\n\\t\\t\\tleftRange = cows[cow] - cows[i];\\r\\n\\t\\t}\\r\\n\\t\\tif (cows[i] > cows[cow] && cows[i] - cows[cow] < rightRange) {\\r\\n\\t\\t\\trightCow = i;\\r\\n\\t\\t\\trightRange = cows[i] - cows[cow];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\r\\n\\t// Return the position identifier of cow that the given cow passes to\\r\\n\\tif (leftRange <= rightRange) {\\r\\n\\t\\treturn leftCow;\\r\\n\\t}        \\r\\n\\treturn rightCow;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tifstream fin(\\\"hoofball.in\\\");\\r\\n\\tofstream fout(\\\"hoofball.out\\\");\\r\\n\\tfin >> N;\\r\\n\\tint ballsNeeded = 0;\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\tfin >> cows[i];\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\tcowsPassingTo[passToCow(i)]++;\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t// This is a source cow, so give it a ball\\r\\n\\t\\tif (cowsPassingTo[i] == 0) { \\r\\n\\t\\t\\tballsNeeded++;\\r\\n\\t\\t}\\r\\n\\t\\t// This cow only passes to 1 other cow forever, so give it a ball\\r\\n\\t\\tif (i < passToCow(i)\\r\\n\\t\\t\\t&& passToCow(passToCow(i)) == i\\r\\n\\t\\t\\t&& cowsPassingTo[i] == 1\\r\\n\\t\\t\\t&& cowsPassingTo[passToCow(i)] == 1) {\\r\\n\\t\\t\\tballsNeeded++;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tfout << ballsNeeded << \\\"\\\\n\\\";\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class Hoofball {\\r\\n\\tstatic final int MAX_X = 1000;\\r\\n\\t\\r\\n\\tstatic int N;\\r\\n\\tstatic int[] cows;\\r\\n\\tstatic int[] cowsPassingTo;\\r\\n\\r\\n\\t// Which cow does a given cow pass to?\\r\\n\\tpublic static int passToCow(int cow) {\\r\\n\\t\\tint leftCow = -1;\\r\\n\\t\\tint rightCow = -1;\\r\\n\\t\\tint leftRange = MAX_X;\\r\\n\\t\\tint rightRange = MAX_X;\\r\\n\\r\\n\\t\\t// For each cow, find closest cows to it on the left and right\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tif (cows[i] < cows[cow] && cows[cow] - cows[i] < leftRange) {\\r\\n\\t\\t\\t\\tleftCow = i;\\r\\n\\t\\t\\t\\tleftRange = cows[cow] - cows[i];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (cows[i] > cows[cow] && cows[i] - cows[cow] < rightRange) {\\r\\n\\t\\t\\t\\trightCow = i;\\r\\n\\t\\t\\t\\trightRange = cows[i] - cows[cow];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\t// Return the position identifier of cow that the given cow passes to\\r\\n\\t\\tif (leftRange <= rightRange) {\\r\\n\\t\\t\\treturn leftCow;\\r\\n\\t\\t}\\r\\n\\t\\treturn rightCow;\\r\\n\\t}\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tKattio io = new Kattio(\\\"hoofball\\\");\\r\\n\\r\\n\\t\\tN = io.nextInt();\\r\\n\\t\\tcows = new int[N];\\r\\n\\t\\tcowsPassingTo = new int[N];\\r\\n\\t\\tint ballsNeeded = 0;\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tcows[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Let's classify each cow  \\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tcowsPassingTo[passToCow(i)]++;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\t// This is a source cow, so give it a ball\\r\\n\\t\\t\\tif (cowsPassingTo[i] == 0) {\\r\\n\\t\\t\\t\\tballsNeeded++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t// This cow only passes to 1 other cow forever, so give it a ball\\r\\n\\t\\t\\tif (i < passToCow(i)\\r\\n\\t\\t\\t\\t&& passToCow(passToCow(i)) == i\\r\\n\\t\\t\\t\\t&& cowsPassingTo[i] == 1\\r\\n\\t\\t\\t\\t&& cowsPassingTo[passToCow(i)] == 1) {\\r\\n\\t\\t\\t\\tballsNeeded++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tio.println(ballsNeeded);\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\r\\n\\t\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-808","source":"USACO Bronze 2018 February","title":"Hoofball","author":"Ryan Chou, Ben Dodge"},"parent":{"name":"usaco-808","relativePath":"usaco-808.mdx"},"toc":{"cpp":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"ad-hoc","title":"Ad Hoc Problems"}}}}]},"problemInfo":{"uniqueId":"usaco-808","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=808"}},"pageContext":{"id":"usaco-808"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}