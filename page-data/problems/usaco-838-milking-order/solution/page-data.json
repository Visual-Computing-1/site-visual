{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-838-milking-order/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-838\", source = \"USACO Gold 2018 Open\", title = \"Milking Order\", author = \"Timothy Gao, Qi Wang, Melody Yu, Neo Wang\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Youtube: _missingComponent(\"Youtube\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, Youtube, MATHSPAN, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_milkorder_gold_open18.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"video-solution\",\n      children: [_jsx(_components.a, {\n        href: \"#video-solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Video Solution\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: The video solution might not be the same as other solutions. Code in C++.\"\n    }), \"\\n\", _jsx(Youtube, {\n      id: \"OaL9vEkShyk\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution\",\n      children: [_jsx(_components.a, {\n        href: \"#solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Denote each cow as a node in a graph. Let's draw a directed edge from each node \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" to another node \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" if \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" must come before \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \". Note that this can be done when we process the \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"M\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\\\"application/x-tex\\\">M</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span></span></span></span>\"\n      }), \" observations. Now, notice that an ordering is valid only if the resulting graph is a DAG. Additionally, we can use a priority queue (instead of a queue) with topological sort to generate the lexicographically minimum topological ordering. It remains to find how many observations we can follow starting from the first observation, which we can binary search for.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}((E + N \\\\log N) \\\\log M)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mo stretchy=\\\"false\\\">(</mo><mi>E</mi><mo>+</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo><mi>log</mi><mo>⁡</mo><mi>M</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}((E + N \\\\log N) \\\\log M)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">((</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05764em;\\\">E</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"//BeginCodeSnip{C++ Short Template}\\n#include <bits/stdc++.h> // see /general/running-code-locally\\nusing namespace std;\\n\\nusing ll = long long;\\n\\nusing vi = vector<int>;\\n#define pb push_back\\n#define all(x) begin(x), end(x)\\n#define sz(x) (int) (x).size()\\n\\nusing pi = pair<int,int>;\\n#define f first\\n#define s second\\n#define mp make_pair\\n\\nvoid setIO(string name = \\\"\\\") {\\n\\tcin.tie(0)->sync_with_stdio(0); // see /general/fast-io\\n\\tif (sz(name)) {\\n\\t\\tfreopen((name + \\\".in\\\").c_str(), \\\"r\\\", stdin); // see /general/input-output\\n\\t\\tfreopen((name + \\\".out\\\").c_str(), \\\"w\\\", stdout);\\n\\t}\\n}\\n//EndCodeSnip\\n//BeginCodeSnip{Topological Sort}\\r\\n/*\\r\\n  * Description: sorts vertices such that if there exists an edge x->y, then x goes before y\\r\\n  * Source: KACTL\\r\\n  * Verification: https://open.kattis.com/problems/quantumsuperposition\\r\\n  */\\r\\n\\r\\nstruct TopoSort {\\r\\n\\tint N; vi in, res;\\r\\n\\tvector<vi> adj;\\r\\n\\tvoid init(int _N) { N = _N; in.resize(N); adj.resize(N); }\\r\\n\\tvoid ae(int x, int y) { adj[x].pb(y), in[y]++; }\\r\\n\\tbool sort() {\\r\\n\\t\\tpriority_queue<int, vi, greater<int>> todo;\\r\\n\\t\\tfor (int i = 1; i < N; i++)\\r\\n\\t\\t\\tif (!in[i]) todo.push(i);\\r\\n\\t\\twhile (sz(todo)) {\\r\\n\\t\\t\\tint x = todo.top(); todo.pop(); res.pb(x);\\r\\n\\t\\t\\tfor (const int &i : adj[x])\\r\\n\\t\\t\\t\\tif (!(--in[i])) todo.push(i);\\r\\n\\t\\t}\\r\\n\\t\\treturn sz(res) == N - 1;\\r\\n\\t}\\r\\n};\\r\\n//EndCodeSnip{Topological Sort}\\r\\n\\r\\nvi ret;\\r\\nvector<vi> order;\\r\\nint n, m;\\r\\n\\r\\nbool check(int x) {\\r\\n\\tTopoSort T; T.init(n + 1);\\r\\n\\tfor (int i = 0; i < x; i++) {\\r\\n\\t\\tfor (int j = 0; j < sz(order[i]) - 1; j++) {\\r\\n\\t\\t\\tT.ae(order[i][j], order[i][j + 1]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tbool ans = T.sort();\\r\\n\\tif (ans)\\r\\n\\t\\tret = T.res;\\r\\n\\treturn ans;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tsetIO(\\\"milkorder\\\");\\r\\n\\tcin >> n >> m;\\r\\n\\torder.resize(m);\\r\\n\\r\\n\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\tint k; cin >> k;\\r\\n\\t\\tvi v(k);\\r\\n\\t\\tfor (int j = 0; j < k; j++)\\r\\n\\t\\t\\tcin >> v[j];\\r\\n\\t\\torder[i] = v;\\r\\n\\t}\\r\\n\\r\\n\\tint lo = 0, hi = m;\\r\\n\\twhile (lo < hi) {  // find the last successful check()\\r\\n\\t\\tint mid = lo + (hi - lo + 1) / 2;\\r\\n\\t\\tcheck(mid) ? lo = mid : hi = mid - 1;\\r\\n\\t}\\r\\n\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tcout << ret[i] << (i != n - 1 ? \\\" \\\" : \\\"\\\");\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class MilkingOrder {\\r\\n\\tstatic int N, M;\\r\\n\\tstatic List<Edge>[] adj;\\r\\n\\tstatic List<Integer> res;\\r\\n\\tpublic static void main(String[] args) throws Exception {\\r\\n\\t\\tKattio io = new Kattio(\\\"milkorder\\\");\\r\\n\\r\\n\\t\\tN = io.nextInt();\\r\\n\\t\\tM = io.nextInt();\\r\\n\\r\\n\\t\\tadj = new List[M];\\r\\n\\r\\n\\t\\tfor (int i = 0; i < M; i++) {\\r\\n\\t\\t\\tadj[i] = new ArrayList<>();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < M - 1; i++) {\\r\\n\\t\\t\\tint n = io.nextInt();\\r\\n\\r\\n\\t\\t\\tint prev = -1;\\r\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\r\\n\\t\\t\\t\\tint to = io.nextInt() - 1;\\r\\n\\t\\t\\t\\tif(prev != -1) {\\r\\n\\t\\t\\t\\t\\tadj[i].add(new Edge(prev, to));\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tprev = to;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint l = 0;\\r\\n\\t\\tint r = M;\\r\\n\\r\\n\\t\\twhile(l < r) {\\r\\n\\t\\t\\tint mid = (l + r + 1) / 2;\\r\\n\\r\\n\\t\\t\\tif(check(mid)) {\\r\\n\\t\\t\\t\\tl = mid;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tr = mid - 1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcheck(l);\\r\\n\\r\\n\\t\\tfor (int i = 0; i < res.size(); i++) {\\r\\n\\t\\t\\tio.print(res.get(i));\\r\\n\\t\\t\\tif(i < res.size()-1) {\\r\\n\\t\\t\\t\\tio.print(\\\" \\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\r\\n\\tpublic static boolean check(int x) {\\r\\n\\t\\tint[] inDeg = new int[N];\\r\\n\\t\\tList<Integer>[] edge = new List[N];\\r\\n\\t\\tres = new ArrayList<>();\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tedge[i] = new ArrayList<>();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < x; i++) {\\r\\n\\t\\t\\tfor (int j = 0; j < adj[i].size(); j++) {\\r\\n\\t\\t\\t\\tinDeg[adj[i].get(j).t]++;\\r\\n\\t\\t\\t\\tedge[adj[i].get(j).f].add(adj[i].get(j).t);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tPriorityQueue<Integer> q = new PriorityQueue<>();\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tif(inDeg[i] == 0) {\\r\\n\\t\\t\\t\\tq.add(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\twhile (!q.isEmpty()) {\\r\\n\\t\\t\\tint curr = q.poll();\\r\\n\\r\\n\\t\\t\\tres.add(curr + 1);\\r\\n\\r\\n\\t\\t\\tfor (int next : edge[curr]) {\\r\\n\\t\\t\\t\\tinDeg[next]--;\\r\\n\\t\\t\\t\\tif(inDeg[next] == 0) {\\r\\n\\t\\t\\t\\t\\tq.add(next);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn res.size() == N;\\r\\n\\t}\\r\\n\\r\\n\\tprivate static class Edge {\\r\\n\\t\\tint f, t;\\r\\n\\t\\tpublic Edge(int a, int b) {\\r\\n\\t\\t\\tf = a;\\r\\n\\t\\t\\tt = b;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\r\\n\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-838","source":"USACO Gold 2018 Open","title":"Milking Order","author":"Timothy Gao, Qi Wang, Melody Yu, Neo Wang"},"parent":{"name":"usaco-838","relativePath":"usaco-838.mdx"},"toc":{"cpp":[{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"toposort","title":"Topological Sort"}}}}]},"problemInfo":{"uniqueId":"usaco-838","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=838"}},"pageContext":{"id":"usaco-838"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}