{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-921-cow-land/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-921\", source = \"USACO Gold 2019 February\", title = \"Cow Land\", author = \"Albert Ye\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {MATHSPAN, HeaderLink, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}((n+q) \\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo>+</mo><mi>q</mi><mo stretchy=\\\"false\\\">)</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}((n+q) \\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">((</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">q</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Main Idea:\"\n      }), \" We use Euler tour technique to initialize a binary indexed tree,\\r\\nand use the binary indexed tree to run range XOR queries.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Check the\\r\\n\", _jsx(_components.a, {\n        href: \"http://usaco.org/current/data/sol_cowland_gold_feb19.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"official solution\"\n      }), \"\\r\\nfor another, more complicated, solution with HLD.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"e_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>e</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">e_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5806em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" be the enjoyment values for each of the attractions, and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"lca(i, j)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy=\\\"false\\\">(</mo><mi>i</mi><mo separator=\\\"true\\\">,</mo><mi>j</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">lca(i, j)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.01968em;\\\">l</span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \"\\r\\nbe the lowest common ancestor between nodes \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"j\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\\\"application/x-tex\\\">j</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.854em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"euler-tour-technique\",\n      children: [_jsx(_components.a, {\n        href: \"#euler-tour-technique\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Euler Tour Technique\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>i</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">i_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8095em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"o_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>o</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">o_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5806em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">o</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" be the in and out times for the tree, which we find through\\r\\nDFS with the Euler tour technique mentioned in\\r\\n\", _jsx(_components.a, {\n        href: \"/gold/tree-euler\",\n        children: \"this section\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"binary-indexed-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#binary-indexed-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Binary Indexed Tree\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We create a binary indexed tree which supports range updates and XOR queries.\\r\\nNote that the inverse of XOR is XOR itself.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Store \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"e_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>e</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">e_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5806em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" at indices \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>i</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">i_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8095em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"o_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>o</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">o_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5806em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">o</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" for all \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \" in the BIT. Note that the\\r\\nprefix XOR to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>i</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">i_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8095em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" is now the path XOR from the root node to each node at the\\r\\ntree. See\\r\\n\", _jsx(_components.a, {\n        href: \"/solutions/cses-1138\",\n        children: \"the solution for Path Queries\"\n      }), \" for a\\r\\ncomprehensive explanation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let the prefix XOR at \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n      }), \" be \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"X(i)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>X</mi><mo stretchy=\\\"false\\\">(</mo><mi>i</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">X(i)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07847em;\\\">X</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \". The difference between the explanation for Path Queries and this problem is that\\r\\nwe have range XOR queries instead of range sum queries. This precomputation takes \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(n \\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(n \\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"responding-to-queries\",\n      children: [_jsx(_components.a, {\n        href: \"#responding-to-queries\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Responding to Queries\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We now need to respond to path queries and updates. To update node \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \", we\\r\\nremove the current values at \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>i</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">i_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8095em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"o_x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>o</mi><mi>x</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">o_x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5806em;vertical-align:-0.15em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">o</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">x</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" and replace these indices with the\\r\\nnew value. For a path query, we just output\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"X(i) \\\\oplus X(j) \\\\oplus e_{lca(i, j)}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>X</mi><mo stretchy=\\\"false\\\">(</mo><mi>i</mi><mo stretchy=\\\"false\\\">)</mo><mo>⊕</mo><mi>X</mi><mo stretchy=\\\"false\\\">(</mo><mi>j</mi><mo stretchy=\\\"false\\\">)</mo><mo>⊕</mo><msub><mi>e</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy=\\\"false\\\">(</mo><mi>i</mi><mo separator=\\\"true\\\">,</mo><mi>j</mi><mo stretchy=\\\"false\\\">)</mo></mrow></msub></mrow><annotation encoding=\\\"application/x-tex\\\">X(i) \\\\oplus X(j) \\\\oplus e_{lca(i, j)}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07847em;\\\">X</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⊕</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07847em;\\\">X</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⊕</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7858em;vertical-align:-0.3552em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3448em;\\\"><span style=\\\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.01968em;\\\">l</span><span class=\\\"mord mathnormal mtight\\\">c</span><span class=\\\"mord mathnormal mtight\\\">a</span><span class=\\\"mopen mtight\\\">(</span><span class=\\\"mord mathnormal mtight\\\">i</span><span class=\\\"mpunct mtight\\\">,</span><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mclose mtight\\\">)</span></span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3552em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" (where \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\oplus\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\oplus</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">⊕</span></span></span></span>\"\n      }), \" represents the XOR\\r\\noperation). The \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"X(i)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>X</mi><mo stretchy=\\\"false\\\">(</mo><mi>i</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">X(i)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07847em;\\\">X</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"X(j)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>X</mi><mo stretchy=\\\"false\\\">(</mo><mi>j</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">X(j)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07847em;\\\">X</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" are the XOR queries for the paths from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \" to\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"j\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\\\"application/x-tex\\\">j</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.854em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span></span></span></span>\"\n      }), \", respectively. The path from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"lca(i, j)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy=\\\"false\\\">(</mo><mi>i</mi><mo separator=\\\"true\\\">,</mo><mi>j</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">lca(i, j)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.01968em;\\\">l</span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">i</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" is counted\\r\\ntwice and thus negates itself. Thus, we need to also XOR \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"e_{lca(i,j)}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>e</mi><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy=\\\"false\\\">(</mo><mi>i</mi><mo separator=\\\"true\\\">,</mo><mi>j</mi><mo stretchy=\\\"false\\\">)</mo></mrow></msub></mrow><annotation encoding=\\\"application/x-tex\\\">e_{lca(i,j)}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7858em;vertical-align:-0.3552em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3448em;\\\"><span style=\\\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\"><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.01968em;\\\">l</span><span class=\\\"mord mathnormal mtight\\\">c</span><span class=\\\"mord mathnormal mtight\\\">a</span><span class=\\\"mopen mtight\\\">(</span><span class=\\\"mord mathnormal mtight\\\">i</span><span class=\\\"mpunct mtight\\\">,</span><span class=\\\"mord mathnormal mtight\\\" style=\\\"margin-right:0.05724em;\\\">j</span><span class=\\\"mclose mtight\\\">)</span></span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3552em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" to\\r\\naccount for the full path XOR from \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"j\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\\\"application/x-tex\\\">j</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.854em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05724em;\\\">j</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"LCA precomputation is known to take \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(n \\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(n \\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" with sparse table.\\r\\nAdditionally, updates and queries both take \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(\\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(\\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" each, the\\r\\ncomplexity of the LCA and BIT queries. As there are \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"q\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>q</mi></mrow><annotation encoding=\\\"application/x-tex\\\">q</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">q</span></span></span></span>\"\n      }), \" updates and queries in\\r\\ntotal, the total complexity for the querying step is \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(q \\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>q</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(q \\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">q</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \".\\r\\nHence, the total complexity is \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}((n+q) \\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo>+</mo><mi>q</mi><mo stretchy=\\\"false\\\">)</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}((n+q) \\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">((</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">q</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(CPPSection, {\n        children: [_jsxs(_components.h2, {\n          id: \"implementation\",\n          children: [_jsx(_components.a, {\n            href: \"#implementation\",\n            \"aria-hidden\": \"true\",\n            tabIndex: \"-1\",\n            className: \"anchor before\",\n            children: _jsx(HeaderLink, {})\n          }), \"Implementation\"]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\n\\r\\n#define MAXN 100005\\r\\n#define bitinc(x) (x&-x);\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\nint n,arr[MAXN],bit[4*MAXN],in[MAXN],ot[MAXN],par[MAXN][22];\\r\\nvector<int> adj[MAXN];\\r\\n\\r\\nint timer = 1;\\r\\n// does initial DFS to find the time in/out for each subtree-range.\\r\\nvoid dfs(int v=0,int p=0)\\r\\n{\\r\\n\\tin[v] = timer++;\\r\\n\\tpar[v][0] = p;\\r\\n\\tfor(int i = 1; i < 22; i++)\\r\\n\\t\\tpar[v][i] = par[par[v][i-1]][i-1];\\r\\n\\tfor(int x : adj[v])\\r\\n\\t{\\r\\n\\t\\tif(x == p) continue;\\r\\n\\t\\tdfs(x,v);\\r\\n\\t}\\r\\n\\tot[v] = timer++;\\r\\n}\\r\\n\\r\\n// prefix xor. reversable = done onto itself\\r\\nint XOR(int ind)\\r\\n{\\r\\n\\tint xo = 0;\\r\\n\\twhile(ind > 0)\\r\\n\\t{\\r\\n\\t\\txo ^= bit[ind];\\r\\n\\t\\tind -= bitinc(ind);\\r\\n\\t}\\r\\n\\treturn xo;\\r\\n}\\r\\nvoid upd(int ind, int val)\\r\\n{\\r\\n\\twhile(ind <= timer)\\r\\n\\t{\\r\\n\\t\\tbit[ind] ^= val;\\r\\n\\t\\tind += bitinc(ind);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nbool anc(int u, int v)\\r\\n{\\r\\n\\treturn (in[u] <= in[v] && ot[u] >= ot[v]);\\r\\n}\\r\\n\\r\\n// method finding all lca's\\r\\nint lca(int u, int v)\\r\\n{\\r\\n\\tif(anc(u,v))\\r\\n\\t\\treturn u;\\r\\n\\tfor(int i = 21; i >= 0; i--)\\r\\n\\t{\\r\\n\\t\\tif(par[u][i] >= 0 && !anc(par[u][i], v))\\r\\n\\t\\t\\tu = par[u][i];\\r\\n\\t}\\r\\n\\treturn par[u][0];\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tfreopen(\\\"cowland.in\\\", \\\"r\\\", stdin);\\r\\n\\tfreopen(\\\"cowland.out\\\", \\\"w\\\", stdout);\\r\\n\\tint q;\\r\\n\\tcin >> n >> q;\\r\\n\\tfor(int i = 0; i < n; i++) cin >> arr[i];\\r\\n\\tfor(int i = 1; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tint u,v;\\r\\n\\t\\tcin >> u >> v;\\r\\n\\t\\t--u; --v;\\r\\n\\t\\tadj[u].push_back(v);\\r\\n\\t\\tadj[v].push_back(u);\\r\\n\\t}\\r\\n\\tdfs();\\r\\n\\t// add each vertex query right now.\\r\\n\\tfor(int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tupd(in[i], arr[i]);\\r\\n\\t\\tupd(ot[i], arr[i]);\\r\\n\\t}\\r\\n\\t// rep. for each query\\r\\n\\tfor(int que = 0; que < q; que++)\\r\\n\\t{\\r\\n\\t\\tint t;\\r\\n\\t\\tcin >> t;\\r\\n\\t\\tif(t==1)\\r\\n\\t\\t{\\r\\n\\t\\t\\tint s, x;\\r\\n\\t\\t\\tcin >> s >> x;\\r\\n\\t\\t\\t--s;\\r\\n\\t\\t\\t// erase the initial arr[s] value.\\r\\n\\t\\t\\tupd(in[s], arr[s]);\\r\\n\\t\\t\\tupd(ot[s], arr[s]);\\r\\n\\t\\t\\tarr[s] = x;\\r\\n\\t\\t\\t// update the arr[s] value to x.\\r\\n\\t\\t\\tupd(in[s], arr[s]);\\r\\n\\t\\t\\tupd(ot[s], arr[s]);\\r\\n\\t\\t} else\\r\\n\\t\\t{\\r\\n\\t\\t\\tint u,v;\\r\\n\\t\\t\\tcin >> u >> v;\\r\\n\\t\\t\\t--u; --v;\\r\\n\\t\\t\\tint w = lca(u,v);\\r\\n\\t\\t\\tcout << ((XOR(in[u]) ^ XOR(in[v])) ^ arr[w]) << endl;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })]\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\n// this one uses a segment tree for the xor-ing instead of a BIT, but overall it's the same philosophy\\r\\npublic class CowLand {\\r\\n\\tprivate static class MinSegTree {\\r\\n\\t\\tprivate final int[] segtree;\\r\\n\\t\\tprivate final int arrSize;\\r\\n\\t\\tprivate final int size;\\r\\n\\t\\tprivate final Comparator<Integer> cmp;\\r\\n\\r\\n\\t\\tpublic MinSegTree(int len, Comparator<Integer> comp) {\\r\\n\\t\\t\\tint size = 1;\\r\\n\\t\\t\\twhile (size < len) {\\r\\n\\t\\t\\t\\tsize *= 2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.size = size;\\r\\n\\t\\t\\tcmp = comp;\\r\\n\\t\\t\\tarrSize = len;\\r\\n\\t\\t\\tsegtree = new int[size * 2];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic MinSegTree(int[] arr, Comparator<Integer> comp) {\\r\\n\\t\\t\\tthis(arr.length, comp);\\r\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++) {\\r\\n\\t\\t\\t\\tset(i, arr[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic void set(int index, int element) {\\r\\n\\t\\t\\tif (index < 0 || index > arrSize) {\\r\\n\\t\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"%s should be out of bounds\\\", index));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tset(index, element, 0, 0, size);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprivate void set(int index, int element, int currNode, int left, int right) {\\r\\n\\t\\t\\tif (right - left == 1) {\\r\\n\\t\\t\\t\\tsegtree[currNode] = element;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tint mid = (left + right) / 2;\\r\\n\\t\\t\\t\\tif (index < mid) {\\r\\n\\t\\t\\t\\t\\tset(index, element, 2 * currNode + 1, left, mid);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tset(index, element, 2 * currNode + 2, mid, right);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tsegtree[currNode] = Collections.min(Arrays.asList(segtree[2 * currNode + 1], segtree[2 * currNode + 2]), cmp);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic int min(int from, int to) {\\r\\n\\t\\t\\tif (from < 0 || to > arrSize) {\\r\\n\\t\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"the bounds %s and %s are out of bounds i think\\\", from, to));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn min(from, to, 0, 0, size);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprivate int min(int from, int to, int currNode, int left, int right) {\\r\\n\\t\\t\\tif (right <= from || to <= left) {\\r\\n\\t\\t\\t\\treturn Integer.MAX_VALUE;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (from <= left && right <= to) {\\r\\n\\t\\t\\t\\treturn segtree[currNode];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tint middle = (left + right) / 2;\\r\\n\\t\\t\\tint leftPart = min(from, to, 2 * currNode + 1, left, middle);\\r\\n\\t\\t\\tint rightPart = min(from, to, 2 * currNode + 2, middle, right);\\r\\n\\t\\t\\tif (leftPart == Integer.MAX_VALUE) {\\r\\n\\t\\t\\t\\treturn rightPart;\\r\\n\\t\\t\\t} else if (rightPart == Integer.MAX_VALUE) {\\r\\n\\t\\t\\t\\treturn leftPart;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn cmp.compare(leftPart, rightPart) < 0 ? leftPart : rightPart;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tprivate static class XORSegTree {\\r\\n\\t\\tprivate final int[] segtree;\\r\\n\\t\\tprivate final int arrSize;\\r\\n\\t\\tprivate final int size;\\r\\n\\r\\n\\t\\tpublic XORSegTree(int len) {  // constructs the thing kinda like an array\\r\\n\\t\\t\\tint size = 1;\\r\\n\\t\\t\\twhile (size < len) {\\r\\n\\t\\t\\t\\tsize *= 2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis.size = size;\\r\\n\\t\\t\\tarrSize = len;\\r\\n\\t\\t\\tsegtree = new int[size * 2];  // we won't necessarily use all of the element but that doesn't really matter\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic void set(int index, int element) {\\r\\n\\t\\t\\tif (index < 0 || index > arrSize) {\\r\\n\\t\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"%s should be out of bounds lol\\\", index));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tset(index, element, 0, 0, size);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprivate void set(int index, int element, int currNode, int left, int right) {\\r\\n\\t\\t\\tif (right - left == 1) {\\r\\n\\t\\t\\t\\tsegtree[currNode] = element;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tint mid = (left + right) / 2;\\r\\n\\t\\t\\t\\tif (index < mid) {\\r\\n\\t\\t\\t\\t\\tset(index, element, 2 * currNode + 1, left, mid);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tset(index, element, 2 * currNode + 2, mid, right);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tsegtree[currNode] = segtree[2 * currNode + 1] ^ segtree[2 * currNode + 2];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// for this one, from and to follow \\\"normal\\\" slicing rules - left bound is inclusive, right bound isn't\\r\\n\\t\\tpublic int xor(int from, int to) {\\r\\n\\t\\t\\tif (from < 0 || to > arrSize) {\\r\\n\\t\\t\\t\\tthrow new IllegalArgumentException(String.format(\\\"the bounds %s and %s are out of bounds i think\\\", from, to));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn xor(from, to, 0, 0, size);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprivate int xor(int from, int to, int currNode, int left, int right) {\\r\\n\\t\\t\\tif (right <= from || to <= left) {  // oof, out of bounds, so the sum is definitely 0\\r\\n\\t\\t\\t\\treturn 0;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (from <= left && right <= to) {\\r\\n\\t\\t\\t\\treturn segtree[currNode];\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tint middle = (left + right) / 2;\\r\\n\\t\\t\\tint leftPartSum = xor(from, to, 2 * currNode + 1, left, middle);\\r\\n\\t\\t\\tint rightPartSum = xor(from, to, 2 * currNode + 2, middle, right);\\r\\n\\t\\t\\treturn leftPartSum ^ rightPartSum;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tprivate static class AmusementPark {\\r\\n\\t\\tprivate final ArrayList<Integer>[] neighbors;\\r\\n\\t\\tprivate final ArrayList<Integer> eulerTour = new ArrayList<>();\\r\\n\\t\\tprivate final int[] firstOcc;\\r\\n\\t\\tprivate final int[] lastOcc;\\r\\n\\t\\tprivate final int[] height;\\r\\n\\t\\tprivate final int[] enjoyment;\\r\\n\\t\\tprivate final int nodes;\\r\\n\\r\\n\\t\\tprivate final MinSegTree LCATree;\\r\\n\\t\\tprivate final XORSegTree queryTree;\\r\\n\\r\\n\\t\\tpublic AmusementPark(ArrayList<Integer>[] neighbors, int[] respectiveVals) {\\r\\n\\t\\t\\tthis.neighbors = neighbors;\\r\\n\\t\\t\\tenjoyment = respectiveVals.clone();\\r\\n\\t\\t\\tnodes = neighbors.length;\\r\\n\\t\\t\\tfirstOcc = new int[nodes];\\r\\n\\t\\t\\tlastOcc = new int[nodes];\\r\\n\\t\\t\\theight = new int[nodes];\\r\\n\\r\\n\\t\\t\\teulerTour();\\r\\n\\t\\t\\tboolean[] seen = new boolean[nodes];\\r\\n\\t\\t\\tfor (int i = eulerTour.size() - 1; i >= 0; i--) {\\r\\n\\t\\t\\t\\tint n = eulerTour.get(i);\\r\\n\\t\\t\\t\\tif (!seen[n]) {\\r\\n\\t\\t\\t\\t\\tlastOcc[n] = i;\\r\\n\\t\\t\\t\\t\\tseen[n] = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tqueryTree = new XORSegTree(eulerTour.size());\\r\\n\\t\\t\\tfor (int n = 0; n < nodes; n++) {\\r\\n\\t\\t\\t\\tqueryTree.set(firstOcc[n], enjoyment[n]);\\r\\n\\t\\t\\t\\tqueryTree.set(lastOcc[n], enjoyment[n]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tLCATree = new MinSegTree(eulerTour.stream().mapToInt(i -> i).toArray(), Comparator.comparingInt(n -> height[n]));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic int query(int n1, int n2) {\\r\\n\\t\\t\\treturn queryTree.xor(0, firstOcc[n1] + 1) ^ queryTree.xor(0, firstOcc[n2] + 1) ^ enjoyment[LCA(n1, n2)];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic void set(int node, int val) {\\r\\n\\t\\t\\tenjoyment[node] = val;\\r\\n\\t\\t\\tqueryTree.set(firstOcc[node], val);\\r\\n\\t\\t\\tqueryTree.set(lastOcc[node], val);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpublic int LCA(int n1, int n2) {\\r\\n\\t\\t\\tint p1 = firstOcc[n1];\\r\\n\\t\\t\\tint p2 = firstOcc[n2];\\r\\n\\t\\t\\tif (p1 > p2) {  // see which one occurs first because of the minimum thing\\r\\n\\t\\t\\t\\tint temp = p1;\\r\\n\\t\\t\\t\\tp1 = p2;\\r\\n\\t\\t\\t\\tp2 = temp;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn LCATree.min(p1, p2 + 1);  // + 1 because of the bounds of min()\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tprivate void eulerTour() {  // i could just put this in the constructor but this makes it look better\\r\\n\\t\\t\\tArrayDeque<int[]> frontier = new ArrayDeque<>(Collections.singletonList(new int[]{0, -1, 0}));\\r\\n\\t\\t\\tHashSet<Integer> visited = new HashSet<>();\\r\\n\\t\\t\\tint[] parent = new int[nodes];\\r\\n\\t\\t\\twhile (!frontier.isEmpty()) {\\r\\n\\t\\t\\t\\tint[] curr = frontier.removeFirst();\\r\\n\\t\\t\\t\\teulerTour.add(curr[0]);\\r\\n\\t\\t\\t\\tif (curr[0] == -1 || visited.contains(curr[0])) {\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvisited.add(curr[0]);\\r\\n\\t\\t\\t\\theight[curr[0]] = curr[2];\\r\\n\\t\\t\\t\\tfirstOcc[curr[0]] = eulerTour.size() - 1;  // -1 because of that .add(curr[0]) above\\r\\n\\t\\t\\t\\tif (curr[0] != 0) {\\r\\n\\t\\t\\t\\t\\tfrontier.addFirst(new int[]{curr[1], parent[curr[1]], curr[2] - 1});\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tboolean isLeaf = true;  // i know i could like check the amt of neighbors but this is somehow faster\\r\\n\\t\\t\\t\\tfor (int n : neighbors[curr[0]]) {\\r\\n\\t\\t\\t\\t\\tif (n != curr[1]) {  // visit all children (don't process the parent)\\r\\n\\t\\t\\t\\t\\t\\tparent[n] = curr[0];\\r\\n\\t\\t\\t\\t\\t\\tfrontier.addFirst(new int[]{n, curr[0], curr[2] + 1});\\r\\n\\t\\t\\t\\t\\t\\tisLeaf = false;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (isLeaf) {\\r\\n\\t\\t\\t\\t\\teulerTour.add(curr[0]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tlong start = System.currentTimeMillis();\\r\\n\\t\\tBufferedReader read = new BufferedReader(new FileReader(\\\"cowland.in\\\"));\\r\\n\\t\\tStringTokenizer initial = new StringTokenizer(read.readLine());\\r\\n\\t\\tint placeNum = Integer.parseInt(initial.nextToken());\\r\\n\\t\\tint queryNum = Integer.parseInt(initial.nextToken());\\r\\n\\t\\tint[] initialVals = Arrays.stream(read.readLine().split(\\\" \\\")).mapToInt(Integer::parseInt).toArray();\\r\\n\\t\\tArrayList<Integer>[] neighbors = new ArrayList[placeNum];\\r\\n\\t\\tfor (int p = 0; p < placeNum; p++) {\\r\\n\\t\\t\\tneighbors[p] = new ArrayList<>();\\r\\n\\t\\t}\\r\\n\\t\\tfor (int i = 0; i < placeNum - 1; i++) {\\r\\n\\t\\t\\tint[] route = Arrays.stream(read.readLine().split(\\\" \\\")).mapToInt(j -> Integer.parseInt(j) - 1).toArray();\\r\\n\\t\\t\\tneighbors[route[0]].add(route[1]);\\r\\n\\t\\t\\tneighbors[route[1]].add(route[0]);\\r\\n\\t\\t}\\r\\n\\t\\tAmusementPark park = new AmusementPark(neighbors, initialVals);\\r\\n\\t\\tPrintWriter written = new PrintWriter(\\\"cowland.out\\\");\\r\\n\\t\\tfor (int q = 0; q < queryNum; q++) {\\r\\n\\t\\t\\tint[] query = Arrays.stream(read.readLine().split(\\\" \\\")).mapToInt(Integer::parseInt).toArray();\\r\\n\\t\\t\\tswitch (query[0]) {\\r\\n\\t\\t\\t\\tcase 1:\\r\\n\\t\\t\\t\\t\\tpark.set(query[1] - 1, query[2]);\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\tcase 2:\\r\\n\\t\\t\\t\\t\\tint happiness = park.query(query[1] - 1, query[2] - 1);\\r\\n\\t\\t\\t\\t\\t// System.out.println(happiness);  // <- adding this makes the thing too slow lol\\r\\n\\t\\t\\t\\t\\twritten.println(happiness);\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\t\\tthrow new IllegalArgumentException(\\\"what kind of query is \\\" + Arrays.toString(query) + \\\" lol\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\twritten.close();\\r\\n\\t\\tSystem.out.printf(\\\"time: %d ms%n\\\", System.currentTimeMillis() - start);\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-921","source":"USACO Gold 2019 February","title":"Cow Land","author":"Albert Ye"},"parent":{"name":"usaco-921","relativePath":"usaco-921.mdx"},"toc":{"cpp":[{"depth":2,"value":"Euler Tour Technique","slug":"euler-tour-technique"},{"depth":2,"value":"Binary Indexed Tree","slug":"binary-indexed-tree"},{"depth":2,"value":"Responding to Queries","slug":"responding-to-queries"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Euler Tour Technique","slug":"euler-tour-technique"},{"depth":2,"value":"Binary Indexed Tree","slug":"binary-indexed-tree"},{"depth":2,"value":"Responding to Queries","slug":"responding-to-queries"}],"py":[{"depth":2,"value":"Euler Tour Technique","slug":"euler-tour-technique"},{"depth":2,"value":"Binary Indexed Tree","slug":"binary-indexed-tree"},{"depth":2,"value":"Responding to Queries","slug":"responding-to-queries"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"tree-euler","title":"Euler Tour Technique"}}}},{"node":{"module":{"frontmatter":{"id":"hld","title":"Heavy-Light Decomposition"}}}}]},"problemInfo":{"uniqueId":"usaco-921","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=921"}},"pageContext":{"id":"usaco-921"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}