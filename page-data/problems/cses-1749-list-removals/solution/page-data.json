{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1749-list-removals/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1749\", source = \"CSES\", title = \"List Removals\", author = \"Benjamin Qi\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\")\n  }, _props.components), {HeaderLink, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"solution-1\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 1\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Use a\\r\\n\", _jsx(_components.a, {\n        href: \"https://github.com/bqi343/USACO/blob/master/Implementations/content/data-structures/STL%20(5)/Rope.h\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"rope\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <ext/rope>\\r\\n#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\nusing namespace __gnu_cxx;\\r\\n\\r\\nusing ll = long long;\\r\\nusing ld = long double;\\r\\nusing db = double;\\r\\nusing str = string; // yay python!\\r\\n\\r\\nusing pi = pair<int,int>;\\r\\nusing pl = pair<ll,ll>;\\r\\nusing pd = pair<db,db>;\\r\\n\\r\\nusing vi = vector<int>;\\r\\nusing vb = vector<bool>;\\r\\nusing vl = vector<ll>;\\r\\nusing vd = vector<db>;\\r\\nusing vs = vector<str>;\\r\\nusing vpi = vector<pi>;\\r\\nusing vpl = vector<pl>;\\r\\nusing vpd = vector<pd>;\\r\\n\\r\\n#define tcT template<class T\\r\\n#define tcTU tcT, class U\\r\\n// ^ lol this makes everything look weird but I'll try it\\r\\ntcT> using V = vector<T>;\\r\\ntcT, size_t SZ> using AR = array<T,SZ>;\\r\\ntcT> using PR = pair<T,T>;\\r\\n\\r\\n// pairs\\r\\n#define mp make_pair\\r\\n#define f first\\r\\n#define s second\\r\\n\\r\\n// vectors\\r\\n// oops size(x), rbegin(x), rend(x) need C++17\\r\\n#define sz(x) int((x).size())\\r\\n#define bg(x) begin(x)\\r\\n#define all(x) bg(x), end(x)\\r\\n#define rall(x) x.rbegin(), x.rend()\\r\\n#define sor(x) sort(all(x))\\r\\n#define rsz resize\\r\\n#define ins insert\\r\\n#define ft front()\\r\\n#define bk back()\\r\\n#define pb push_back\\r\\n#define eb emplace_back\\r\\n#define pf push_front\\r\\n\\r\\n#define lb lower_bound\\r\\n#define ub upper_bound\\r\\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\\r\\n\\r\\n// loops\\r\\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\\r\\n#define F0R(i,a) FOR(i,0,a)\\r\\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\\r\\n#define R0F(i,a) ROF(i,0,a)\\r\\n#define trav(a,x) for (auto& a: x)\\r\\n\\r\\nconst int MOD = 1e9+7; // 998244353;\\r\\nconst int MX = 2e5+5;\\r\\nconst ll INF = 1e18; // not too close to LLONG_MAX\\r\\nconst ld PI = acos((ld)-1);\\r\\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\\r\\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\\r\\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\\r\\n\\r\\n// bitwise ops\\r\\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\\r\\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\\r\\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\\r\\n\\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x))\\r\\nconstexpr int p2(int x) { return 1<<x; }\\r\\nconstexpr int msk2(int x) { return p2(x)-1; }\\r\\n\\r\\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\\r\\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\\r\\n\\r\\ntcT> bool ckmin(T& a, const T& b) {\\r\\n\\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\\r\\ntcT> bool ckmax(T& a, const T& b) {\\r\\n\\treturn a < b ? a = b, 1 : 0; }\\r\\n\\r\\ntcTU> T fstTrue(T lo, T hi, U f) {\\r\\n\\thi ++; assert(lo <= hi); // assuming f is increasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo)/2;\\r\\n\\t\\tf(mid) ? hi = mid : lo = mid+1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcTU> T lstTrue(T lo, T hi, U f) {\\r\\n\\tlo --; assert(lo <= hi); // assuming f is decreasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo+1)/2;\\r\\n\\t\\tf(mid) ? lo = mid : hi = mid-1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\\r\\n\\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\\r\\ntcTU> void erase(T& t, const U& u) { // don't erase\\r\\n\\tauto it = t.find(u); assert(it != end(t));\\r\\n\\tt.erase(it); } // element that doesn't exist from (multi)set\\r\\n\\r\\n// INPUT\\r\\n#define tcTUU tcT, class ...U\\r\\ntcT> void re(complex<T>& c);\\r\\ntcTU> void re(pair<T,U>& p);\\r\\ntcT> void re(V<T>& v);\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& a);\\r\\n\\r\\ntcT> void re(T& x) { cin >> x; }\\r\\nvoid re(db& d) { str t; re(t); d = stod(t); }\\r\\nvoid re(ld& d) { str t; re(t); d = stold(t); }\\r\\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\\r\\n\\r\\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\\r\\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\\r\\ntcT> void re(V<T>& x) { trav(a,x) re(a); }\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\\r\\ntcT> void rv(int n, V<T>& x) { x.rsz(n); re(x); }\\r\\n\\r\\n// TO_STRING\\r\\n#define ts to_string\\r\\nstr ts(char c) { return str(1,c); }\\r\\nstr ts(const char* s) { return (str)s; }\\r\\nstr ts(str s) { return s; }\\r\\nstr ts(bool b) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn b ? \\\"true\\\" : \\\"false\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts((int)b);\\r\\n\\t#endif\\r\\n}\\r\\ntcT> str ts(complex<T> c) {\\r\\n\\tstringstream ss; ss << c; return ss.str(); }\\r\\nstr ts(V<bool> v) {\\r\\n\\tstr res = \\\"{\\\"; F0R(i,sz(v)) res += char('0'+v[i]);\\r\\n\\tres += \\\"}\\\"; return res; }\\r\\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\\r\\n\\tstr res = \\\"\\\"; F0R(i,SZ) res += char('0'+b[i]);\\r\\n\\treturn res; }\\r\\ntcTU> str ts(pair<T,U> p);\\r\\ntcT> str ts(T v) { // containers with begin(), end()\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\tbool fst = 1; str res = \\\"{\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\", \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\tres += \\\"}\\\"; return res;\\r\\n\\t#else\\r\\n\\t\\tbool fst = 1; str res = \\\"\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\" \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\treturn res;\\r\\n\\r\\n\\t#endif\\r\\n}\\r\\ntcTU> str ts(pair<T,U> p) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn \\\"(\\\"+ts(p.f)+\\\", \\\"+ts(p.s)+\\\")\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts(p.f)+\\\" \\\"+ts(p.s);\\r\\n\\t#endif\\r\\n}\\r\\n\\r\\n// OUTPUT\\r\\ntcT> void pr(T x) { cout << ts(x); }\\r\\ntcTUU> void pr(const T& t, const U&... u) {\\r\\n\\tpr(t); pr(u...); }\\r\\nvoid ps() { pr(\\\"\\\\n\\\"); } // print w/ spaces\\r\\ntcTUU> void ps(const T& t, const U&... u) {\\r\\n\\tpr(t); if (sizeof...(u)) pr(\\\" \\\"); ps(u...); }\\r\\n\\r\\n// DEBUG\\r\\nvoid DBG() { cerr << \\\"]\\\" << endl; }\\r\\ntcTUU> void DBG(const T& t, const U&... u) {\\r\\n\\tcerr << ts(t); if (sizeof...(u)) cerr << \\\", \\\";\\r\\n\\tDBG(u...); }\\r\\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\\r\\n\\t#define dbg(...) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> [\\\" << #__VA_ARGS__ << \\\"]: [\\\", DBG(__VA_ARGS__)\\r\\n\\t#define chk(...) if (!(__VA_ARGS__)) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> function(\\\" \\\\\\r\\n\\t\\t << __FUNCTION__  << \\\") -> CHK FAILED: (\\\" << #__VA_ARGS__ << \\\")\\\" << \\\"\\\\n\\\", exit(0);\\r\\n#else\\r\\n\\t#define dbg(...) 0\\r\\n\\t#define chk(...) 0\\r\\n#endif\\r\\n\\r\\nvoid setPrec() { cout << fixed << setprecision(15); }\\r\\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\\r\\n// FILE I/O\\r\\nvoid setIn(str s) { freopen(s.c_str(),\\\"r\\\",stdin); }\\r\\nvoid setOut(str s) { freopen(s.c_str(),\\\"w\\\",stdout); }\\r\\nvoid setIO(str s = \\\"\\\") {\\r\\n\\tunsyncIO(); setPrec();\\r\\n\\t// cin.exceptions(cin.failbit);\\r\\n\\t// throws exception when do smth illegal\\r\\n\\t// ex. try to read letter into int\\r\\n\\tif (sz(s)) setIn(s+\\\".in\\\"), setOut(s+\\\".out\\\"); // for USACO\\r\\n}\\r\\n\\r\\nint n;\\r\\nrope<int> x;\\r\\n\\r\\nint main() {\\r\\n    setIO(); re(n);\\r\\n    F0R(i,n) {\\r\\n        int t; re(t);\\r\\n        x.pb(t);\\r\\n    }\\r\\n    F0R(i,n) {\\r\\n        int p; re(p); --p;\\r\\n        pr(x[p],' ');\\r\\n        x.erase(x.mutable_begin()+p);\\r\\n    }\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-2\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-2\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 2\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Use an indexed set.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\n#include <ext/pb_ds/assoc_container.hpp>\\r\\nusing namespace __gnu_pbds;\\r\\n\\r\\ntemplate<class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\r\\n\\r\\nint main () {\\r\\n\\tint n;\\r\\n\\tcin >> n;\\r\\n\\tTree<int> ist;\\r\\n\\tvector<int> p(n);\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tist.insert(i);\\r\\n\\t\\tcin >> p[i];\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tint ind;\\r\\n\\t\\tcin >> ind;\\r\\n\\t\\tind--;\\r\\n\\t\\tint pos = *ist.find_by_order(ind);\\r\\n\\t\\tist.erase(pos);\\r\\n\\t\\tcout << p[pos] << (i == n - 1 ? '\\\\n' : ' ');\\r\\n\\t}\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-3\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-3\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 3\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Binary search on a BIT.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nusing ll = long long;\\r\\nusing ld = long double;\\r\\nusing db = double;\\r\\nusing str = string; // yay python!\\r\\n\\r\\nusing pi = pair<int,int>;\\r\\nusing pl = pair<ll,ll>;\\r\\nusing pd = pair<db,db>;\\r\\n\\r\\nusing vi = vector<int>;\\r\\nusing vb = vector<bool>;\\r\\nusing vl = vector<ll>;\\r\\nusing vd = vector<db>;\\r\\nusing vs = vector<str>;\\r\\nusing vpi = vector<pi>;\\r\\nusing vpl = vector<pl>;\\r\\nusing vpd = vector<pd>;\\r\\n\\r\\n#define tcT template<class T\\r\\n#define tcTU tcT, class U\\r\\n// ^ lol this makes everything look weird but I'll try it\\r\\ntcT> using V = vector<T>;\\r\\ntcT, size_t SZ> using AR = array<T,SZ>;\\r\\ntcT> using PR = pair<T,T>;\\r\\n\\r\\n// pairs\\r\\n#define mp make_pair\\r\\n#define f first\\r\\n#define s second\\r\\n\\r\\n// vectors\\r\\n// oops size(x), rbegin(x), rend(x) need C++17\\r\\n#define sz(x) int((x).size())\\r\\n#define bg(x) begin(x)\\r\\n#define all(x) bg(x), end(x)\\r\\n#define rall(x) x.rbegin(), x.rend()\\r\\n#define sor(x) sort(all(x))\\r\\n#define rsz resize\\r\\n#define ins insert\\r\\n#define ft front()\\r\\n#define bk back()\\r\\n#define pb push_back\\r\\n#define eb emplace_back\\r\\n#define pf push_front\\r\\n\\r\\n#define lb lower_bound\\r\\n#define ub upper_bound\\r\\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\\r\\n\\r\\n// loops\\r\\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\\r\\n#define F0R(i,a) FOR(i,0,a)\\r\\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\\r\\n#define R0F(i,a) ROF(i,0,a)\\r\\n#define trav(a,x) for (auto& a: x)\\r\\n\\r\\nconst int MOD = 1e9+7; // 998244353;\\r\\nconst int MX = 2e5+5;\\r\\nconst ll INF = 1e18; // not too close to LLONG_MAX\\r\\nconst ld PI = acos((ld)-1);\\r\\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\\r\\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\\r\\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\\r\\n\\r\\n// bitwise ops\\r\\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\\r\\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\\r\\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\\r\\n\\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x))\\r\\nconstexpr int p2(int x) { return 1<<x; }\\r\\nconstexpr int msk2(int x) { return p2(x)-1; }\\r\\n\\r\\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\\r\\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\\r\\n\\r\\ntcT> bool ckmin(T& a, const T& b) {\\r\\n\\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\\r\\ntcT> bool ckmax(T& a, const T& b) {\\r\\n\\treturn a < b ? a = b, 1 : 0; }\\r\\n\\r\\ntcTU> T fstTrue(T lo, T hi, U f) {\\r\\n\\thi ++; assert(lo <= hi); // assuming f is increasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo)/2;\\r\\n\\t\\tf(mid) ? hi = mid : lo = mid+1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcTU> T lstTrue(T lo, T hi, U f) {\\r\\n\\tlo --; assert(lo <= hi); // assuming f is decreasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo+1)/2;\\r\\n\\t\\tf(mid) ? lo = mid : hi = mid-1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\\r\\n\\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\\r\\ntcTU> void erase(T& t, const U& u) { // don't erase\\r\\n\\tauto it = t.find(u); assert(it != end(t));\\r\\n\\tt.erase(it); } // element that doesn't exist from (multi)set\\r\\n\\r\\n// INPUT\\r\\n#define tcTUU tcT, class ...U\\r\\ntcT> void re(complex<T>& c);\\r\\ntcTU> void re(pair<T,U>& p);\\r\\ntcT> void re(V<T>& v);\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& a);\\r\\n\\r\\ntcT> void re(T& x) { cin >> x; }\\r\\nvoid re(db& d) { str t; re(t); d = stod(t); }\\r\\nvoid re(ld& d) { str t; re(t); d = stold(t); }\\r\\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\\r\\n\\r\\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\\r\\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\\r\\ntcT> void re(V<T>& x) { trav(a,x) re(a); }\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\\r\\ntcT> void rv(int n, V<T>& x) { x.rsz(n); re(x); }\\r\\n\\r\\n// TO_STRING\\r\\n#define ts to_string\\r\\nstr ts(char c) { return str(1,c); }\\r\\nstr ts(const char* s) { return (str)s; }\\r\\nstr ts(str s) { return s; }\\r\\nstr ts(bool b) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn b ? \\\"true\\\" : \\\"false\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts((int)b);\\r\\n\\t#endif\\r\\n}\\r\\ntcT> str ts(complex<T> c) {\\r\\n\\tstringstream ss; ss << c; return ss.str(); }\\r\\nstr ts(V<bool> v) {\\r\\n\\tstr res = \\\"{\\\"; F0R(i,sz(v)) res += char('0'+v[i]);\\r\\n\\tres += \\\"}\\\"; return res; }\\r\\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\\r\\n\\tstr res = \\\"\\\"; F0R(i,SZ) res += char('0'+b[i]);\\r\\n\\treturn res; }\\r\\ntcTU> str ts(pair<T,U> p);\\r\\ntcT> str ts(T v) { // containers with begin(), end()\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\tbool fst = 1; str res = \\\"{\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\", \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\tres += \\\"}\\\"; return res;\\r\\n\\t#else\\r\\n\\t\\tbool fst = 1; str res = \\\"\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\" \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\treturn res;\\r\\n\\r\\n\\t#endif\\r\\n}\\r\\ntcTU> str ts(pair<T,U> p) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn \\\"(\\\"+ts(p.f)+\\\", \\\"+ts(p.s)+\\\")\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts(p.f)+\\\" \\\"+ts(p.s);\\r\\n\\t#endif\\r\\n}\\r\\n\\r\\n// OUTPUT\\r\\ntcT> void pr(T x) { cout << ts(x); }\\r\\ntcTUU> void pr(const T& t, const U&... u) {\\r\\n\\tpr(t); pr(u...); }\\r\\nvoid ps() { pr(\\\"\\\\n\\\"); } // print w/ spaces\\r\\ntcTUU> void ps(const T& t, const U&... u) {\\r\\n\\tpr(t); if (sizeof...(u)) pr(\\\" \\\"); ps(u...); }\\r\\n\\r\\n// DEBUG\\r\\nvoid DBG() { cerr << \\\"]\\\" << endl; }\\r\\ntcTUU> void DBG(const T& t, const U&... u) {\\r\\n\\tcerr << ts(t); if (sizeof...(u)) cerr << \\\", \\\";\\r\\n\\tDBG(u...); }\\r\\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\\r\\n\\t#define dbg(...) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> [\\\" << #__VA_ARGS__ << \\\"]: [\\\", DBG(__VA_ARGS__)\\r\\n\\t#define chk(...) if (!(__VA_ARGS__)) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> function(\\\" \\\\\\r\\n\\t\\t << __FUNCTION__  << \\\") -> CHK FAILED: (\\\" << #__VA_ARGS__ << \\\")\\\" << \\\"\\\\n\\\", exit(0);\\r\\n#else\\r\\n\\t#define dbg(...) 0\\r\\n\\t#define chk(...) 0\\r\\n#endif\\r\\n\\r\\nvoid setPrec() { cout << fixed << setprecision(15); }\\r\\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\\r\\n// FILE I/O\\r\\nvoid setIn(str s) { freopen(s.c_str(),\\\"r\\\",stdin); }\\r\\nvoid setOut(str s) { freopen(s.c_str(),\\\"w\\\",stdout); }\\r\\nvoid setIO(str s = \\\"\\\") {\\r\\n\\tunsyncIO(); setPrec();\\r\\n\\t// cin.exceptions(cin.failbit);\\r\\n\\t// throws exception when do smth illegal\\r\\n\\t// ex. try to read letter into int\\r\\n\\tif (sz(s)) setIn(s+\\\".in\\\"), setOut(s+\\\".out\\\"); // for USACO\\r\\n}\\r\\n\\r\\n/**\\r\\n * Description: range sum queries and point updates for $D$ dimensions\\r\\n * Source: https://codeforces.com/blog/entry/64914\\r\\n * Verification: SPOJ matsum\\r\\n * Usage: \\\\texttt{BIT<int,10,10>} gives 2D BIT\\r\\n * Time: O((\\\\log N)^D)\\r\\n */\\r\\n\\r\\ntemplate <class T, int ...Ns> struct BIT {\\r\\n\\tT val = 0; void upd(T v) { val += v; }\\r\\n\\tT query() { return val; }\\r\\n};\\r\\ntemplate <class T, int N, int... Ns> struct BIT<T, N, Ns...> {\\r\\n\\tBIT<T,Ns...> bit[N+1];\\r\\n\\ttemplate<typename... Args> void upd(int pos, Args... args) { assert(pos > 0);\\r\\n\\t\\tfor (; pos<=N; pos+=pos&-pos) bit[pos].upd(args...); }\\r\\n\\ttemplate<typename... Args> T sum(int r, Args... args) {\\r\\n\\t\\tT res=0; for (;r;r-=r&-r) res += bit[r].query(args...);\\r\\n\\t\\treturn res; }\\r\\n\\ttemplate<typename... Args> T query(int l, int r, Args...\\r\\n\\t\\targs) { return sum(r,args...)-sum(l-1,args...); }\\r\\n};\\r\\ntemplate<class T, int N> int get_kth(const BIT<T,N>& bit, T des) {\\r\\n\\tassert(des > 0);\\r\\n\\tint ind = 0;\\r\\n\\tfor (int i = 1<<bits(N); i; i /= 2)\\r\\n\\t\\tif (ind+i <= N && bit.bit[ind+i].val < des)\\r\\n\\t\\t\\tdes -= bit.bit[ind += i].val;\\r\\n\\tassert(ind < N); return ind+1;\\r\\n}\\r\\n\\r\\nBIT<int,MX> B;\\r\\n\\r\\nint N;\\r\\n\\r\\nint main() {\\r\\n\\tsetIO(); re(N);\\r\\n\\tvi x(N); re(x);\\r\\n\\tFOR(i,1,N+1) B.upd(i,1);\\r\\n\\tF0R(_,N) {\\r\\n\\t\\tint p; re(p);\\r\\n\\t\\tint ind = get_kth(B,p);\\r\\n\\t\\tpr(x[ind-1],' ');\\r\\n\\t\\tB.upd(ind,-1);\\r\\n\\t}\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-4\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-4\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 4\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Use a segment tree to store the number of elements present in each segment and\\r\\n\", _jsx(_components.a, {\n        href: \"/plat/seg-ext#walking-on-a-segment-tree\",\n        children: \"walk down it\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <algorithm>\\r\\nusing namespace std;\\r\\n\\r\\nstruct node;\\r\\n\\r\\nvector<int> information; // stores the actual array with our data in\\r\\n\\r\\nvector<int> results;\\r\\n\\r\\nstruct node {\\r\\n\\t// left child manages data from left to midpoint\\r\\n\\t// right child manages data from midpoint+1 to right\\r\\n\\tint left, right, midpoint;\\r\\n\\tnode* left_child;\\r\\n\\tnode* right_child;\\r\\n\\tnode* parent;\\r\\n\\tint count; // stores the number of elements in the subtree\\r\\n\\tnode(int left, int right, node* parent) : left(left), right(right), midpoint((left+right)/2), parent(parent) {\\r\\n\\t\\tif (left != right) {\\r\\n\\t\\t\\tleft_child = new node(left, midpoint, this);\\r\\n\\t\\t\\tright_child = new node(midpoint+1, right, this);\\r\\n\\t\\t\\tcount = left_child->count + right_child->count;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tcount = 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// this function deletes index'th element in the subtree and also removes\\r\\n\\t// one from the count\\r\\n\\tvoid del(int index) {\\r\\n\\t\\t// Uncomment the following line to see how it traverses the segment tree\\r\\n\\t\\t// cout << \\\"left: \\\" << left << \\\" right: \\\" << right << \\\" count: \\\" << count << \\\" ind: \\\" << index << endl;\\r\\n\\t\\tif (count < index) {\\r\\n\\t\\t\\tthrow std::runtime_error(\\\"Element doesn't exist\\\");\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tcount--;\\r\\n\\t\\t\\tif (left == right) {\\r\\n\\t\\t\\t\\tresults.push_back(information[left]);\\r\\n\\t\\t\\t} else if (left_child->count > index) {\\r\\n\\t\\t\\t\\tleft_child->del(index);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tright_child->del(index - left_child->count);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n};\\r\\n\\r\\n\\r\\nint main() {\\r\\n\\tint n;\\r\\n\\tcin >> n;\\r\\n\\tinformation.resize(n);\\r\\n\\tfor (auto& i : information) cin >> i;\\r\\n\\r\\n\\tnode root(0, n-1, nullptr);\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tint index;\\r\\n\\t\\tcin >> index;\\r\\n\\t\\tindex--; // 1-indexed to 0-indexed\\r\\n\\t\\troot.del(index);\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tcout << results[i] << \\\" \\\\n\\\"[i == n-1];\\r\\n\\t}\\r\\n}\\n\"\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1749","source":"CSES","title":"List Removals","author":"Benjamin Qi"},"parent":{"name":"cses-1749","relativePath":"cses-1749.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2","slug":"solution-2"},{"depth":2,"value":"Solution 3","slug":"solution-3"},{"depth":2,"value":"Solution 4","slug":"solution-4"}],"java":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2","slug":"solution-2"},{"depth":2,"value":"Solution 3","slug":"solution-3"},{"depth":2,"value":"Solution 4","slug":"solution-4"}],"py":[{"depth":2,"value":"Solution 1","slug":"solution-1"},{"depth":2,"value":"Solution 2","slug":"solution-2"},{"depth":2,"value":"Solution 3","slug":"solution-3"},{"depth":2,"value":"Solution 4","slug":"solution-4"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"PURS","title":"Point Update Range Sum"}}}}]},"problemInfo":{"uniqueId":"cses-1749","url":"https://cses.fi/problemset/task/1749"}},"pageContext":{"id":"cses-1749"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}