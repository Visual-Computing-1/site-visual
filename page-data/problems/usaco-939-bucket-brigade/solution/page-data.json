{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-939-bucket-brigade/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-939\", source = \"USACO Bronze 2019 Open\", title = \"Bucket Brigade\", author = \"Maggie Liu\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    PySection: _missingComponent(\"PySection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, JavaSection, PySection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_buckets_bronze_open19.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"explanation\",\n      children: [_jsx(_components.a, {\n        href: \"#explanation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Explanation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If there was no rock, then the number of cows needed would just be the\\r\\nhorizontal distance between the barn and the lake, plus the vertical distance\\r\\nbetween the barn and the lake, minus \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \". Adding the rock onto the farm usually\\r\\ndoesn't change the answer. The only case where the rock matters is if the rock,\\r\\nbarn and lake are on the same line, and the rock is between the barn and the\\r\\nlake. In this case, there will need to be \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"2\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\\\"application/x-tex\\\">2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">2</span></span></span></span>\"\n      }), \" extra cows to go around the rock.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <cstdio>\\r\\nusing namespace std;\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tfreopen(\\\"buckets.in\\\", \\\"r\\\", stdin);\\r\\n\\tfreopen(\\\"buckets.out\\\", \\\"w\\\", stdout);\\r\\n\\tint barn_i = 0, barn_j = 0, rock_i = 0, rock_j = 0, lake_i = 0, lake_j = 0;\\r\\n\\tfor (int i = 0; i < 10; i++)\\r\\n\\t{\\r\\n\\t\\tstring row;\\r\\n\\t\\tcin >> row;\\r\\n\\t\\tfor (int j = 0; j < 10; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif (row[j] == 'B')\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tbarn_i = i;\\r\\n\\t\\t\\t\\tbarn_j = j;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse if (row[j] == 'R')\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\trock_i = i;\\r\\n\\t\\t\\t\\trock_j = j;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse if (row[j] == 'L')\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tlake_i = i;\\r\\n\\t\\t\\t\\tlake_j = j;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// initial distance\\r\\n\\tint cows = abs(barn_i - lake_i) + abs(barn_j - lake_j) - 1;\\r\\n\\r\\n\\t// if the barn, lake and rock are in the same column\\r\\n\\t// and the rock is betwen the barn and the lake\\r\\n\\tif (barn_i == lake_i && rock_i == barn_i\\r\\n\\t\\t\\t&& ((lake_j < rock_j && rock_j < barn_j)\\r\\n\\t\\t\\t\\t|| (barn_j < rock_j && rock_j < lake_j)))\\r\\n\\t{\\r\\n\\t\\tcows += 2;\\r\\n\\t}\\r\\n\\t// if the barn, lake and rock are in the same row\\r\\n\\t// and the rock is between the barn and the lake\\r\\n\\telse if (barn_j == lake_j && rock_j == barn_j\\r\\n\\t\\t\\t\\t&& ((lake_i < rock_i && rock_i < barn_i)\\r\\n\\t\\t\\t\\t\\t|| (barn_i < rock_i && rock_i < lake_i)))\\r\\n\\t{\\r\\n\\t\\tcows += 2;\\r\\n\\t}\\r\\n\\tcout << cows << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class BucketBrigade\\r\\n{\\r\\n\\tpublic static void main(String[] args) throws IOException\\r\\n\\t{\\r\\n\\t\\tint barnI = 0, barnJ = 0, rockI = 0, rockJ = 0, lakeI = 0, lakeJ = 0;\\r\\n\\t\\tKattio io = new Kattio(\\\"buckets\\\");\\r\\n\\t\\tfor (int i = 0; i < 10; i++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tString row = io.next();\\r\\n\\t\\t\\tfor (int j = 0; j < 10; j++)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif (row.charAt(j) == 'B')\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tbarnI = i;\\r\\n\\t\\t\\t\\t\\tbarnJ = j;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\telse if (row.charAt(j) == 'R')\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\trockI = i;\\r\\n\\t\\t\\t\\t\\trockJ = j;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\telse if (row.charAt(j) == 'L')\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tlakeI = i;\\r\\n\\t\\t\\t\\t\\tlakeJ = j;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// distance without accounting for the rock\\r\\n\\t\\tint cows = Math.abs(barnI - lakeI) + Math.abs(barnJ - lakeJ) - 1;\\r\\n\\r\\n\\t\\t// if the barn, lake and rock are in the same row\\r\\n\\t\\t// and the rock is betwen the barn and the lake\\r\\n\\t\\tif (barnI == lakeI && barnI == rockI\\r\\n\\t\\t\\t\\t&& ((lakeJ < rockJ && rockJ < barnJ)\\r\\n\\t\\t\\t\\t\\t|| (barnJ < rockJ && rockJ < lakeJ)))\\r\\n\\t\\t{\\r\\n\\t\\t\\tcows += 2;\\r\\n\\t\\t}\\r\\n\\t\\t// if the barn, lake and rock are in the same column\\r\\n\\t\\t// and the rock is between the barn and the lake\\r\\n\\t\\telse if (barnJ == lakeJ && barnJ == rockJ\\r\\n\\t\\t\\t\\t\\t&& ((lakeI < rockI && rockI < barnI)\\r\\n\\t\\t\\t\\t\\t\\t|| (barnI < rockI && rockI < lakeI)))\\r\\n\\t\\t{\\r\\n\\t\\t\\tcows += 2;\\r\\n\\t\\t}\\r\\n\\t\\tio.println(cows);\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\nsys.stdin = open(\\\"buckets.in\\\", \\\"r\\\")\\r\\nsys.stdout = open(\\\"buckets.out\\\", \\\"w\\\")\\r\\n\\r\\nfor i in range(10):\\r\\n\\trow = input()\\r\\n\\tfor j in range(10):\\r\\n\\t\\tif row[j] == \\\"B\\\":\\r\\n\\t\\t\\tbarn_i = i\\r\\n\\t\\t\\tbarn_j = j\\r\\n\\t\\tif row[j] == \\\"R\\\":\\r\\n\\t\\t\\trock_i = i\\r\\n\\t\\t\\trock_j = j\\r\\n\\t\\tif row[j] == \\\"L\\\":\\r\\n\\t\\t\\tlake_i = i\\r\\n\\t\\t\\tlake_j = j\\r\\n\\r\\n# distance without accounting for the rock\\r\\ncows = abs(barn_i - lake_i) + abs(barn_j - lake_j) - 1\\r\\n\\r\\n# if the barn, lake and rock are in the same row\\r\\n# and the rock is betwen the barn and the lake\\r\\nif (barn_i == rock_i == lake_i and\\r\\n\\t\\t(lake_j < rock_j < barn_j or barn_j < rock_j < lake_j)):\\r\\n\\tcows += 2\\r\\n# if the barn, lake and rock are in the same column\\r\\n# and the rock is between the barn and the lake\\r\\nelif (barn_j == rock_j == lake_j and\\r\\n\\t\\t(lake_i < rock_i < barn_i or barn_i < rock_i < lake_i)):\\r\\n\\tcows += 2\\r\\nprint(cows)\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-939","source":"USACO Bronze 2019 Open","title":"Bucket Brigade","author":"Maggie Liu"},"parent":{"name":"usaco-939","relativePath":"usaco-939.mdx"},"toc":{"cpp":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"expected-knowledge","title":"Expected Knowledge"}}}}]},"problemInfo":{"uniqueId":"usaco-939","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=939"}},"pageContext":{"id":"usaco-939"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}