{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-berland-federalization/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cf-440D\", source = \"CF\", title = \"Berland Federalization\", author = \"Kevin Sheng\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    br: \"br\",\n    ol: \"ol\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    MATHDIV: _missingComponent(\"MATHDIV\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {MATHSPAN, MATHDIV, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Let's define \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{best}[n][k]\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">best</mtext><mo stretchy=\\\"false\\\">[</mo><mi>n</mi><mo stretchy=\\\"false\\\">]</mo><mo stretchy=\\\"false\\\">[</mo><mi>k</mi><mo stretchy=\\\"false\\\">]</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{best}[n][k]</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">best</span></span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">]</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span><span class=\\\"mclose\\\">]</span></span></span></span>\"\n      }), \" as the smallest edge set that connects a subtree of size \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"k\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\\\"application/x-tex\\\">k</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span></span></span></span>\"\n      }), \" rooted at node \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" to the rest of the tree (It's undefined if such a subtree is impossible).\\r\\nThe base cases for any node are as follows:\"]\n    }), \"\\n\", _jsx(MATHDIV, {\n      className: \"math math-display\",\n      latex: \"\\\\texttt{best}[n][0] = \\\\{\\\\}\",\n      children: \"<span class=\\\"katex-display\\\"><span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\" display=\\\"block\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">best</mtext><mo stretchy=\\\"false\\\">[</mo><mi>n</mi><mo stretchy=\\\"false\\\">]</mo><mo stretchy=\\\"false\\\">[</mo><mn>0</mn><mo stretchy=\\\"false\\\">]</mo><mo>=</mo><mo stretchy=\\\"false\\\">{</mo><mo stretchy=\\\"false\\\">}</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{best}[n][0] = \\\\{\\\\}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">best</span></span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">]</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord\\\">0</span><span class=\\\"mclose\\\">]</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">{</span><span class=\\\"mclose\\\">}</span></span></span></span></span>\"\n    }), \"\\n\", _jsx(MATHDIV, {\n      className: \"math math-display\",\n      latex: \"\\\\texttt{best}[n][1] = \\\\{\\\\}\",\n      children: \"<span class=\\\"katex-display\\\"><span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\" display=\\\"block\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">best</mtext><mo stretchy=\\\"false\\\">[</mo><mi>n</mi><mo stretchy=\\\"false\\\">]</mo><mo stretchy=\\\"false\\\">[</mo><mn>1</mn><mo stretchy=\\\"false\\\">]</mo><mo>=</mo><mo stretchy=\\\"false\\\">{</mo><mo stretchy=\\\"false\\\">}</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{best}[n][1] = \\\\{\\\\}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">best</span></span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">]</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord\\\">1</span><span class=\\\"mclose\\\">]</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">{</span><span class=\\\"mclose\\\">}</span></span></span></span></span>\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, when we're processing a specific node in the tree, we go through each of its children and incorporate the child's DP array into that of the current node.\", _jsx(_components.br, {}), \"\\nFor each of these subtrees, we have 2 choices:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"We don't include any of it, and add the edge connecting it and the current node to the current edge set we're processing.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"We include some of it, and with that add the edge set stored in that subtree's DP array.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"After that, we can simply go through each node and get the overall minimum edge set to get a city of size \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"k\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\\\"application/x-tex\\\">k</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <cassert>\\r\\n#include <vector>\\r\\n#include <set>\\r\\n#include <algorithm>\\r\\n\\r\\nusing std::cout;\\r\\nusing std::endl;\\r\\nusing std::vector;\\r\\nusing std::pair;\\r\\n\\r\\nclass Country {\\r\\n\\tprivate:\\r\\n\\t\\tstruct Road {\\r\\n\\t\\t\\tint from;\\r\\n\\t\\t\\tint to;\\r\\n\\t\\t\\tbool operator==(const Road& o) {\\r\\n\\t\\t\\t\\treturn (from == o.from && to == o.to) || (from == o.to && to == o.from);\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\t\\tconst int ROOT = 0;\\r\\n\\r\\n\\t\\tconst vector<vector<int>>& neighbors;\\r\\n\\t\\tint target_size;\\r\\n\\t\\tvector<int> sub_town_num;\\r\\n\\t\\tvector<int> parent;\\r\\n\\t\\t/*\\r\\n\\t\\t * this[n][k] = min problem roads given that\\r\\n\\t\\t * there is a k-sized town rooted at n\\r\\n\\t\\t * the stored vector is a list of the supposed \\\"problem\\\" roads\\r\\n\\t\\t * min_roads just contains the size/validity of each state\\r\\n\\t\\t */\\r\\n\\t\\tvector<vector<vector<Road>>> best;\\r\\n\\t\\tvector<vector<int>> min_roads;\\r\\n\\r\\n\\t\\tvoid process_towns(int at, int prev) {\\r\\n\\t\\t\\tsub_town_num[at] = 1;\\r\\n\\t\\t\\tparent[at] = prev;\\r\\n\\t\\t\\t// preliminary calculations\\r\\n\\t\\t\\tfor (int n : neighbors[at]) {\\r\\n\\t\\t\\t\\tif (n != prev) {\\r\\n\\t\\t\\t\\t\\tprocess_towns(n, at);\\r\\n\\t\\t\\t\\t\\tsub_town_num[at] += sub_town_num[n];\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t * ok so this base case isn't really true, but if the parent wants\\r\\n\\t\\t\\t * to include none from this subtree they have to cut off this road\\r\\n\\t\\t\\t * so might as well include it now so the first case can be handled\\r\\n\\t\\t\\t * implicitly without a special if statement\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tbest[at][0] = {{at, prev}};\\r\\n\\t\\t\\tmin_roads[at][0] = 1;\\r\\n\\t\\t\\tbest[at][1] = {};\\r\\n\\t\\t\\tmin_roads[at][1] = 0;\\r\\n\\r\\n\\t\\t\\t// incorporate the child towns\\r\\n\\t\\t\\tfor (int n : neighbors[at]) {\\r\\n\\t\\t\\t\\tif (n == prev) {\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tvector<vector<Road>> new_b(target_size + 1);\\r\\n\\t\\t\\t\\tvector<int> new_m(target_size + 1, INT32_MAX);\\r\\n\\t\\t\\t\\tnew_b[0] = best[at][0];\\r\\n\\t\\t\\t\\tnew_m[0] = min_roads[at][0];\\r\\n\\t\\t\\t\\tfor (int st = 1; st <= target_size; st++) {\\r\\n\\t\\t\\t\\t\\tfor (int at_amt = 1; at_amt <= st; at_amt++) {\\r\\n\\t\\t\\t\\t\\t\\tint n_amt = st - at_amt;\\r\\n\\t\\t\\t\\t\\t\\tif (min_roads[at][at_amt] == INT32_MAX\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t|| min_roads[n][n_amt] == INT32_MAX) {\\r\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tint new_r = min_roads[at][at_amt] + min_roads[n][n_amt];\\r\\n\\t\\t\\t\\t\\t\\tif (new_r < new_m[st]) {\\r\\n\\t\\t\\t\\t\\t\\t\\tnew_m[st] = new_r;\\r\\n\\t\\t\\t\\t\\t\\t\\tnew_b[st] = vector<Road>(best[at][at_amt]);\\r\\n\\t\\t\\t\\t\\t\\t\\tnew_b[st].insert(\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tnew_b[st].end(),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbest[n][n_amt].begin(),\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tbest[n][n_amt].end()\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbest[at] = new_b;\\r\\n\\t\\t\\t\\tmin_roads[at] = new_m;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (sub_town_num[at] <= target_size) {\\r\\n\\t\\t\\t\\t// or the entire subtree could be a state lol\\r\\n\\t\\t\\t\\tbest[at][sub_town_num[at]] = {};\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\tpublic:\\r\\n\\t\\t// i honestly don't know if the formatting for this is correct or not lmao\\r\\n\\t\\tCountry(const vector<vector<int>>& neighbors, int target_size)\\r\\n\\t\\t\\t\\t: neighbors(neighbors),\\r\\n\\t\\t\\t\\t  target_size(target_size),\\r\\n\\t\\t\\t\\t  sub_town_num(neighbors.size()),\\r\\n\\t\\t\\t\\t  parent(neighbors.size()),\\r\\n\\t\\t\\t\\t  best(neighbors.size(), vector<vector<Road>>(target_size + 1)),\\r\\n\\t\\t\\t\\t  min_roads(\\r\\n\\t\\t\\t\\t\\tneighbors.size(),\\r\\n\\t\\t\\t\\t\\tvector<int>(target_size + 1, INT32_MAX)\\r\\n\\t\\t\\t\\t  ) {\\r\\n\\t\\t\\tassert(target_size >= 1);  // this breaks down for any other number lol\\r\\n\\t\\t\\tprocess_towns(ROOT, ROOT);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvector<Road> min_problem_roads() {\\r\\n\\t\\t\\tint min_problem_amt = INT32_MAX;\\r\\n\\t\\t\\tvector<Road> town_roads;\\r\\n\\t\\t\\tfor (int r = 0; r < neighbors.size(); r++) {\\r\\n\\t\\t\\t\\tif (min_roads[r][target_size] == INT32_MAX) {\\r\\n\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (r == ROOT) {\\r\\n\\t\\t\\t\\t\\tif (min_roads[r][target_size] < min_problem_amt) {\\r\\n\\t\\t\\t\\t\\t\\tmin_problem_amt = min_roads[r][target_size];\\r\\n\\t\\t\\t\\t\\t\\ttown_roads = best[r][target_size];\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t * if this node isn't the root, we have to add the\\r\\n\\t\\t\\t\\t\\t * edge connecting it and it's parent as well\\r\\n\\t\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\t\\tif (min_roads[r][target_size] + 1 < min_problem_amt) {\\r\\n\\t\\t\\t\\t\\t\\tmin_problem_amt = min_roads[r][target_size] + 1;\\r\\n\\t\\t\\t\\t\\t\\ttown_roads = best[r][target_size];\\r\\n\\t\\t\\t\\t\\t\\ttown_roads.push_back({r, parent[r]});\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn town_roads;\\r\\n\\t\\t}\\r\\n};\\r\\n\\r\\nint main() {\\r\\n\\tint town_num;\\r\\n\\tint target_size;\\r\\n\\tstd::cin >> town_num >> target_size;\\r\\n\\tvector<vector<int>> neighbors(town_num);\\r\\n\\tvector<pair<int, int>> roads;\\r\\n\\tfor (int e = 0; e < town_num - 1; e++) {\\r\\n\\t\\tint from;\\r\\n\\t\\tint to;\\r\\n\\t\\tstd::cin >> from >> to;\\r\\n\\t\\tneighbors[--from].push_back(--to);\\r\\n\\t\\tneighbors[to].push_back(from);\\r\\n\\t\\troads.push_back({from, to});\\r\\n\\t}\\r\\n\\r\\n\\tCountry country(neighbors, target_size);\\r\\n\\tstd::set<pair<int, int>> to_remove;\\r\\n\\tfor (const auto& r : country.min_problem_roads()) {\\r\\n\\t\\tto_remove.insert({r.from, r.to});\\r\\n\\t}\\r\\n\\tvector<int> remove_ind;\\r\\n\\tfor (int r = 0; r < town_num - 1; r++) {\\r\\n\\t\\t// append the indices of all roads that are in the \\\"to remove\\\" list\\r\\n\\t\\tif (to_remove.count(roads[r])\\r\\n\\t\\t\\t\\t|| to_remove.count(std::make_pair(roads[r].second, roads[r].first))) {\\r\\n\\t\\t\\tremove_ind.push_back(r);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tcout << remove_ind.size() << endl;\\r\\n\\tfor (int i = 0; i < (int) remove_ind.size() - 1; i++) {\\r\\n\\t\\tcout << remove_ind[i] + 1 << ' ';\\r\\n\\t}\\r\\n\\tif (!remove_ind.empty()) {\\r\\n\\t\\tcout << remove_ind.back() + 1;\\r\\n\\t}\\r\\n\\tcout << endl;\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cf-440D","source":"CF","title":"Berland Federalization","author":"Kevin Sheng"},"parent":{"name":"cf-440D","relativePath":"cf-440D.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"dp-trees","title":"DP on Trees - Introduction"}}}}]},"problemInfo":{"uniqueId":"cf-440D","url":"https://codeforces.com/problemset/problem/440/D"}},"pageContext":{"id":"cf-440D"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}