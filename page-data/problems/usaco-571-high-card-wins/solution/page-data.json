{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-571-high-card-wins/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-571\", source = \"USACO Silver 2015 December\", title = \"High Card Wins\", author = \"Óscar Garries, Ryan Chou\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, PySection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_highcard_silver_dec15.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (Java)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Intuitively, we always want Bessie to win with the smallest card possible. We can ensure this minimum by storing the available cards for both Bessie and Elsie. If Elsie's current card is higher than Bessie's, we can move to the Bessie's next higher card.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can see the algorithm in action with the test set below:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/usaco-571-anim/highcard_algo.gif\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <algorithm>\\r\\n#include <cstdio>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\nconst int MAX_CARDS = 1e5;\\r\\nbool elsieHas[MAX_CARDS + 1];\\r\\n\\r\\nint main() {\\r\\n\\tfreopen(\\\"highcard.in\\\", \\\"r\\\", stdin);\\r\\n\\tfreopen(\\\"highcard.out\\\", \\\"w\\\", stdout);\\r\\n\\tint n;\\r\\n\\tcin >> n;\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tint card;\\r\\n\\t\\tcin >> card;\\r\\n\\t\\telsieHas[card] = true;\\r\\n\\t}\\r\\n\\r\\n\\tvector<int> elsie;\\r\\n\\tvector<int> bessie;\\r\\n\\t\\r\\n\\t// Because we loop over the values in increasing order,\\r\\n\\t// the two lists will be in sorted order.\\r\\n\\tfor (int i = 1; i <= n * 2; i++) {\\r\\n\\t\\t// If Elsie has this card:\\r\\n\\t\\tif (elsieHas[i]) {\\r\\n\\t\\t\\telsie.push_back(i);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tbessie.push_back(i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tint points = 0, bessieIndex = 0, elsieIndex = 0;\\r\\n\\twhile (bessieIndex < n && elsieIndex < n) {\\r\\n\\t\\t// If Bessie wins:\\r\\n\\t\\tif (bessie[bessieIndex] > elsie[elsieIndex]) {\\r\\n\\t\\t\\tpoints++;\\r\\n\\t\\t\\tbessieIndex++;\\r\\n\\t\\t\\telsieIndex++;\\r\\n\\t\\t// Otherwise, choose the next highest card from Bessie's hand.\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tbessieIndex++;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tcout << points;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\n\\r\\nsys.stdin = open(\\\"highcard.in\\\", \\\"r\\\")\\r\\nsys.stdout = open(\\\"highcard.out\\\", \\\"w\\\")\\r\\n\\r\\nelsie_has = set()\\r\\nn = int(input())\\r\\n\\r\\nfor i in range(n):\\r\\n\\telsie_has.add(int(input()))\\r\\n\\r\\nelsie, bessie = [], []\\r\\n\\t\\r\\n# Because we loop over the values in increasing order,\\r\\n# the two lists will be in sorted order.\\r\\nfor i in range(1, n * 2 + 1):\\r\\n\\t# If Elsie doesn't have the card:\\r\\n\\tif i not in elsie_has:\\r\\n\\t\\tbessie.append(i)\\r\\n\\telse:\\r\\n\\t\\telsie.append(i)\\r\\n\\r\\npoints, bessie_index, elsie_index = 0, 0, 0\\r\\n\\r\\nwhile (bessie_index < n and elsie_index < n):\\r\\n\\t# If Bessie wins:\\r\\n\\tif bessie[bessie_index] > elsie[elsie_index]:\\r\\n\\t\\tpoints += 1\\r\\n\\t\\tbessie_index += 1\\r\\n\\t\\telsie_index += 1\\r\\n\\t# Otherwise, choose the next highest card from Bessie's hand.\\r\\n\\telse:\\r\\n\\t\\tbessie_index += 1\\r\\n\\r\\nprint(points)\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"// Code from Official USACO Editorial:\\r\\nimport java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class HighCard {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader br = new BufferedReader(new FileReader(\\\"highcard.in\\\"));\\r\\n\\t\\tPrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(\\\"highcard.out\\\")));\\r\\n\\t\\tint n = Integer.parseInt(br.readLine());\\r\\n\\t\\tboolean[] elsieOwns = new boolean[2 * n + 1];\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\telsieOwns[Integer.parseInt(br.readLine())] = true;\\r\\n\\t\\t}\\r\\n\\t\\tList<Integer> bessie = new ArrayList<Integer>();\\r\\n\\t\\tList<Integer> elsie = new ArrayList<Integer>();\\r\\n\\t\\tint points = 0;\\r\\n\\t\\t// Because we loop over the values in increasing order,\\r\\n\\t\\t// the two lists will be in sorted order.\\r\\n\\t\\tfor (int i = 1; i <= n * 2; i++) {\\r\\n\\t\\t\\t// If Elsie doesn't have the card:\\r\\n\\t\\t\\tif (elsieOwns[i]) {\\r\\n\\t\\t\\t\\telsie.add(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tbessie.add(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tint bessieIndex = 0;\\r\\n\\t\\tint elsieIndex = 0;\\r\\n\\t\\twhile (bessieIndex < n && elsieIndex < n) {\\r\\n\\t\\t\\t// If Bessie wins:\\r\\n\\t\\t\\tif (bessie.get(bessieIndex) > elsie.get(elsieIndex)) {\\r\\n\\t\\t\\t\\tpoints++;\\r\\n\\t\\t\\t\\tbessieIndex++;\\r\\n\\t\\t\\t\\telsieIndex++;\\r\\n\\t\\t\\t// Otherwise, choose the next highest card from Bessie's hand.\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tbessieIndex++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tpw.println(points);\\r\\n\\t\\tpw.close();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-571","source":"USACO Silver 2015 December","title":"High Card Wins","author":"Óscar Garries, Ryan Chou"},"parent":{"name":"usaco-571","relativePath":"usaco-571.mdx"},"toc":{"cpp":[{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"greedy-sorting","title":"Greedy Algorithms with Sorting"}}}}]},"problemInfo":{"uniqueId":"usaco-571","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=571"}},"pageContext":{"id":"usaco-571"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}