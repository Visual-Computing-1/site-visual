{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1161-stick-division/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1161\", source = \"CSES\", title = \"Stick Divisions\", author = \"Dong Liu, Benjamin Qi, Chuyang Wang\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {MATHSPAN, HeaderLink, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"In this problem, we're asked to find the minimum cost to divide a stick with\\r\\nlength \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \" into \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" sticks with given lengths. It helps to work backwards; what\\r\\nif we start with sticks of lengths \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"d_1,\\\\ldots,d_n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub><mo separator=\\\"true\\\">,</mo><mo>…</mo><mo separator=\\\"true\\\">,</mo><msub><mi>d</mi><mi>n</mi></msub></mrow><annotation encoding=\\\"application/x-tex\\\">d_1,\\\\ldots,d_n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8889em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">d</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.3011em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">1</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"minner\\\">…</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\">d</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.1514em;\\\"><span style=\\\"top:-2.55em;margin-left:0em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mathnormal mtight\\\">n</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.15em;\\\"><span></span></span></span></span></span></span></span></span></span>\"\n      }), \" and merge them into one?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It turns out that this can be solved using\\r\\n\", _jsx(_components.a, {\n        href: \"/CPH.pdf#page=73\",\n        children: \"Huffman Coding\"\n      }), \" (also see\\r\\n\", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Huffman_coding#Basic_technique\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Wikipedia\"\n      }), \"). The\\r\\nalgorithm is simple; take the two shortest sticks, merge them into one, and\\r\\nrepeat.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you're wondering why Huffman Coding always produces an optimal solution, see\\r\\n\", _jsx(_components.a, {\n        href: \"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-02-introduction-to-eecs-ii-digital-communication-systems-fall-2012/readings/MIT6_02F12_chap03.pdf#page=6\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"here\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As we want to select both shortest sticks and then insert the combined new stick, we will want to have a data structure where we are able to get the smallest value in the collection, remove it and add new values to the collection. The insert and remove operations can be done easily with a priority queue in \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(\\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(\\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" time, while retrieving the smallest value takes constant time.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(n \\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(n \\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <queue>\\r\\nusing namespace std;\\r\\n\\r\\nint main(){\\r\\n\\t\\tios_base::sync_with_stdio(0); cin.tie(0);\\r\\n\\t\\tint x, n; cin >> x >> n;\\r\\n\\t\\tpriority_queue<int, vector<int>, greater<int> > PQ;\\r\\n\\t\\tfor(int i=0; i<n; i++) {\\r\\n\\t\\t\\tint a; cin >> a;\\r\\n\\t\\t\\tPQ.push(a);\\r\\n\\t\\t}\\r\\n\\t\\tlong long ans=0;\\r\\n\\t\\tfor(int i=1; i<n; i++) {\\r\\n\\t\\t\\tint a=PQ.top(); PQ.pop();\\r\\n\\t\\t\\tint b=PQ.top(); PQ.pop();\\r\\n\\t\\t\\tPQ.push(a+b);\\r\\n\\t\\t\\tans += a+b;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tcout << ans <<\\\"\\\\n\\\";\\r\\n\\t\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class StickDivision {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(in.readLine());\\r\\n\\r\\n\\t\\t// with our algorithm the variable x will not be used at all\\r\\n\\t\\t// since it is guaranteed by problem constraints that all values add up to x\\r\\n\\t\\tint x = Integer.parseInt(st.nextToken());\\r\\n\\t\\tint n = Integer.parseInt(st.nextToken());\\r\\n\\t\\tQueue<Integer> sticks = new PriorityQueue<Integer>();\\r\\n\\t\\tst = new StringTokenizer(in.readLine());\\r\\n\\t\\tfor (int i = 0; i < n; i++)\\r\\n\\t\\t\\tsticks.add(Integer.valueOf(st.nextToken()));\\r\\n\\r\\n\\t\\tlong costs = 0;\\r\\n\\t\\t// we keep combining two smallest sticks a and b\\r\\n\\t\\t// until there is only one stick remaining, which will have the length x\\r\\n\\t\\twhile (sticks.size() > 1) {\\r\\n\\t\\t\\tint a = sticks.remove();\\r\\n\\t\\t\\tint b = sticks.remove();\\r\\n\\t\\t\\tsticks.add(a + b);\\r\\n\\t\\t\\t// the length of the combined stick is the cost for dividing them into\\r\\n\\t\\t\\t// the seperated sticks a and b\\r\\n\\t\\t\\tcosts += a + b;\\r\\n\\t\\t}\\r\\n\\t\\tSystem.out.println(costs);\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1161","source":"CSES","title":"Stick Divisions","author":"Dong Liu, Benjamin Qi, Chuyang Wang"},"parent":{"name":"cses-1161","relativePath":"cses-1161.mdx"},"toc":{"cpp":[{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"greedy-sorting","title":"Greedy Algorithms with Sorting"}}}}]},"problemInfo":{"uniqueId":"cses-1161","url":"https://cses.fi/problemset/task/1161"}},"pageContext":{"id":"cses-1161"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}