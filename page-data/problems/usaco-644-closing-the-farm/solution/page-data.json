{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-644-closing-the-farm/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-644\", source = \"USACO Silver 2016 Open\", title = \"Closing the Farm\", author = \"Jesse Choe, Maggie Liu, Nathan Gong, Ryan Chou\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    Warning: _missingComponent(\"Warning\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, PySection, Warning, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_closing_silver_open16.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In this problem, we are asked to determine if all remaining barns are connected\\r\\nas the barns close one at a time. To check this, we can run a \", _jsx(_components.a, {\n        href: \"/silver/dfs\",\n        children: \"depth-first search\\r\\n(DFS)\"\n      }), \" starting from the barn that will close last. To simulate the closure of\\r\\neach barn, we can store a boolean array and set each barn in the iteration to be\\r\\n\\\"closed\\\". Then, we can run the DFS and check how many nodes have been visited.\\r\\nIf all the unclosed nodes have been visited, then we print \\\"YES\\\" otherwise, we\\r\\nprint \\\"NO\\\".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2 + NM)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>+</mo><mi>N</mi><mi>M</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2 + NM)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">NM</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(PySection, {\n        children: [_jsx(Warning, {\n          title: \"Time Limit Exceeded\",\n          children: _jsx(_components.p, {\n            children: \"Since Python is slow, it exceeds the time limit on test cases 8 and 10 even though the solution is the intended one.\"\n          })\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\n\\r\\nsys.stdin = open(\\\"closing.in\\\", \\\"r\\\")\\r\\nsys.stdout = open(\\\"closing.out\\\", \\\"w\\\")\\r\\n\\r\\nn, m = map(int, input().split())\\r\\n\\r\\nadj, order = {}, []\\r\\nfor i in range(1, n + 1): adj[i] = []\\r\\n\\r\\nvisited, closed = [False] * (n + 1), [False] * (n + 1)\\r\\nnodes = 0\\r\\n\\r\\ndef dfs(node):\\r\\n\\tglobal nodes\\r\\n\\tif visited[node] or closed[node]: return\\r\\n\\r\\n\\t# Visit this node if it isn't closed and we haven't visited it yet.\\r\\n\\tnodes += 1\\r\\n\\tvisited[node] = True\\r\\n\\t\\r\\n\\tfor u in adj[node]:\\r\\n\\t\\tif not visited[u]: \\r\\n\\t\\t\\tdfs(u)\\r\\n\\r\\n# Read in adjacency list.\\r\\nfor i in range(m):\\r\\n\\ta, b = map(int, input().split())\\r\\n\\tadj[a].append(b)\\r\\n\\tadj[b].append(a)\\r\\n\\r\\nfor i in range(n):\\r\\n\\torder.append(int(input()))\\r\\n\\r\\ndfs(1)\\r\\n\\r\\n\\\"\\\"\\\"\\r\\nThe farm is initially connected if we've visited every node \\r\\nbefore any of the farms are closed.\\r\\n\\\"\\\"\\\"\\r\\nprint(\\\"YES\\\") if nodes == n else print(\\\"NO\\\")\\r\\n\\r\\nfor i in range(n - 1):\\r\\n\\tvisited = [False] * (n + 1)\\r\\n\\tnodes = 0\\r\\n\\tclosed[order[i]] = True\\r\\n\\r\\n\\t# Start DFS from the barn that will close last.\\r\\n\\tdfs(order[n - 1])\\r\\n\\r\\n\\t# Have we visited all the unclosed barns?\\r\\n\\tif nodes == n - i - 1:\\r\\n\\t\\tprint(\\\"YES\\\")\\r\\n\\telse:\\r\\n\\t\\tprint(\\\"NO\\\")\\n\"\n          })\n        })]\n      }), _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <cstdio>\\r\\n#include <vector>\\r\\nusing namespace std;\\r\\n\\r\\nint n, m;\\r\\nconst int MAX_N = 3000;\\r\\n\\r\\nvector<vector<int>> adj(MAX_N);\\r\\nvector<int> vis(MAX_N);\\r\\nvector<int> closed(MAX_N);\\r\\nint nodes = 0;\\r\\n\\r\\n\\r\\nvoid dfs(int node) {\\r\\n\\tif (vis[node] || closed[node]) return;\\r\\n\\r\\n\\t// Visit this node if it isn't closed and we haven't visited it yet.\\r\\n\\tnodes++;\\r\\n\\tvis[node] = true;\\r\\n\\t\\r\\n\\tfor (int u : adj[node]) {\\r\\n\\t\\tif (!vis[u]) dfs(u);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tfreopen(\\\"closing.in\\\", \\\"r\\\", stdin);\\r\\n\\tfreopen(\\\"closing.out\\\", \\\"w\\\", stdout);\\r\\n\\r\\n\\tcin >> n >> m;\\r\\n\\r\\n\\t// Read in adjacency list.\\r\\n\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\tadj[a].push_back(b);\\r\\n\\t\\tadj[b].push_back(a);\\r\\n\\t}\\r\\n\\t\\r\\n\\tvector<int> ord(n);\\r\\n\\tfor (int i = 0; i < n; i++) cin >> ord[i];\\r\\n\\r\\n\\tdfs(1);\\r\\n\\t\\r\\n\\t/*\\r\\n\\t * The farm is initially connected if we've visited every node \\r\\n\\t * before any of the farms are closed.\\r\\n\\t */\\r\\n\\tif (nodes == n) {\\r\\n\\t\\tcout << \\\"YES\\\\n\\\";\\r\\n\\t} else {\\r\\n\\t\\tcout << \\\"NO\\\\n\\\";\\r\\n\\t}\\r\\n\\t\\r\\n\\tfor (int i = 0; i < n - 1; i++) {\\r\\n\\t\\tnodes = 0;\\r\\n\\t\\tclosed[ord[i]] = true;\\r\\n\\t\\tfill(vis.begin(), vis.end(), false);\\r\\n\\r\\n\\t\\t// Start DFS from the barn that will close last.\\r\\n\\t\\tdfs(ord[n - 1]);\\r\\n\\r\\n\\t\\t// Have we visited all the unclosed barns?\\r\\n\\t\\tif (nodes == n - i - 1) {\\r\\n\\t\\t\\tcout << \\\"YES\\\" << \\\"\\\\n\\\";\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tcout << \\\"NO\\\" << \\\"\\\\n\\\";\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class closing {\\r\\n\\t// Store global variables used by dfs\\r\\n\\tstatic ArrayList<ArrayList<Integer>> adj;\\r\\n\\tstatic boolean[] visited, closed;\\r\\n\\tstatic int nodes;\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tScanner sc = new Scanner(new File(\\\"closing.in\\\"));\\r\\n\\t\\tPrintWriter out = new PrintWriter(\\\"closing.out\\\");\\r\\n\\t\\t\\r\\n\\t\\tint n = sc.nextInt();\\r\\n\\t\\tint m = sc.nextInt();\\r\\n\\r\\n\\t\\tvisited = new boolean[n];\\r\\n\\t\\tclosed = new boolean[n];\\r\\n\\t\\tadj = new ArrayList<ArrayList<Integer>>();\\r\\n\\t\\tfor (int i = 0; i < n; i++) adj.add(new ArrayList<Integer>());\\r\\n\\r\\n\\t\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\t\\tint a = sc.nextInt() - 1;\\r\\n\\t\\t\\tint b = sc.nextInt() - 1;\\r\\n\\t\\t\\tadj.get(a).add(b);\\r\\n\\t\\t\\tadj.get(b).add(a);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint[] order = new int[n];\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\torder[i] = sc.nextInt() - 1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tArrays.fill(visited, false);\\r\\n\\t\\t\\tnodes = 0;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tdfs(order[n - 1]); // DFS from the barn that will close last\\r\\n\\t\\t\\t// Checks if all unclosed barns have been visited\\r\\n\\t\\t\\tif (nodes == n - i) {\\r\\n\\t\\t\\t\\tout.println(\\\"YES\\\");\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tout.println(\\\"NO\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tclosed[order[i]] = true;\\r\\n\\t\\t}\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\r\\n\\tstatic void dfs(int node) {\\r\\n\\t\\tif (visited[node] || closed[node]) return;\\r\\n\\r\\n\\t\\t// Increase the number of nodes \\r\\n\\t\\t// iff this barn hasn't already been closed or visited\\r\\n\\t\\tnodes++;\\r\\n\\t\\tvisited[node] = true;\\r\\n\\t\\tfor (int neighbor : adj.get(node)) {\\r\\n\\t\\t\\tdfs(neighbor);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-644","source":"USACO Silver 2016 Open","title":"Closing the Farm","author":"Jesse Choe, Maggie Liu, Nathan Gong, Ryan Chou"},"parent":{"name":"usaco-644","relativePath":"usaco-644.mdx"},"toc":{"cpp":[{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"dfs","title":"Depth First Search (DFS)"}}}}]},"problemInfo":{"uniqueId":"usaco-644","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=644"}},"pageContext":{"id":"usaco-644"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}