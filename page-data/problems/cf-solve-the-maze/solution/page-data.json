{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-solve-the-maze/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cf-1365D\", source = \"CF\", title = \"Solve the Maze\", author = \"Daniel Suh, Brad Ma\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://codeforces.com/blog/entry/78504\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"explanation\",\n      children: [_jsx(_components.a, {\n        href: \"#explanation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Explanation\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The main observation is that if there is a bad person next to a good person, then it is impossible. For example, consider the following:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"#####\\r\\n##BG#\\r\\n###..\\r\\n####.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Because the good person is adjacent to the bad person, the bad person can simply just move right, and now has full access to wherever the good person can move to. It won't matter if the good person can make it, as the bad person can make it as well. Furthermore, replacing a good person with a wall is not allowed, so preventing the movement of the bad person is not allowed.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"With this observation, the solution is relatively simple. Check for this adjacency, and if it exists, print \\\"No.\\\" Otherwise, proceed by surrounding the bad people with walls. Floodfill from the end point \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"(N - 1,\\\\space M - 1)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo separator=\\\"true\\\">,</mo><mtext> </mtext><mi>M</mi><mo>−</mo><mn>1</mn><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">(N - 1,\\\\space M - 1)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8778em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\"> </span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \", and make sure that all the good people have been visited. You do not need to check if the bad people did not make it, as surrounding the bad people with walls is sufficient.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(TNM)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>T</mi><mi>N</mi><mi>M</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(TNM)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">TNM</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\n\\r\\nusing namespace std;\\r\\ntypedef long long ll;\\r\\n\\r\\nconst int mxN = 55;\\r\\nchar grid[mxN][mxN];\\r\\nbool visited[mxN][mxN];\\r\\nint rowMovement[4]{0, 1, 0, -1};\\r\\nint columnMovement[4]{1, 0, -1, 0};\\r\\n\\r\\nint N, M;\\r\\n\\r\\nvoid floodfill(int r, int c)\\r\\n{\\r\\n\\tif (r < 0 || r >= N || c < 0 || c >= M)\\r\\n\\t\\treturn;\\r\\n\\tif (grid[r][c] == '#' || visited[r][c])\\r\\n\\t\\treturn;\\r\\n\\tvisited[r][c] = true;\\r\\n\\tfloodfill(r + 1, c);\\r\\n\\tfloodfill(r - 1, c);\\r\\n\\tfloodfill(r, c + 1);\\r\\n\\tfloodfill(r, c - 1);\\r\\n}\\r\\n\\r\\nvoid solve()\\r\\n{\\r\\n\\tmemset(grid, '.', sizeof(grid));\\r\\n\\tmemset(visited, 0, sizeof(visited));\\r\\n\\tcin >> N >> M;\\r\\n\\tfor (int i = 0; i < N; i++)\\r\\n\\t{\\r\\n\\t\\tfor (int j = 0; j < M; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tcin >> grid[i][j];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t//surrounds the bad people\\r\\n\\tbool ok = true;\\r\\n\\tfor (int i = 0; i < N; i++)\\r\\n\\t{\\r\\n\\t\\tfor (int j = 0; j < M; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif (grid[i][j] == 'B')\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tfor (int x = 0; x < 4; x++)  // go through all 4 directions\\r\\n\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\tint newRow = i + rowMovement[x];\\r\\n\\t\\t\\t\\t\\tint newColumn = j + columnMovement[x];\\r\\n\\t\\t\\t\\t\\t// check if it is in the boundaries\\r\\n\\t\\t\\t\\t\\tif (newRow >= 0 && newRow < N && newColumn >= 0 && newColumn < M)\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tif (grid[newRow][newColumn] == 'G')\\r\\n\\t\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\t\\tcout << \\\"No\\\\n\\\";\\r\\n\\t\\t\\t\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tif (grid[newRow][newColumn] == '.')\\r\\n\\t\\t\\t\\t\\t\\t{ \\r\\n\\t\\t\\t\\t\\t\\t\\tgrid[newRow][newColumn] = '#';  // turn it into a #\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tfloodfill(N - 1, M - 1);\\r\\n\\tfor (int i = 0; i < N; i++)\\r\\n\\t{\\r\\n\\t\\tfor (int j = 0; j < M; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif (grid[i][j] == 'G' && !visited[i][j])\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tcout << \\\"No\\\\n\\\";\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tcout << \\\"Yes\\\\n\\\";\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tios::sync_with_stdio(false);\\r\\n\\tcin.tie(nullptr);\\r\\n\\tint T;\\r\\n\\tcin >> T;\\r\\n\\twhile (T--)\\r\\n\\t{\\r\\n\\t\\tsolve();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class SolveTheMaze {\\r\\n\\tstatic int[] rowMovement = {0, 1, 0, -1};  // right, down, left, up\\r\\n\\tstatic int[] columnMovement = {1, 0, -1, 0};\\r\\n\\tstatic char[][] grid;\\r\\n\\tstatic boolean[][] visited;\\r\\n\\tstatic int numRows;\\r\\n\\tstatic int numColumns;\\r\\n\\r\\n\\tstatic boolean inBoundaries (int newRow, int newColumn) {\\r\\n\\t\\tif (newRow >= 0 && newRow < numRows) {\\r\\n\\t\\t\\tif (newColumn >= 0 && newColumn < numColumns) {\\r\\n\\t\\t\\t\\treturn true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\tstatic void floodfill (int row, int column) {\\r\\n\\t\\tvisited[row][column] = true;\\r\\n\\r\\n\\t\\tfor (int x = 0; x < 4; x++) {  // the 4 directions\\r\\n\\t\\t\\tint newRow = row + rowMovement[x];\\r\\n\\t\\t\\tint newColumn = column + columnMovement[x];\\r\\n\\t\\t\\tif (inBoundaries(newRow, newColumn)) {  // in boundaries\\r\\n\\t\\t\\t\\t// not visited, and not #\\r\\n\\t\\t\\t\\tif (! visited[newRow][newColumn]) {\\r\\n\\t\\t\\t\\t\\tif (grid[newRow][newColumn] != '#') {\\r\\n\\t\\t\\t\\t\\t\\tfloodfill(newRow, newColumn);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tstatic String solve () {\\r\\n\\t\\t// surround the bad\\r\\n\\t\\tfor (int i = 0; i < numRows; i++) {\\r\\n\\t\\t\\tfor (int j = 0; j < numColumns; j++) {\\r\\n\\t\\t\\t\\tif (grid[i][j] == 'B') {\\r\\n\\t\\t\\t\\t\\tfor (int x = 0; x < 4; x++) {  // the 4 directions\\r\\n\\t\\t\\t\\t\\t\\tint newRow = i + rowMovement[x];\\r\\n\\t\\t\\t\\t\\t\\tint newColumn = j + columnMovement[x];\\r\\n\\t\\t\\t\\t\\t\\t// check if it is in the boundaries\\r\\n\\t\\t\\t\\t\\t\\tif (inBoundaries(newRow, newColumn)) {\\r\\n\\t\\t\\t\\t\\t\\t\\tif (grid[newRow][newColumn] == 'G') {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\treturn \\\"No\\\";\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t\\tif (grid[newRow][newColumn] == '.') {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t// turn it into #\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tgrid[newRow][newColumn] = '#';\\r\\n\\t\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (grid[numRows - 1][numColumns - 1] != '#') {\\r\\n\\t\\t\\t// floodfill it\\r\\n\\t\\t\\tfloodfill(numRows - 1, numColumns - 1);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < numRows; i++) {\\r\\n\\t\\t\\tfor (int j = 0; j < numColumns; j++) {\\r\\n\\t\\t\\t\\t// make false if we find an unvisited G\\r\\n\\t\\t\\t\\tif (grid[i][j] == 'G' && !visited[i][j]) {\\r\\n\\t\\t\\t\\t\\treturn \\\"No\\\";\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn \\\"Yes\\\";\\r\\n\\t}\\r\\n\\r\\n\\tpublic static void main (String[] args) {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\t\\tint numTestCases = io.nextInt();\\r\\n\\t\\tfor (int x = 0; x < numTestCases; x++) {\\r\\n\\t\\t\\tnumRows = io.nextInt();\\r\\n\\t\\t\\tnumColumns = io.nextInt();\\r\\n\\t\\t\\tgrid = new char[numRows][numColumns];\\r\\n\\t\\t\\tvisited = new boolean[numRows][numColumns];\\r\\n\\r\\n\\t\\t\\tfor (int row = 0; row < numRows; row++) {  // read grid\\r\\n\\t\\t\\t\\tString line = io.next();\\r\\n\\t\\t\\t\\tfor (int column = 0; column < numColumns; column++) {\\r\\n\\t\\t\\t\\t\\tgrid[row][column] = line.charAt(column);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tio.println(solve());\\r\\n\\t\\t}\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cf-1365D","source":"CF","title":"Solve the Maze","author":"Daniel Suh, Brad Ma"},"parent":{"name":"cf-1365D","relativePath":"cf-1365D.mdx"},"toc":{"cpp":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"flood-fill","title":"Flood Fill"}}}}]},"problemInfo":{"uniqueId":"cf-1365D","url":"https://codeforces.com/contest/1365/problem/D"}},"pageContext":{"id":"cf-1365D"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}