{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/ceoi-2009harbingers/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"ceoi-09-Harbingers\", source = \"CEOI 2009\", title = \"Harbingers\", author = \"Dustin Miao\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h1: \"h1\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    Info: _missingComponent(\"Info\")\n  }, _props.components), {HeaderLink, LanguageSection, CPPSection, MATHSPAN, Info, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"The official analysis can be found \", _jsx(_components.a, {\n        href: \"https://studylib.net/doc/5889373/--ceoi-2009\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"here\"\n      })]\n    }), \"\\n\", _jsxs(_components.h1, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsxs(CPPSection, {\n        children: [_jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Time Complexity:\"\n          }), \" \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"\\\\mathcal{O}(n \\\\log n)\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mi>log</mi><mo>‚Å°</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(n \\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n          })]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nusing ll = long long;\\r\\nusing ld = long double;\\r\\nusing pll = pair<ll, ll>;\\r\\n\\r\\nconst int MAXN = 1e5 + 1;\\r\\n\\r\\n/** A simple line class for linear functions */ \\r\\nstruct Line {\\r\\n\\tll m, b;\\r\\n\\r\\n\\tLine(ll m = 0, ll b = 0) : m(m), b(b) {}\\r\\n\\r\\n\\t/** Evaluates the linear function at position x */ \\r\\n\\tll operator()(ll x) { return m * x + b; }\\r\\n\\r\\n\\t/** Returns the x-coordinate of the intersection of two lines */ \\r\\n\\tfriend ld intersect(Line l1, Line l2) { \\r\\n\\t\\treturn (ld)(l2.b - l1.b) / (ld)(l1.m - l2.m); \\r\\n\\t}\\r\\n};\\r\\n\\r\\nint N;\\r\\nll S[MAXN];  // Start time for harbinger at node\\r\\nll V[MAXN];  // Velocity for harbinger at node\\r\\nll min_time[MAXN];  // Minimum time to reach the capital from node\\r\\n\\r\\nvector<pll> T[MAXN];  // Stores tree edges\\r\\n\\r\\nLine stk[MAXN];  // convex hull of lines\\r\\nint stk_max = 0;  // end of convex hull stack\\r\\n\\r\\n/**\\r\\n * Given the convex hull of points in stk[],\\r\\n * finds the minimum y value for the given x value\\r\\n * out of all lines in the hull\\r\\n * @param x The x position\\r\\n * @return The minimum y value in the convex hull\\r\\n */ \\r\\nll line_min(ll x) {\\r\\n\\t// binary search for min value\\r\\n\\tint l = 0, r = stk_max - 1;\\r\\n\\twhile (l < r) {\\r\\n\\t\\tint m = (l + r) / 2;\\r\\n\\t\\tif (intersect(stk[m], stk[m + 1]) < x) {\\r\\n\\t\\t\\tl = m + 1;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tr = m;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn stk[l](x);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Gives the position such that if this line was to be added \\r\\n * into the convex hull, it would occupy that position. The \\r\\n * convex hull is stored in stk. If no lines are to be \\r\\n * removed to make room for the new line, then the size of the\\r\\n * convex hull is returned. Note that the convex hull \\r\\n * is NOT modified in this function. \\r\\n * @param line The line to be queried\\r\\n * @return An index between 1 and stk_max (inclusive) specifying \\r\\n *\\t\\t the location the given line would occupy should it \\r\\n *\\t\\t be added to the hull\\r\\n */ \\r\\nll remove_pos(Line line) {\\r\\n\\t// check if hull is trivial or if line belongs at the end\\r\\n\\tif (stk_max < 2 || \\r\\n\\t\\tintersect(line, stk[stk_max - 1]) >= intersect(stk[stk_max - 1], stk[stk_max - 2])) {\\r\\n\\t\\treturn stk_max;\\r\\n\\t}\\r\\n\\r\\n\\t// begin at l = 1 because we need to check intersection between k and k - 1\\r\\n\\tint l = 1, r = stk_max - 1;\\r\\n\\twhile (l < r) {\\r\\n\\t\\tint m = (l + r) / 2;\\r\\n\\t\\tif (intersect(line, stk[m]) < intersect(stk[m], stk[m - 1])) {\\r\\n\\t\\t\\tr = m;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tl = m + 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn l;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Finds the smallest dp value for all nodes in the \\r\\n * current subtree\\r\\n * @param u Current node\\r\\n * @param p Parent of current node\\r\\n * @param d Distance from root\\r\\n */ \\r\\nvoid dfs(int u = 1, int p = 0, ll d = 0) {\\r\\n\\tint prev_max, prev_pos;\\r\\n\\tLine prev_line;\\r\\n\\tif (u == 1) {\\r\\n\\t\\tmin_time[u] = 0;\\r\\n\\t\\tstk[stk_max++] = {0, 0}; \\r\\n\\t} else {\\r\\n\\t\\tmin_time[u] = line_min(V[u]) + d * V[u] + S[u];  // get dp value by querying convex hull\\r\\n\\t\\tLine l(-d, min_time[u]);  // construct new line that might be added into hull\\r\\n\\t\\tprev_max = stk_max;  // store previous hull size\\r\\n\\t\\tprev_pos = stk_max = remove_pos(l);  // update hull size to include new line\\r\\n\\t\\tprev_line = stk[stk_max];  // store previous line at replacement position\\r\\n\\t\\tstk[stk_max++] = l;  // update replacement position to new line\\r\\n\\t}\\r\\n\\r\\n\\t// recurse to children\\r\\n\\tfor (auto [v, w] : T[u]) {\\r\\n\\t\\tif (v != p) {\\r\\n\\t\\t\\tdfs(v, u, d + w);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// reset any changes made at this step\\r\\n\\tif (u != 1) {\\r\\n\\t\\tstk_max = prev_max;  // reset convex hull size \\r\\n\\t\\tstk[prev_pos] = prev_line;  // reset replacement position\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcin >> N;\\r\\n\\tfor (int i = 1; i < N; i++) {\\r\\n\\t\\tint u, v, w;\\r\\n\\t\\tcin >> u >> v >> w;\\r\\n\\t\\tT[u].emplace_back(v, w);\\r\\n\\t\\tT[v].emplace_back(u, w);\\r\\n\\t}\\r\\n\\tfor (int i = 2; i <= N; i++) {\\r\\n\\t\\tcin >> S[i] >> V[i];\\r\\n\\t}\\r\\n\\r\\n\\tdfs();\\r\\n\\r\\n\\tfor (int i = 2; i <= N; i++) {\\r\\n\\t\\tcout << min_time[i] << ' ';\\r\\n\\t}\\r\\n\\tcout << '\\\\n';\\r\\n}\\n\"\n          })\n        })]\n      })\n    }), \"\\n\", _jsx(Info, {\n      title: \"Alternative Solution\",\n      children: _jsxs(_components.p, {\n        children: [\"This problem can also be solved with a persistent \", _jsx(_components.a, {\n          href: \"https://cp-algorithms.com/geometry/convex_hull_trick.html#toc-tgt-1\",\n          target: \"_blank\",\n          rel: \"nofollow noopener noreferrer\",\n          children: \"Li-Chao tree\"\n        }), \" (although the memory limit is rather tight).\"]\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"ceoi-09-Harbingers","source":"CEOI 2009","title":"Harbingers","author":"Dustin Miao"},"parent":{"name":"ceoi-09-Harbingers","relativePath":"ceoi-09-Harbingers.mdx"},"toc":{"cpp":[{"depth":1,"value":"Implementation","slug":"implementation"}],"java":[{"depth":1,"value":"Implementation","slug":"implementation"}],"py":[{"depth":1,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"convex-hull-trick","title":"Convex Hull Trick"}}}},{"node":{"module":{"frontmatter":{"id":"line-container","title":"LineContainer"}}}}]},"problemInfo":{"uniqueId":"ceoi-09-Harbingers","url":"https://oj.uz/problem/view/CEOI09_harbingers"}},"pageContext":{"id":"ceoi-09-Harbingers"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}