{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-1041-haircut/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-1041\", source = \"USACO Gold 2020 US Open\", title = \"Haircut\", author = \"Jeffrey Meng\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    ol: \"ol\",\n    li: \"li\",\n    pre: \"pre\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {MATHSPAN, LanguageSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_haircut_gold_open20.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, we need to count the number of inversions. (Fun fact: the number of\\r\\ninversions is also a measure of how sorted an array is. If an array has 0\\r\\ninversions, it's perfectly sorted in ascending order. Conversely, if it has the\\r\\nmaximum possible number of inversions, the array is perfectly sorted in\\r\\ndescending order.)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"One way to count inversions is to use a binary indexed tree. Think of an\\r\\ninversion as a pair of values \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a, b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi><mo separator=\\\"true\\\">,</mo><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a, b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8889em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \", with \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a > b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a &gt; b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5782em;vertical-align:-0.0391em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">&gt;</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span></span></span></span>\"\n      }), \" appearing before \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \"\\r\\nin the array. Then we can easily compute, for each value in the array, the\\r\\nnumber of inversions for which it is \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To do this, we use a BIT as a frequency table, keeping track of the number of\\r\\nhairs of each possible value. If our BIT is named \", _jsx(_components.code, {\n        children: \"tree\"\n      }), \", \", _jsx(_components.code, {\n        children: \"tree[i]\"\n      }), \" will tell us\\r\\nhow many times \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"i\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n      }), \" is seen in the array of hairs. The trick is that as long as\\r\\nwe fill out the frequency table in the order the elements appear in the array,\\r\\nwe can also use the frequency table to count the number of inversions, because\\r\\nat each point in time the frequency table only contains hairs to the left of the\\r\\nhair we are currently considering.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"That leads us to this algorithm:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Initialize a BIT so that the frequency of each value is 0.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Create an array \", _jsx(_components.code, {\n          children: \"inversions\"\n        }), \". \", _jsx(_components.code, {\n          children: \"inversions[b]\"\n        }), \" will store the number of\\r\\ninversion pairs with the second value being \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"b\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"For each hair \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"h\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\\\"application/x-tex\\\">h</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">h</span></span></span></span>\"\n        }), \" in the order it appears in the array (with \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"h\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\\\"application/x-tex\\\">h</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">h</span></span></span></span>\"\n        }), \" being the\\r\\nlength of the hair):\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"Count the number of taller hairs that appear before hair \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"h\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\\\"application/x-tex\\\">h</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">h</span></span></span></span>\"\n            }), \" in the array\\r\\n(which is, at this point in time, just the frequencies of all values\\r\\ngreater than \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"h\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\\\"application/x-tex\\\">h</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">h</span></span></span></span>\"\n            }), \"). Store this in \", _jsx(_components.code, {\n              children: \"inversions[h]\"\n            }), \".\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"Increment the frequency of \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"h\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>h</mi></mrow><annotation encoding=\\\"application/x-tex\\\">h</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">h</span></span></span></span>\"\n            }), \" in the BIT.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The number of inversions would then be the sum of all the values we computed in\\r\\nstep 3.1. However, we also need to consider the haircuts. If we cut all hairs\\r\\ngreater than length \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \", what does that mean? It means that there can be\\r\\nno inversions with a \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"b \\\\geq n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi><mo>≥</mo><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b \\\\geq n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8304em;vertical-align:-0.136em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≥</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \", because the definition of an inversion is that\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a > b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a &gt; b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5782em;vertical-align:-0.0391em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">&gt;</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \", but if \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"b \\\\geq n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi><mo>≥</mo><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b \\\\geq n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8304em;vertical-align:-0.136em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≥</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" then \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a > n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a &gt; n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5782em;vertical-align:-0.0391em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">&gt;</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" must also be true. However, if this is\\r\\ntrue, then both \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \" would have been cut to length \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \", and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"(a, b)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo stretchy=\\\"false\\\">(</mo><mi>a</mi><mo separator=\\\"true\\\">,</mo><mi>b</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">(a, b)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \"\\r\\nwould no longer be an inversion.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Thus, the number of inversions if all hairs greater than \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" are cut to length\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" is simply the sum of the first \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n - 1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">n - 1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \" elements of the inversions array (if\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" is 0 then all hairs are 0 units long, so there are 0 inversions for\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n = 0\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\\\"application/x-tex\\\">n = 0</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">0</span></span></span></span>\"\n      }), \"). This is basically just the prefix sum of the \", _jsx(_components.code, {\n        children: \"inversions\"\n      }), \" array.\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"\\r\\nimport java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class Haircut {\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tPrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\\r\\n\\r\\n\\t\\tint N = Integer.parseInt(f.readLine());\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(f.readLine());\\r\\n\\r\\n\\t\\tint[] hairs = new int[N];\\r\\n\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\thairs[i] = Integer.parseInt(st.nextToken());\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tBIT tree = new BIT(N + 1); // hair can be at most N\\r\\n\\r\\n\\t\\tlong[] inversionsWithValue = new long[N + 1];\\r\\n\\t\\t// inversionsWithValue[i] == the number of inversions used with all hairs of length i\\r\\n\\r\\n\\t\\tfor (int value : hairs) {\\r\\n\\r\\n\\r\\n\\t\\t\\t// we process from left to right, so the tree only\\r\\n\\t\\t\\t// has elements to the left of this. Therefore,\\r\\n\\t\\t\\t// the number of elements higher than this is the number of inversions.\\r\\n\\t\\t\\tint numInversions = tree.getSum(value + 1, tree.size - 1);\\r\\n\\t\\t\\tinversionsWithValue[value] += numInversions;\\r\\n\\r\\n\\t\\t\\ttree.increase(value, 1);\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\tlong cumulativeInversions = 0;\\r\\n\\t\\tout.println(0); // if all hairs are cut to length 0, they're all equal, so no inversions are possible\\r\\n\\t\\tfor (int j = 0; j < N - 1; j++) {\\r\\n\\t\\t\\tcumulativeInversions += inversionsWithValue[j];\\r\\n\\t\\t\\tout.println(cumulativeInversions);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\r\\n\\tstatic class BIT {\\r\\n\\t\\tint size;\\r\\n\\t\\tint[] tree;\\r\\n\\r\\n\\t\\tpublic BIT(int size) {\\r\\n\\t\\t\\tthis.size = size;\\r\\n\\t\\t\\ttree = new int[size + 1];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t* Change the value at index i by change\\r\\n\\t\\t* @param i\\r\\n\\t\\t* @param change\\r\\n\\t\\t*/\\r\\n\\t\\tpublic void increase(int i, int change) {\\r\\n\\t\\t\\ti++; // We start BIT at index 0\\r\\n\\t\\t\\twhile (i < tree.length) {\\r\\n\\t\\t\\t\\ttree[i] += change; // Update for all parents\\r\\n\\t\\t\\t\\ti += i & -i; // lowbit (~i + 1) is the same thing as -i\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t* Set i to a value\\r\\n\\t\\t* @param i\\r\\n\\t\\t* @param val\\r\\n\\t\\t*/\\r\\n\\t\\tpublic void set(int i, int val) {\\r\\n\\t\\t\\tincrease(i, val - get(i));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t* Sum of all elements up to and including i\\r\\n\\t\\t* @param i - index\\r\\n\\t\\t* @return\\r\\n\\t\\t*/\\r\\n\\t\\tpublic int getSum(int i) {\\r\\n\\t\\t\\ti++;\\r\\n\\t\\t\\tint sum = 0;\\r\\n\\t\\t\\twhile (i > 0) { // Sum the values of each parent\\r\\n\\t\\t\\t\\tsum += tree[i];\\r\\n\\t\\t\\t\\ti -= i & -i;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn sum;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t* Get sum of range [i, j]\\r\\n\\t\\t* @param i - start index, inclusive\\r\\n\\t\\t* @param j - end index, inclusive\\r\\n\\t\\t* @return sum of range [i, j]\\r\\n\\t\\t*/\\r\\n\\t\\tpublic int getSum(int i, int j) {\\r\\n\\t\\t\\treturn getSum(j) -\\r\\n\\t\\t\\t\\t(i > 0 ? getSum(i - 1) : 0);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t* @param i - index\\r\\n\\t\\t* @return element at i\\r\\n\\t\\t*/\\r\\n\\t\\tpublic int get(int i) {\\r\\n\\t\\t\\treturn getSum(i, i);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t/**\\r\\n\\t\\t* String representation\\r\\n\\t\\t* @return\\r\\n\\t\\t*/\\r\\n\\t\\tpublic String toString() {\\r\\n\\t\\t\\tString out = \\\"\\\";\\r\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\r\\n\\t\\t\\t\\tout += get(i) + \\\" \\\";\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tout += get(size - 1);\\r\\n\\t\\t\\treturn out;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-1041","source":"USACO Gold 2020 US Open","title":"Haircut","author":"Jeffrey Meng"},"parent":{"name":"usaco-1041","relativePath":"usaco-1041.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"PURS","title":"Point Update Range Sum"}}}}]},"problemInfo":{"uniqueId":"usaco-1041","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1041"}},"pageContext":{"id":"usaco-1041"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}