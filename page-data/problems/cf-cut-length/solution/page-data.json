{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-cut-length/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cf-598F\", source = \"CF\", title = \"Cut Length\", author = \"Benjamin Qi\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\")\n  }, _props.components), {MATHSPAN, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://codeforces.com/blog/entry/21590\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Editorial (Russian)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://codeforces.com/contest/598/submission/94804283\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"My Submission\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"My Code (without template):\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nusing ll = long long;\\r\\nusing ld = long double;\\r\\nusing db = double;\\r\\nusing str = string; // yay python!\\r\\n\\r\\nusing pi = pair<int,int>;\\r\\nusing pl = pair<ll,ll>;\\r\\nusing pd = pair<db,db>;\\r\\n\\r\\nusing vi = vector<int>;\\r\\nusing vb = vector<bool>;\\r\\nusing vl = vector<ll>;\\r\\nusing vd = vector<db>;\\r\\nusing vs = vector<str>;\\r\\nusing vpi = vector<pi>;\\r\\nusing vpl = vector<pl>;\\r\\nusing vpd = vector<pd>;\\r\\n\\r\\n#define tcT template<class T\\r\\n#define tcTU tcT, class U\\r\\n// ^ lol this makes everything look weird but I'll try it\\r\\ntcT> using V = vector<T>;\\r\\ntcT, size_t SZ> using AR = array<T,SZ>;\\r\\ntcT> using PR = pair<T,T>;\\r\\n\\r\\n// pairs\\r\\n#define mp make_pair\\r\\n#define f first\\r\\n#define s second\\r\\n\\r\\n// vectors\\r\\n// oops size(x), rbegin(x), rend(x) need C++17\\r\\n#define sz(x) int((x).size())\\r\\n#define bg(x) begin(x)\\r\\n#define all(x) bg(x), end(x)\\r\\n#define rall(x) x.rbegin(), x.rend()\\r\\n#define sor(x) sort(all(x))\\r\\n#define rsz resize\\r\\n#define ins insert\\r\\n#define ft front()\\r\\n#define bk back()\\r\\n#define pb push_back\\r\\n#define eb emplace_back\\r\\n#define pf push_front\\r\\n\\r\\n#define lb lower_bound\\r\\n#define ub upper_bound\\r\\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\\r\\n\\r\\n// loops\\r\\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\\r\\n#define F0R(i,a) FOR(i,0,a)\\r\\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\\r\\n#define R0F(i,a) ROF(i,0,a)\\r\\n#define trav(a,x) for (auto& a: x)\\r\\n\\r\\nconst int MOD = 1e9+7; // 998244353;\\r\\nconst int MX = 2e5+5;\\r\\nconst ll INF = 1e18; // not too close to LLONG_MAX\\r\\nconst ld PI = acos((ld)-1);\\r\\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\\r\\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\\r\\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\\r\\n\\r\\n// bitwise ops\\r\\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\\r\\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\\r\\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\\r\\n\\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x))\\r\\nconstexpr int p2(int x) { return 1<<x; }\\r\\nconstexpr int msk2(int x) { return p2(x)-1; }\\r\\n\\r\\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\\r\\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\\r\\n\\r\\ntcT> bool ckmin(T& a, const T& b) {\\r\\n\\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\\r\\ntcT> bool ckmax(T& a, const T& b) {\\r\\n\\treturn a < b ? a = b, 1 : 0; }\\r\\n\\r\\ntcTU> T fstTrue(T lo, T hi, U f) {\\r\\n\\thi ++; assert(lo <= hi); // assuming f is increasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo)/2;\\r\\n\\t\\tf(mid) ? hi = mid : lo = mid+1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcTU> T lstTrue(T lo, T hi, U f) {\\r\\n\\tlo --; assert(lo <= hi); // assuming f is decreasing\\r\\n\\twhile (lo < hi) { // find first index such that f is true\\r\\n\\t\\tT mid = lo+(hi-lo+1)/2;\\r\\n\\t\\tf(mid) ? lo = mid : hi = mid-1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\\r\\n\\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\\r\\ntcTU> void erase(T& t, const U& u) { // don't erase\\r\\n\\tauto it = t.find(u); assert(it != end(t));\\r\\n\\tt.erase(it); } // element that doesn't exist from (multi)set\\r\\n\\r\\n// INPUT\\r\\n#define tcTUU tcT, class ...U\\r\\ntcT> void re(complex<T>& c);\\r\\ntcTU> void re(pair<T,U>& p);\\r\\ntcT> void re(V<T>& v);\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& a);\\r\\n\\r\\ntcT> void re(T& x) { cin >> x; }\\r\\nvoid re(db& d) { str t; re(t); d = stod(t); }\\r\\nvoid re(ld& d) { str t; re(t); d = stold(t); }\\r\\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\\r\\n\\r\\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\\r\\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\\r\\ntcT> void re(V<T>& x) { trav(a,x) re(a); }\\r\\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\\r\\ntcT> void rv(int n, V<T>& x) { x.rsz(n); re(x); }\\r\\n\\r\\n// TO_STRING\\r\\n#define ts to_string\\r\\nstr ts(char c) { return str(1,c); }\\r\\nstr ts(const char* s) { return (str)s; }\\r\\nstr ts(str s) { return s; }\\r\\nstr ts(bool b) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn b ? \\\"true\\\" : \\\"false\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts((int)b);\\r\\n\\t#endif\\r\\n}\\r\\ntcT> str ts(complex<T> c) {\\r\\n\\tstringstream ss; ss << c; return ss.str(); }\\r\\nstr ts(V<bool> v) {\\r\\n\\tstr res = \\\"{\\\"; F0R(i,sz(v)) res += char('0'+v[i]);\\r\\n\\tres += \\\"}\\\"; return res; }\\r\\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\\r\\n\\tstr res = \\\"\\\"; F0R(i,SZ) res += char('0'+b[i]);\\r\\n\\treturn res; }\\r\\ntcTU> str ts(pair<T,U> p);\\r\\ntcT> str ts(T v) { // containers with begin(), end()\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\tbool fst = 1; str res = \\\"{\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\", \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\tres += \\\"}\\\"; return res;\\r\\n\\t#else\\r\\n\\t\\tbool fst = 1; str res = \\\"\\\";\\r\\n\\t\\tfor (const auto& x: v) {\\r\\n\\t\\t\\tif (!fst) res += \\\" \\\";\\r\\n\\t\\t\\tfst = 0; res += ts(x);\\r\\n\\t\\t}\\r\\n\\t\\treturn res;\\r\\n\\r\\n\\t#endif\\r\\n}\\r\\ntcTU> str ts(pair<T,U> p) {\\r\\n\\t#ifdef LOCAL\\r\\n\\t\\treturn \\\"(\\\"+ts(p.f)+\\\", \\\"+ts(p.s)+\\\")\\\";\\r\\n\\t#else\\r\\n\\t\\treturn ts(p.f)+\\\" \\\"+ts(p.s);\\r\\n\\t#endif\\r\\n}\\r\\n\\r\\n// OUTPUT\\r\\ntcT> void pr(T x) { cout << ts(x); }\\r\\ntcTUU> void pr(const T& t, const U&... u) {\\r\\n\\tpr(t); pr(u...); }\\r\\nvoid ps() { pr(\\\"\\\\n\\\"); } // print w/ spaces\\r\\ntcTUU> void ps(const T& t, const U&... u) {\\r\\n\\tpr(t); if (sizeof...(u)) pr(\\\" \\\"); ps(u...); }\\r\\n\\r\\n// DEBUG\\r\\nvoid DBG() { cerr << \\\"]\\\" << endl; }\\r\\ntcTUU> void DBG(const T& t, const U&... u) {\\r\\n\\tcerr << ts(t); if (sizeof...(u)) cerr << \\\", \\\";\\r\\n\\tDBG(u...); }\\r\\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\\r\\n\\t#define dbg(...) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> [\\\" << #__VA_ARGS__ << \\\"]: [\\\", DBG(__VA_ARGS__)\\r\\n\\t#define chk(...) if (!(__VA_ARGS__)) cerr << \\\"Line(\\\" << __LINE__ << \\\") -> function(\\\" \\\\\\r\\n\\t\\t << __FUNCTION__  << \\\") -> CHK FAILED: (\\\" << #__VA_ARGS__ << \\\")\\\" << \\\"\\\\n\\\", exit(0);\\r\\n#else\\r\\n\\t#define dbg(...) 0\\r\\n\\t#define chk(...) 0\\r\\n#endif\\r\\n\\r\\nvoid setPrec() { cout << fixed << setprecision(15); }\\r\\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\\r\\n// FILE I/O\\r\\nvoid setIn(str s) { freopen(s.c_str(),\\\"r\\\",stdin); }\\r\\nvoid setOut(str s) { freopen(s.c_str(),\\\"w\\\",stdout); }\\r\\nvoid setIO(str s = \\\"\\\") {\\r\\n\\tunsyncIO(); setPrec();\\r\\n\\t// cin.exceptions(cin.failbit);\\r\\n\\t// throws exception when do smth illegal\\r\\n\\t// ex. try to read letter into int\\r\\n\\tif (sz(s)) setIn(s+\\\".in\\\"), setOut(s+\\\".out\\\"); // for USACO\\r\\n}\\r\\n\\r\\n/**\\r\\n * Description: Use in place of \\\\texttt{complex<T>}.\\r\\n * Source: http://codeforces.com/blog/entry/22175, KACTL\\r\\n * Verification: various\\r\\n */\\r\\n\\r\\nusing T = ld;\\r\\nint sgn(T a) { return (a>0)-(a<0); }\\r\\nT sq(T a) { return a*a; }\\r\\n\\r\\ntypedef pair<T,T> P; typedef vector<P> vP;\\r\\nT norm(const P& p) { return sq(p.f)+sq(p.s); }\\r\\nT abs(const P& p) { return sqrt(norm(p)); }\\r\\nT arg(const P& p) { return atan2(p.s,p.f); }\\r\\nP conj(const P& p) { return P(p.f,-p.s); }\\r\\nP perp(const P& p) { return P(-p.s,p.f); }\\r\\nP dir(T ang) { return P(cos(ang),sin(ang)); }\\r\\n\\r\\nP operator-(const P& l) { return P(-l.f,-l.s); }\\r\\nP operator+(const P& l, const P& r) {\\r\\n\\treturn P(l.f+r.f,l.s+r.s); }\\r\\nP operator-(const P& l, const P& r) {\\r\\n\\treturn P(l.f-r.f,l.s-r.s); }\\r\\nP operator*(const P& l, const T& r) {\\r\\n\\treturn P(l.f*r,l.s*r); }\\r\\nP operator*(const T& l, const P& r) { return r*l; }\\r\\nP operator/(const P& l, const T& r) {\\r\\n\\treturn P(l.f/r,l.s/r); }\\r\\nP operator*(const P& l, const P& r) {\\r\\n\\treturn P(l.f*r.f-l.s*r.s,l.s*r.f+l.f*r.s); }\\r\\nP operator/(const P& l, const P& r) {\\r\\n\\treturn l*conj(r)/norm(r); }\\r\\nP& operator+=(P& l, const P& r) { return l = l+r; }\\r\\nP& operator-=(P& l, const P& r) { return l = l-r; }\\r\\nP& operator*=(P& l, const T& r) { return l = l*r; }\\r\\nP& operator/=(P& l, const T& r) { return l = l/r; }\\r\\nP& operator*=(P& l, const P& r) { return l = l*r; }\\r\\nP& operator/=(P& l, const P& r) { return l = l/r; }\\r\\n\\r\\nP unit(const P& p) { return p/abs(p); }\\r\\nT dot(const P& a, const P& b) { return a.f*b.f+a.s*b.s; }\\r\\nT cross(const P& a, const P& b) { return a.f*b.s-a.s*b.f; }\\r\\nT cross(const P& p, const P& a, const P& b) {\\r\\n\\treturn cross(a-p,b-p); }\\r\\nP reflect(const P& p, const P& a, const P& b) {\\r\\n\\treturn a+conj((p-a)/(b-a))*(b-a); }\\r\\nP foot(const P& p, const P& a, const P& b) {\\r\\n\\treturn (p+reflect(p,a,b))/(T)2; }\\r\\nbool onSeg(const P& p, const P& a, const P& b) {\\r\\n\\treturn cross(a,b,p) == 0 && dot(p-a,p-b) <= 0; }\\r\\n\\r\\nP lineIsect(P a, P b, P c, P d) {\\r\\n\\tT x = cross(a,b,c), y = cross(a,b,d);\\r\\n\\tT X = cross(c,d,a), Y = cross(c,d,b);\\r\\n\\treturn (d*x-c*y)/(x-y); // interior\\r\\n}\\r\\n\\r\\n/**\\r\\n * Description: centroid (center of mass) of a polygon with\\r\\n \\t* constant mass per unit area and SIGNED area\\r\\n * Time: O(N)\\r\\n * Source: http://codeforces.com/blog/entry/22175, KACTL\\r\\n * Verification: kattis polygonarea, VT HSPC 2018 Holiday Stars\\r\\n */\\r\\n\\r\\n// #include \\\"../Primitives/Point.h\\\"\\r\\n\\r\\npair<P,T> cenArea(const vP& v) {\\r\\n\\tP cen(0,0); T area = 0;\\r\\n\\tF0R(i,sz(v)) {\\r\\n\\t\\tint j = (i+1)%sz(v); T a = cross(v[i],v[j]);\\r\\n\\t\\tcen += a*(v[i]+v[j]); area += a;\\r\\n\\t}\\r\\n\\treturn {cen/area/(T)3,area/2};\\r\\n}\\r\\n\\r\\nint n,m;\\r\\n\\r\\nint main() {\\r\\n\\tsetIO(); re(n,m);\\r\\n\\tvP v(n); re(v); // read polygon\\r\\n\\tif (cenArea(v).s < 0) reverse(all(v));\\r\\n\\t// polygon should be counter clockwise\\r\\n\\tF0R(_,m) {\\r\\n\\t\\tP a,b; re(a,b); // two points on the line\\r\\n\\t\\tvi side; trav(t,v) side.pb(sgn(cross(a,b,t)) >= 0);\\r\\n\\t\\tT ans = 0;\\r\\n\\t\\tF0R(i,n) {\\r\\n\\t\\t\\tint j = (i+1)%sz(side);\\r\\n\\t\\t\\tif (side[i] != side[j]) {\\r\\n\\t\\t\\t\\tint sign = sgn(cross(v[i]-v[j],b-a));\\r\\n\\t\\t\\t\\t// add or subtract \\\"x-coordinate\\\"\\r\\n\\t\\t\\t\\tans += sign*dot(b-a,lineIsect(a,b,v[i],v[j]));\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (cross(a,b,v[i]) == 0 && cross(a,b,v[j]) == 0\\r\\n\\t\\t\\t\\t && dot(b-a,v[j]-v[i]) > 0)\\r\\n\\t\\t\\t\\tans += dot(b-a,v[j]-v[i]);\\r\\n\\t\\t\\t // deal with sides that are collinear with the line\\r\\n\\t\\t}\\r\\n\\t\\tcout << fixed << setprecision(9) << ans/abs(b-a) << \\\"\\\\n\\\";\\r\\n\\t}\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(nm)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mi>m</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(nm)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">nm</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We'll process each of the \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"m\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\\\"application/x-tex\\\">m</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">m</span></span></span></span>\"\n      }), \" lines in \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" time each. For a fixed\\r\\nline, let \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"a\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\\\"application/x-tex\\\">a</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">a</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"b\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\\\"application/x-tex\\\">b</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span></span></span></span>\"\n      }), \" be two points on the line. Suppose for simplicity that the\\r\\nline is parallel to the \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \"-axis.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, if no vertex of the polygon lies on the line then we can compute all the\\r\\nintersection points of the sides with the line and add / subtract their\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \"-coordinates appropriately to get the answer. In my solution,\\r\\n\", _jsx(_components.code, {\n        children: \"dot(b-a,p)/abs(b-a)\"\n      }), \" essentially computes the \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n      }), \"-coordinate of some point \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"p\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\\\"application/x-tex\\\">p</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">p</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To deal with vertices of the polygon that lie on the line, we can envision\\r\\nshifting the line up or down by some small amount so that no vertex lies on the\\r\\nline. This incorrectly leaves out some sides of the polygon that are collinear\\r\\nwith the original line, so we should add the lengths of these sides to the\\r\\nanswer. These sides are dealt with by the second \", _jsx(_components.code, {\n        children: \"if\"\n      }), \" statement within the loop.\"]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cf-598F","source":"CF","title":"Cut Length","author":"Benjamin Qi"},"parent":{"name":"cf-598F","relativePath":"cf-598F.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"geo-pri","title":"Geometry Primitives"}}}}]},"problemInfo":{"uniqueId":"cf-598F","url":"https://codeforces.com/contest/598/problem/F"}},"pageContext":{"id":"cf-598F"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}