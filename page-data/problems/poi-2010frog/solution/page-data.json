{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/poi-2010frog/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx} = arguments[0];\nconst id = \"poi-10-frog\", source = \"POI 2010\", title = \"Frog\", author = \"Benjamin Qi\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    pre: \"pre\",\n    code: \"code\"\n  }, _props.components), {wrapper: MDXLayout} = _components;\n  const _content = _jsx(_Fragment, {\n    children: _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\n#include <ext/pb_ds/assoc_container.hpp>\\r\\n\\r\\nusing namespace std;\\r\\nusing namespace __gnu_pbds;\\r\\n\\r\\ntypedef long long ll;\\r\\ntypedef vector<int> vi;\\r\\ntypedef pair<int, int> pii;\\r\\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\\r\\n\\r\\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\\r\\n#define F0R(i, a) for (int i=0; i<(a); i++)\\r\\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\\r\\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\\r\\n\\r\\n#define sz(x) (int)(x).size()\\r\\n#define mp make_pair\\r\\n#define pb push_back\\r\\n#define f first\\r\\n#define s second\\r\\n#define lb lower_bound\\r\\n#define ub upper_bound\\r\\n#define all(x) x.begin(), x.end()\\r\\n\\r\\nconst int MOD = 1000000007;\\r\\nconst int MX = 1000001;\\r\\n\\r\\nint n,k, sz[MX], nex[MX][20];\\r\\nll m;\\r\\n\\r\\nint get(int x, int lef) {\\r\\n\\tF0Rd(i,20) if (lef&(1<<i)) x = nex[x][i];\\r\\n\\treturn x;\\r\\n}\\r\\n\\r\\nvoid solve(int x) {\\r\\n\\tif (m <= n) cout << get(x,m) << \\\" \\\";\\r\\n\\telse {\\r\\n\\t\\tx = get(x,n);\\r\\n\\t\\tcout << get(x,(m-n)%sz[x]) << \\\" \\\";\\r\\n\\t}\\r\\n}\\r\\n\\r\\nll p[MX];\\r\\n\\r\\nvoid genNex() {\\r\\n\\tpii cur = {1,k+1};\\r\\n\\tFOR(i,1,n+1) {\\r\\n\\t\\twhile (cur.s < n && p[cur.s+1]-p[i] < p[i]-p[cur.f]) cur.f ++, cur.s ++;\\r\\n\\t\\tif (p[i]-p[cur.f] >= p[cur.s]-p[i]) nex[i][0] = cur.f;\\r\\n\\t\\telse nex[i][0] = cur.s;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint vis[MX];\\r\\n\\r\\nvoid cycSize() {\\r\\n\\tFOR(i,1,n+1) {\\r\\n\\t\\tint I = i;\\r\\n\\t\\tfor (;vis[I] == 0; I = nex[I][0]) vis[I] = i;\\r\\n\\t\\tif (vis[I] != i) continue;\\r\\n\\r\\n\\t\\tint cur = 0;\\r\\n\\t\\tfor (;vis[I] == i; I = nex[I][0]) { cur ++; vis[I] += n; }\\r\\n\\t\\tfor (;vis[I] == i+n; I = nex[I][0]) { sz[I] = cur; vis[I] += n; }\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0); cin.tie(0);\\r\\n\\tcin >> n >> k >> m;\\r\\n\\tFOR(i,1,n+1) cin >> p[i];\\r\\n\\tgenNex();\\r\\n\\tFOR(i,1,20) FOR(j,1,n+1) nex[j][i] = nex[nex[j][i-1]][i-1];\\r\\n\\tcycSize();\\r\\n\\tFOR(i,1,n+1) solve(i);\\r\\n}\\n\"\n      })\n    })\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"poi-10-frog","source":"POI 2010","title":"Frog","author":"Benjamin Qi"},"parent":{"name":"poi-10-frog","relativePath":"poi-10-frog.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"binary-jump","title":"Binary Jumping"}}}}]},"problemInfo":{"uniqueId":"poi-10-frog","url":"https://szkopul.edu.pl/problemset/problem/qDH9CkBHZKHY4vbKRBlXPrA7/site/?key=statement"}},"pageContext":{"id":"poi-10-frog"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}