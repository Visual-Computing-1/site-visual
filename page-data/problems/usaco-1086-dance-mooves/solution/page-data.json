{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-1086-dance-mooves/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-1086\", source = \"USACO Silver 2021 January\", title = \"Dance Mooves\", author = \"Neo Wang, Melody Yu (Video)\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    code: \"code\",\n    strong: \"strong\",\n    pre: \"pre\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Youtube: _missingComponent(\"Youtube\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {HeaderLink, Youtube, MATHSPAN, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_prob1_silver_jan21.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"video-solution\",\n      children: [_jsx(_components.a, {\n        href: \"#video-solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Video Solution\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Note: The video solution might not be the same as other solutions. Code in C++.\"\n    }), \"\\n\", _jsx(Youtube, {\n      id: \"WaumFVLE6Dc\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-dsu\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-dsu\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution (DSU)\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Just like the official analysis, the key observation to make here is that all\\r\\ncows will share the same answer if they have been in the same position. In other\\r\\nwords, any cow \", _jsx(_components.code, {\n        children: \"i\"\n      }), \" will share the same positions with \", _jsx(_components.code, {\n        children: \"P[i]\"\n      }), \", the position of\\r\\nthe cow after \", _jsx(_components.code, {\n        children: \"K\"\n      }), \" swaps. Since we are only keeping track of the unique items, it\\r\\nsuffices to use a \", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/container/set\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: _jsx(_components.code, {\n          children: \"set\"\n        })\n      }), \" or in\\r\\nthis case an\\r\\n\", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/container/unordered_set\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: _jsx(_components.code, {\n          children: \"unordered_set\"\n        })\n      }), \" to\\r\\nkeep track of the distinct position a cow covers. After linking all our\\r\\ncomponents together, it suffices to insert them all into a singular set - the\\r\\nset takes care of counting distinct numbers. The trick here is that we perform\\r\\n\", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/container/unordered_set/insert\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: _jsx(_components.code, {\n          children: \"insert()\"\n        })\n      }), \"\\r\\non \", _jsx(_components.code, {\n        children: \"components[dsu.get(i)]\"\n      }), \" in order to count this cumulative distinctness in a\\r\\nsingle position.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N\\\\alpha(N) + K)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mi>α</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo><mo>+</mo><mi>K</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N\\\\alpha(N) + K)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.0037em;\\\">α</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">K</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"//BeginCodeSnip{C++ Short Template}\\n#include <bits/stdc++.h> // see /general/running-code-locally\\nusing namespace std;\\n\\nusing ll = long long;\\n\\nusing vi = vector<int>;\\n#define pb push_back\\n#define all(x) begin(x), end(x)\\n#define sz(x) (int) (x).size()\\n\\nusing pi = pair<int,int>;\\n#define f first\\n#define s second\\n#define mp make_pair\\n\\nvoid setIO(string name = \\\"\\\") {\\n\\tcin.tie(0)->sync_with_stdio(0); // see /general/fast-io\\n\\tif (sz(name)) {\\n\\t\\tfreopen((name + \\\".in\\\").c_str(), \\\"r\\\", stdin); // see /general/input-output\\n\\t\\tfreopen((name + \\\".out\\\").c_str(), \\\"w\\\", stdout);\\n\\t}\\n}\\n//EndCodeSnip\\n\\r\\n/**\\r\\n * Description: Disjoint Set Union with path compression\\r\\n\\t * and union by size. Add edges and test connectivity.\\r\\n\\t * Use for Kruskal's or Boruvka's minimum spanning tree.\\r\\n * Time: O(\\\\alpha(N))\\r\\n * Source: CSAcademy, KACTL\\r\\n * Verification: *\\r\\n */\\r\\n\\r\\nstruct DSU {\\r\\n\\tvi e; void init(int N) { e = vi(N,-1); }\\r\\n\\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\\r\\n\\tbool sameSet(int a, int b) { return get(a) == get(b); }\\r\\n\\tint size(int x) { return -e[get(x)]; }\\r\\n\\tbool unite(int x, int y) { // union by size\\r\\n\\t\\tx = get(x), y = get(y); if (x == y) return 0;\\r\\n\\t\\tif (e[x] > e[y]) swap(x,y);\\r\\n\\t\\te[x] += e[y]; e[y] = x; return 1;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nint N, K;\\r\\n\\r\\nconst int MX = 1e5+1;\\r\\n\\r\\nint P[MX]; // successor\\r\\nunordered_set<int> trav[MX]; // all nodes traversed\\r\\nunordered_set<int> components[MX];\\r\\n\\r\\nint main() {\\r\\n\\tsetIO();\\r\\n\\r\\n\\tcin >> N >> K;\\r\\n\\r\\n\\tfor(int i = 1; i <= N; i++) { P[i] = i; trav[i].insert(i); }\\r\\n\\r\\n\\tfor(int i = 0; i < K; i++) {\\r\\n\\t\\tint a, b; cin >> a >> b;\\r\\n\\t\\t// swap a and b, then add to whichever node visited those.\\r\\n\\r\\n\\t\\ttrav[P[a]].insert(b);\\r\\n\\t\\ttrav[P[b]].insert(a);\\r\\n\\t\\tswap(P[a], P[b]);\\r\\n\\t}\\r\\n\\r\\n\\t// for(int i = 1; i <= N; i++) cerr << \\\"P[i]: \\\" << P[i] << \\\"\\\\n\\\";\\r\\n\\r\\n\\tDSU dsu;\\r\\n\\tdsu.init(N+1);\\r\\n\\r\\n\\tfor(int i = 1; i <= N; i++) dsu.unite(i, P[i]);\\r\\n\\tfor(int i = 1; i <= N; i++)\\r\\n\\t\\tfor(int a: trav[i]) components[dsu.get(i)].insert(a);\\r\\n\\r\\n\\tfor(int i = 1; i <= N; i++) cout << components[dsu.get(i)].size() << \\\"\\\\n\\\";\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-1086","source":"USACO Silver 2021 January","title":"Dance Mooves","author":"Neo Wang, Melody Yu (Video)"},"parent":{"name":"usaco-1086","relativePath":"usaco-1086.mdx"},"toc":{"cpp":[{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Solution (DSU)","slug":"solution-dsu"}],"java":[{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Solution (DSU)","slug":"solution-dsu"}],"py":[{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Solution (DSU)","slug":"solution-dsu"}]}},"allProblemInfo":{"edges":[{"node":{"module":null}}]},"problemInfo":{"uniqueId":"usaco-1086","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1086"}},"pageContext":{"id":"usaco-1086"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}