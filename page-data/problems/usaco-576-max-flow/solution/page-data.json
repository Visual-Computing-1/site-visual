{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-576-max-flow/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-576\", source = \"USACO Platinum 2015 December\", title = \"Max Flow\", author = \"Dustin Miao\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_maxflow_platinum_dec15.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"alternative-solution\",\n      children: [_jsx(_components.a, {\n        href: \"#alternative-solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Alternative Solution\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity\"\n      }), \": \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O((n+m)\\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\\\"false\\\">)</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O((n+m)\\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">((</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">m</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For each path \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"(a, b)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo stretchy=\\\"false\\\">(</mo><mi>a</mi><mo separator=\\\"true\\\">,</mo><mi>b</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">(a, b)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \", we can split it into two paths: \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"(a, lca(a, b)), (b, lca(a, b))\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mo stretchy=\\\"false\\\">(</mo><mi>a</mi><mo separator=\\\"true\\\">,</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy=\\\"false\\\">(</mo><mi>a</mi><mo separator=\\\"true\\\">,</mo><mi>b</mi><mo stretchy=\\\"false\\\">)</mo><mo stretchy=\\\"false\\\">)</mo><mo separator=\\\"true\\\">,</mo><mo stretchy=\\\"false\\\">(</mo><mi>b</mi><mo separator=\\\"true\\\">,</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo stretchy=\\\"false\\\">(</mo><mi>a</mi><mo separator=\\\"true\\\">,</mo><mi>b</mi><mo stretchy=\\\"false\\\">)</mo><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">(a, lca(a, b)), (b, lca(a, b))</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.01968em;\\\">l</span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span><span class=\\\"mclose\\\">))</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">b</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.01968em;\\\">l</span><span class=\\\"mord mathnormal\\\">c</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">a</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">b</span><span class=\\\"mclose\\\">))</span></span></span></span>\"\n      }), \". We\\r\\ncan find the lca with any method, but the easiest is with binary lifting. For each node,\\r\\nkeep track of the number of paths that begin at that node and the number that end at that node.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"k\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\\\"application/x-tex\\\">k</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span></span></span></span>\"\n      }), \" is the number of paths coming from a node's children, \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"s\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\\\"application/x-tex\\\">s</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">s</span></span></span></span>\"\n      }), \" is the number of paths\\r\\nstarting at the current node, and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"e\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>e</mi></mrow><annotation encoding=\\\"application/x-tex\\\">e</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">e</span></span></span></span>\"\n      }), \" is the number of paths ending at the current node,\\r\\nthen the answer for that node is \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"k + s - e / 2\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>k</mi><mo>+</mo><mi>s</mi><mo>−</mo><mi>e</mi><mi mathvariant=\\\"normal\\\">/</mi><mn>2</mn></mrow><annotation encoding=\\\"application/x-tex\\\">k + s - e / 2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7778em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"mord\\\">/2</span></span></span></span>\"\n      }), \". The \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"e / 2\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>e</mi><mi mathvariant=\\\"normal\\\">/</mi><mn>2</mn></mrow><annotation encoding=\\\"application/x-tex\\\">e / 2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"mord\\\">/2</span></span></span></span>\"\n      }), \" is because by splitting up\\r\\nthe paths, we double count the lca for each path. The number of paths going to the node's\\r\\nparent is \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"k + s - e\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>k</mi><mo>+</mo><mi>s</mi><mo>−</mo><mi>e</mi></mrow><annotation encoding=\\\"application/x-tex\\\">k + s - e</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7778em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03148em;\\\">k</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\">s</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">e</span></span></span></span>\"\n      }), \". Thus, we can process all the paths at once using a single post-order\\r\\ntraversal of the tree.\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <algorithm>\\r\\n#include <vector>\\r\\nusing namespace std;\\r\\n\\t\\r\\nconst int MAXN = 50001;\\r\\nconst int LOGN = 20;\\r\\n\\r\\nint N, M;\\r\\nvector<int> adj[MAXN];\\t// adj[u] = neighbors of u\\r\\n\\r\\nint dep[MAXN];\\t\\t// dep[u] = depth of u\\r\\nint par[MAXN][LOGN];\\t// par[u][k] = 2^k parent of u\\r\\n\\t\\r\\nint ans[MAXN];\\t\\t// ans[u] = amount of milk through u\\r\\nint S[MAXN];\\t\\t// S[u] = # of paths starting at u\\r\\nint E[MAXN];\\t\\t// E[u] = # of paths ending at u\\r\\n\\r\\n// initializes (direct) parent and depth \\r\\n// u = current node\\r\\n// p = parent of u (parent of root is root)\\r\\n// d = depth of u\\r\\nvoid init_bl(int u, int p, int d) {\\r\\n\\tdep[u] = d;\\r\\n\\tpar[u][0] = p;\\r\\n\\tfor (int v : adj[u])\\r\\n\\t\\tif (v != p)\\r\\n\\t\\t\\tinit_bl(v, u, d + 1);\\r\\n}\\r\\n\\r\\n// initializes binary lift\\r\\nvoid init_bl() {\\r\\n\\tinit_bl(1, 1, 0);\\r\\n\\tfor (int k = 1; (1 << k) <= N; k++)\\r\\n\\t\\tfor (int i = 1; i <= N; i++)\\r\\n\\t\\t\\tpar[i][k] = par[par[i][k - 1]][k - 1];\\r\\n}\\r\\n\\r\\n// queries the least common ancestor of two nodes\\r\\n// a = node 1\\r\\n// b = node 2\\r\\nint query_lca(int a, int b) {\\r\\n\\tif (dep[a] > dep[b])\\r\\n\\t\\tswap(a, b);\\r\\n\\tfor (int k = LOGN - 1; k >= 0; k--)\\r\\n\\t\\tif (dep[b] - (1 << k) >= dep[a])\\r\\n\\t\\t\\tb = par[b][k];\\r\\n\\tif (a == b)\\r\\n\\t\\treturn a;\\r\\n\\tfor (int k = LOGN - 1; k >= 0; k--)\\r\\n\\t\\tif (par[a][k] != par[b][k])\\r\\n\\t\\t\\ta = par[a][k], b = par[b][k];\\r\\n\\treturn par[a][0];\\r\\n} \\r\\n\\r\\n// initializes ans\\r\\n// u = current node\\r\\n// p = parent of u\\r\\nint dfs_ans(int u, int p) {\\r\\n\\tint sum = 0;\\r\\n\\tfor (int v : adj[u])\\r\\n\\t\\tif (v != p)\\r\\n\\t\\t\\tsum += dfs_ans(v, u);\\r\\n\\tans[u] = sum + S[u] - E[u] / 2;\\r\\n\\treturn sum + S[u] - E[u];\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0); cin.tie(0);\\r\\n\\tfreopen(\\\"maxflow.in\\\", \\\"r\\\", stdin);\\r\\n\\tfreopen(\\\"maxflow.out\\\", \\\"w\\\", stdout);\\r\\n\\t\\r\\n\\tcin >> N >> M;\\r\\n\\tfor (int i = 1; i < N; i++) {\\r\\n\\t\\tint a, b; cin >> a >> b;\\r\\n\\t\\tadj[a].push_back(b);\\r\\n\\t\\tadj[b].push_back(a);\\r\\n\\t}\\r\\n\\t\\r\\n\\tinit_bl();\\r\\n\\twhile (M--) {\\r\\n\\t\\tint a, b; cin >> a >> b;\\r\\n\\t\\tS[a]++, S[b]++, E[query_lca(a, b)] += 2;\\r\\n\\t}\\r\\n\\r\\n\\tdfs_ans(1, 0);\\r\\n\\r\\n\\tint maxAns = 0;\\r\\n\\tfor (int i = 1; i <= N; i++) \\r\\n\\t\\tmaxAns = max(maxAns, ans[i]);\\r\\n\\tcout << maxAns << '\\\\n';\\r\\n}\\r\\n\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-576","source":"USACO Platinum 2015 December","title":"Max Flow","author":"Dustin Miao"},"parent":{"name":"usaco-576","relativePath":"usaco-576.mdx"},"toc":{"cpp":[{"depth":2,"value":"Alternative Solution","slug":"alternative-solution"}],"java":[{"depth":2,"value":"Alternative Solution","slug":"alternative-solution"}],"py":[{"depth":2,"value":"Alternative Solution","slug":"alternative-solution"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"binary-jump","title":"Binary Jumping"}}}}]},"problemInfo":{"uniqueId":"usaco-576","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=576"}},"pageContext":{"id":"usaco-576"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}