{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-rectangles/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cfgym-101102D\", source = \"CF\", title = \"Rectangles\", author = \"Kevin Sheng\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    code: \"code\",\n    br: \"br\",\n    strong: \"strong\",\n    pre: \"pre\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {MATHSPAN, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Let's first simplify this problem, and then generalize the solution of that problem to this one.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Say we had a matrix of all \", _jsx(_components.code, {\n        children: \"0\"\n      }), \"'s and \", _jsx(_components.code, {\n        children: \"1\"\n      }), \"'s. How many submatrices of all \", _jsx(_components.code, {\n        children: \"1\"\n      }), \"'s are there?\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's first define a 2D array, \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{longest\\\\_consec}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">longest_consec</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{longest\\\\_consec}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">longest_consec</span></span></span></span></span>\"\n      }), \", that contains the number of consecutive \", _jsx(_components.code, {\n        children: \"1\"\n      }), \"'s that are directly to the right for each cell (including the cell itself).\", _jsx(_components.br, {}), \"\\nFor example, this matrix...\"]\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsxs(\"table\", {\n        children: [_jsxs(\"tr\", {\n          children: [_jsx(\"td\", {\n            children: \"1\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          })]\n        }), _jsxs(\"tr\", {\n          children: [_jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          })]\n        }), _jsxs(\"tr\", {\n          children: [_jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          })]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"would have the following \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{longest\\\\_consec}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">longest_consec</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{longest\\\\_consec}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">longest_consec</span></span></span></span></span>\"\n      }), \":\"]\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsxs(\"table\", {\n        children: [_jsxs(\"tr\", {\n          children: [_jsx(\"td\", {\n            children: \"1\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"2\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          })]\n        }), _jsxs(\"tr\", {\n          children: [_jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"3\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"2\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          })]\n        }), _jsxs(\"tr\", {\n          children: [_jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"0\"\n          }), \"\\r\\n\", _jsx(\"td\", {\n            children: \"1\"\n          })]\n        })]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, we go through each column and then for each row in reverse,\\r\\nfind out for each cell the number of all \", _jsx(_components.code, {\n        children: \"1\"\n      }), \"'s submatrices where the cell is the upper left corner.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"How would we do this?\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"First, let's initialize a stack \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{rel\\\\_streaks}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">rel_streaks</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{rel\\\\_streaks}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7063em;vertical-align:-0.0951em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">rel_streaks</span></span></span></span></span>\"\n      }), \" which will have elements with two properties:\\r\\nthe value of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{longest\\\\_consec}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">longest_consec</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{longest\\\\_consec}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">longest_consec</span></span></span></span></span>\"\n      }), \" for that element and the difference in row number\\r\\n(aka distance) between that element and the next element in the stack.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Also initialize a number \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{curr\\\\_sum}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">curr_sum</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{curr\\\\_sum}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5257em;vertical-align:-0.0951em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">curr_sum</span></span></span></span></span>\"\n      }), \", which, after processing, will contain\\r\\nthe number of submatrices of all \", _jsx(_components.code, {\n        children: \"1\"\n      }), \"'s that start at each cell.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Now, let's say we just started at a particular cell. How should we change our value of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{curr\\\\_sum}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">curr_sum</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{curr\\\\_sum}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5257em;vertical-align:-0.0951em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">curr_sum</span></span></span></span></span>\"\n      }), \"?\", _jsx(_components.br, {}), \"\\nLet's not consider the new matrices of one row that just got added first, and just consider the previous arrays.\\r\\nTo be able to be extended into the current cell, they need to have a column-wise width\\r\\nless than the current value of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{longest\\\\_consec}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">longest_consec</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{longest\\\\_consec}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">longest_consec</span></span></span></span></span>\"\n      }), \".\", _jsx(_components.br, {}), \"\\nTo subtract these newly invalid submatrices, we keep on popping the stack while the first part of the\\r\\nfirst element is larger than the current width and adjusting the value of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{curr\\\\_sum}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">curr_sum</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{curr\\\\_sum}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5257em;vertical-align:-0.0951em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">curr_sum</span></span></span></span></span>\"\n      }), \" as needed.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, for each step, we just need to add the current element on to the stack and add to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{curr\\\\_sum}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">curr_sum</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{curr\\\\_sum}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5257em;vertical-align:-0.0951em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">curr_sum</span></span></span></span></span>\"\n      }), \"\\r\\nthe value of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{longest\\\\_consec}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">longest_consec</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{longest\\\\_consec}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">longest_consec</span></span></span></span></span>\"\n      }), \" for that cell.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Given that we figured out that simpler problem, we can apply this to the actual problem.\\r\\nLet's make a modified version of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{longest\\\\_consec}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">longest_consec</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{longest\\\\_consec}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">longest_consec</span></span></span></span></span>\"\n      }), \", where each cell contains the\\r\\nnumber of consecutive elements to the right with the same value as the current cell.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"After that, we run almost the exact same algorithm, only now resetting all the necessary\\r\\nvariables when we encounter a number different than the previous ones we were processing.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(RC)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>R</mi><mi>C</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(RC)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">RC</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" for each of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"T\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\\\"application/x-tex\\\">T</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.13889em;\\\">T</span></span></span></span>\"\n      }), \" test cases\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"\\r\\n#include <iostream>\\r\\n#include <vector>\\r\\n#include <algorithm>\\r\\n\\r\\nusing std::cout;\\r\\nusing std::endl;\\r\\nusing std::vector;\\r\\nusing std::pair;\\r\\n\\r\\nint main() {\\r\\n\\t// see /general/fast-io\\r\\n\\tstd::ios_base::sync_with_stdio(false);\\r\\n\\tstd::cin.tie(NULL);\\r\\n\\r\\n\\tint test_num;\\r\\n\\tstd::cin >> test_num;\\r\\n\\tfor (int t = 0; t < test_num; t++) {\\r\\n\\t\\tint row_num;\\r\\n\\t\\tint col_num;\\r\\n\\t\\tstd::cin >> row_num >> col_num;\\r\\n\\t\\tvector<vector<int>> grid(row_num, vector<int>(col_num));\\r\\n\\t\\tfor (int r = 0; r < row_num; r++) {\\r\\n\\t\\t\\tfor (int c = 0; c < col_num; c++) {\\r\\n\\t\\t\\t\\tstd::cin >> grid[r][c];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvector<vector<int>> longest_consec(row_num, vector<int>(col_num));\\r\\n\\t\\tfor (int r = 0; r < row_num; r++) {\\r\\n\\t\\t\\tint curr = -1;\\r\\n\\t\\t\\tint streak = 0;\\r\\n\\t\\t\\tfor (int c = 0; c < col_num; c++) {\\r\\n\\t\\t\\t\\tif (grid[r][c] == curr) {\\r\\n\\t\\t\\t\\t\\tstreak++;\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tcurr = grid[r][c];\\r\\n\\t\\t\\t\\t\\tstreak = 1;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tlongest_consec[r][c] = streak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tlong long total = 0;\\r\\n\\t\\tfor (int c = 0; c < col_num; c++) {\\r\\n\\t\\t\\tvector<pair<int, int>> rel_streaks;\\r\\n\\t\\t\\tint curr_sum = 0;  // the current amt of valid submatrices\\r\\n\\t\\t\\tint curr = grid[row_num - 1][c];\\r\\n\\t\\t\\t// for each row in reverse, count # of valid submatrices that start at that cell\\r\\n\\t\\t\\tfor (int r = row_num - 1; r >= 0; r--) {\\r\\n\\t\\t\\t\\t// if we encounter a diff number, just up & reset everything\\r\\n\\t\\t\\t\\tif (grid[r][c] != curr) {\\r\\n\\t\\t\\t\\t\\tcurr = grid[r][c];\\r\\n\\t\\t\\t\\t\\tcurr_sum = 0;\\r\\n\\t\\t\\t\\t\\trel_streaks = vector<pair<int, int>>();\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t * the total # of elements that were killed\\r\\n\\t\\t\\t\\t * between this element & the last one\\r\\n\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\tint popped = 0;\\r\\n\\t\\t\\t\\t// while this current row can possibly be a chokehold\\r\\n\\t\\t\\t\\twhile (!rel_streaks.empty()\\r\\n\\t\\t\\t\\t\\t\\t&& longest_consec[r][c] < rel_streaks.back().first) {\\r\\n\\t\\t\\t\\t\\t// subtract the # of rectangles this chokehold made invalid\\r\\n\\t\\t\\t\\t\\tcurr_sum -= (rel_streaks.back().second + 1)\\r\\n\\t\\t\\t\\t\\t\\t\\t* (rel_streaks.back().first - longest_consec[r][c]);\\r\\n\\t\\t\\t\\t\\t// add the number of kills this one got & kill this one itself\\r\\n\\t\\t\\t\\t\\tpopped += rel_streaks.back().second + 1;\\r\\n\\t\\t\\t\\t\\trel_streaks.pop_back();\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\trel_streaks.push_back({longest_consec[r][c], popped});\\r\\n\\t\\t\\t\\t// add the submatrices of height 1\\r\\n\\t\\t\\t\\tcurr_sum += longest_consec[r][c];\\r\\n\\t\\t\\t\\ttotal += curr_sum;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tcout << total << '\\\\n';\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class Rectangles {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader read = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tint testNum = Integer.parseInt(read.readLine());\\r\\n\\t\\tfor (int t = 0; t < testNum; t++) {\\r\\n\\t\\t\\tStringTokenizer initial = new StringTokenizer(read.readLine());\\r\\n\\t\\t\\tint rowNum = Integer.parseInt(initial.nextToken());\\r\\n\\t\\t\\tint colNum = Integer.parseInt(initial.nextToken());\\r\\n\\t\\t\\tint[][] grid = new int[rowNum][];\\r\\n\\t\\t\\tfor (int r = 0; r < rowNum; r++) {\\r\\n\\t\\t\\t\\tgrid[r] = Arrays.stream(read.readLine().split(\\\" \\\"))\\r\\n\\t\\t\\t\\t\\t\\t.mapToInt(Integer::parseInt).toArray();\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tint[][] longestConsec = new int[rowNum][colNum];\\r\\n\\t\\t\\tfor (int r = 0; r < rowNum; r++) {\\r\\n\\t\\t\\t\\tint curr = -1;\\r\\n\\t\\t\\t\\tint streak = 0;\\r\\n\\t\\t\\t\\tfor (int c = colNum - 1; c >= 0; c--) {\\r\\n\\t\\t\\t\\t\\tif (grid[r][c] == curr) {\\r\\n\\t\\t\\t\\t\\t\\tstreak++;\\r\\n\\t\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\t\\tcurr = grid[r][c];\\r\\n\\t\\t\\t\\t\\t\\tstreak = 1;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tlongestConsec[r][c] = streak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tlong total = 0;\\r\\n\\t\\t\\tfor (int c = 0; c < colNum; c++) {\\r\\n\\t\\t\\t\\tStack<int[]> relStreaks = new Stack<>();\\r\\n\\t\\t\\t\\tint currSum = 0;  // the current amt of valid submatrices\\r\\n\\t\\t\\t\\tint curr = grid[rowNum - 1][c];\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t * for each row in reverse, count the # of valid submatrices\\r\\n\\t\\t\\t\\t * that start at that cell\\r\\n\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\tfor (int r = rowNum - 1; r >= 0; r--) {\\r\\n\\t\\t\\t\\t\\t// if we encounter a diff number, just up & reset everything\\r\\n\\t\\t\\t\\t\\tif (grid[r][c] != curr) {\\r\\n\\t\\t\\t\\t\\t\\tcurr = grid[r][c];\\r\\n\\t\\t\\t\\t\\t\\tcurrSum = 0;\\r\\n\\t\\t\\t\\t\\t\\trelStreaks = new Stack<>();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t * the total # of elements that were killed\\r\\n\\t\\t\\t\\t\\t * between this element & the last one\\r\\n\\t\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\t\\tint popped = 0;\\r\\n\\t\\t\\t\\t\\t// while this current row can possibly be a chokehold\\r\\n\\t\\t\\t\\t\\twhile (!relStreaks.isEmpty()\\r\\n\\t\\t\\t\\t\\t\\t\\t&& longestConsec[r][c] < relStreaks.peek()[0]) {\\r\\n\\t\\t\\t\\t\\t\\t// subtract the number of rectangles this chokehold made invalid\\r\\n\\t\\t\\t\\t\\t\\tcurrSum -= (relStreaks.peek()[1] + 1)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t* (relStreaks.peek()[0] - longestConsec[r][c]);\\r\\n\\t\\t\\t\\t\\t\\t// add the number of kills this one got & kill this one itself\\r\\n\\t\\t\\t\\t\\t\\tpopped += relStreaks.peek()[1] + 1;\\r\\n\\t\\t\\t\\t\\t\\trelStreaks.pop();\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\trelStreaks.add(new int[] {longestConsec[r][c], popped});\\r\\n\\t\\t\\t\\t\\tcurrSum += longestConsec[r][c];  // add the submatrices of height 1\\r\\n\\t\\t\\t\\t\\ttotal += currSum;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tSystem.out.println(total);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cfgym-101102D","source":"CF","title":"Rectangles","author":"Kevin Sheng"},"parent":{"name":"cfgym-101102D","relativePath":"cfgym-101102D.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"stacks","title":"Stacks"}}}}]},"problemInfo":{"uniqueId":"cfgym-101102D","url":"https://codeforces.com/gym/101102/problem/D"}},"pageContext":{"id":"cfgym-101102D"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}