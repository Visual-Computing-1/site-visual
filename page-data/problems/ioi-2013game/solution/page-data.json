{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/ioi-2013game/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"ioi-13-game\", source = \"IOI 2013\", title = \"Game\", author = \"Andi Qu\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    em: \"em\",\n    h2: \"h2\",\n    a: \"a\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    HeaderLink: _missingComponent(\"HeaderLink\")\n  }, _props.components), {MATHSPAN, HeaderLink, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(Q \\\\log R \\\\cdot \\\\log C)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>Q</mi><mi>log</mi><mo>⁡</mo><mi>R</mi><mo>⋅</mo><mi>log</mi><mo>⁡</mo><mi>C</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(Q \\\\log R \\\\cdot \\\\log C)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">Q</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.00773em;\\\">R</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We're asked to handle point updates and range GCD queries on a 2D grid. This\\r\\nimplies that we should use a 2D range-query data structure like a 2D segment\\r\\ntree (N.B. not a Fenwick tree, as the GCD function has no inverse).\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In 1D (\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"C = 1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>C</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">C = 1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \"), this can be solved by a fairly straightforward use of a segment\\r\\ntree: each node stores the GCD of its two children. Since \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"R\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\\\"application/x-tex\\\">R</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.00773em;\\\">R</span></span></span></span>\"\n      }), \" can be quite big,\\r\\nthis needs to be a sparse segment tree; another alternative would be a balanced\\r\\nbinary tree like a treap.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, a sparse 2D segment tree uses \", _jsx(_components.em, {\n        children: \"just\"\n      }), \" a bit too much memory, and only\\r\\nscores 80 points. Fortunately for us, there are two ways to get around this!\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"approach-1---sparse-segment-tree-of-bbsts\",\n      children: [_jsx(_components.a, {\n        href: \"#approach-1---sparse-segment-tree-of-bbsts\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Approach 1 - Sparse segment tree of BBSTs\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Although BBSTs use 4 times less memory than segment trees, a BBST of BBSTs (e.g.\\r\\na \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Range_tree\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"range tree\"\n      }), \") is rather unpleasant\\r\\nto implement. However, a segment tree of BBSTs is much nicer to implement, and\\r\\nis good enough to score 100 points!\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In my implementation below, I use an\\r\\n\", _jsx(_components.a, {\n        href: \"https://cp-algorithms.com/data_structures/treap.html#toc-tgt-6\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"implicit treap\"\n      }), \"\\r\\nbecause they support point updates and range queries. Each segment tree node\\r\\nstores a treap, and updating a node involves changing \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(\\\\log C)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>log</mi><mo>⁡</mo><mi>C</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(\\\\log C)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \"\\r\\nvalues in its treap (similar to updating a 2D segment tree node).\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include \\\"game.h\\\"\\r\\n\\r\\n#include <bits/stdc++.h>\\r\\ntypedef long long ll;\\r\\nusing namespace std;\\r\\n\\r\\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\\r\\nint rnd() { return ((rand() % (1 << 15)) << 16) + (rand() % (1 << 15)); }\\r\\n\\r\\nstruct TreapNode {\\r\\n\\tTreapNode *l, *r;\\r\\n\\tint pos, key, mn, mx;\\r\\n\\tll val, g;\\r\\n\\r\\n\\tTreapNode(int position, ll value) {\\r\\n\\t\\tl = r = nullptr;\\r\\n\\t\\tmn = mx = pos = position;\\r\\n\\t\\tkey = rnd();\\r\\n\\t\\tval = g = value;\\r\\n\\t}\\r\\n\\r\\n\\tvoid update() {\\r\\n\\t\\tg = val;\\r\\n\\t\\tif (l) g = gcd(g, l->g);\\r\\n\\t\\tif (r) g = gcd(g, r->g);\\r\\n\\t\\tmn = (l ? l->mn : pos);\\r\\n\\t\\tmx = (r ? r->mx : pos);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nstruct Treap {\\r\\n\\tTreapNode *root;\\r\\n\\r\\n\\tTreap() {\\r\\n\\t\\troot = nullptr;\\r\\n\\t\\tsrand(rnd());\\r\\n\\t}\\r\\n\\r\\n\\tvoid split(TreapNode *t, int pos, TreapNode *&l, TreapNode *&r) {\\r\\n\\t\\tif (t == nullptr) {\\r\\n\\t\\t\\tl = r = nullptr;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tif (t->pos < pos) {\\r\\n\\t\\t\\tsplit(t->r, pos, l, r);\\r\\n\\t\\t\\tt->r = l;\\r\\n\\t\\t\\tl = t;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tsplit(t->l, pos, l, r);\\r\\n\\t\\t\\tt->l = r;\\r\\n\\t\\t\\tr = t;\\r\\n\\t\\t}\\r\\n\\t\\tt->update();\\r\\n\\t}\\r\\n\\r\\n\\tTreapNode* merge(TreapNode *l, TreapNode *r) {\\r\\n\\t\\tif (!l || !r) return l ? l : r;\\r\\n\\t\\tif (l->key < r->key) {\\r\\n\\t\\t\\tl->r = merge(l->r, r);\\r\\n\\t\\t\\tl->update();\\r\\n\\t\\t\\treturn l;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tr->l = merge(l, r->l);\\r\\n\\t\\t\\tr->update();\\r\\n\\t\\t\\treturn r;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tbool find(int pos) {\\r\\n\\t\\tTreapNode *t = root;\\r\\n\\t\\twhile (t) {\\r\\n\\t\\t\\tif (t->pos == pos) return true;\\r\\n\\t\\t\\tif (t->pos > pos) t = t->l;\\r\\n\\t\\t\\telse t = t->r;\\r\\n\\t\\t}\\r\\n\\t\\treturn false;\\r\\n\\t}\\r\\n\\r\\n\\tvoid update(TreapNode *t, int pos, ll val) {\\r\\n\\t\\tif (t->pos == pos) {\\r\\n\\t\\t\\tt->val = val;\\r\\n\\t\\t\\tt->update();\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\tif (t->pos > pos) update(t->l, pos, val);\\r\\n\\t\\telse update(t->r, pos, val);\\r\\n\\t\\tt->update();\\r\\n\\t}\\r\\n\\r\\n\\tvoid insert(int pos, ll val) {\\r\\n\\t\\tif (find(pos)) update(root, pos, val);\\r\\n\\t\\telse {\\r\\n\\t\\t\\tTreapNode *l, *r;\\r\\n\\t\\t\\tsplit(root, pos, l, r);\\r\\n\\t\\t\\troot = merge(merge(l, new TreapNode(pos, val)), r);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tll query(TreapNode *t, int st, int en) {\\r\\n\\t\\tif (t->mx < st || en < t->mn) return 0;\\r\\n\\t\\tif (st <= t->mn && t->mx <= en) return t->g;\\r\\n\\r\\n\\t\\tll ans = (st <= t->pos && t->pos <= en ? t->val : 0);\\r\\n\\t\\tif (t->l) ans = gcd(ans, query(t->l, st, en));\\r\\n\\t\\tif (t->r) ans = gcd(ans, query(t->r, st, en));\\r\\n\\t\\treturn ans;\\r\\n\\t}\\r\\n\\tll query(int st, int en) {\\r\\n\\t\\tif (!root) return 0;\\r\\n\\t\\treturn query(root, st, en);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nstruct Segtree {\\r\\n\\tSegtree *l, *r;\\r\\n\\tTreap treap;\\r\\n\\tint lo, hi;\\r\\n\\r\\n\\tSegtree() { l = r = nullptr; }\\r\\n\\tSegtree(int st, int en) {\\r\\n\\t\\tl = r = nullptr;\\r\\n\\t\\tlo = st, hi = en;\\r\\n\\t}\\r\\n\\r\\n\\tvoid new_left() {\\r\\n\\t\\tif (!l) l = new Segtree(lo, (lo + hi) / 2);\\r\\n\\t}\\r\\n\\tvoid new_right() {\\r\\n\\t\\tif (!r) r = new Segtree((lo + hi) / 2 + 1, hi);\\r\\n\\t}\\r\\n\\tvoid fix(int pos) {\\r\\n\\t\\tll val = 0;\\r\\n\\t\\tif (l) val = gcd(val, l->treap.query(pos, pos));\\r\\n\\t\\tif (r) val = gcd(val, r->treap.query(pos, pos));\\r\\n\\t\\ttreap.insert(pos, val);\\r\\n\\t}\\r\\n\\r\\n\\tvoid update(int x, int y, ll val) {\\r\\n\\t\\tif (hi < x || x < lo) return;\\r\\n\\t\\tif (lo == hi) {\\r\\n\\t\\t\\ttreap.insert(y, val);\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (x <= (lo + hi) / 2) {\\r\\n\\t\\t\\tnew_left();\\r\\n\\t\\t\\tl->update(x, y, val);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tnew_right();\\r\\n\\t\\t\\tr->update(x, y, val);\\r\\n\\t\\t}\\r\\n\\t\\tfix(y);\\r\\n\\t}\\r\\n\\r\\n\\tll query(int t, int b, int st, int en) {\\r\\n\\t\\tif (hi < t || b < lo) return 0;\\r\\n\\t\\tif (t <= lo && hi <= b) return treap.query(st, en);\\r\\n\\r\\n\\t\\tll ans = 0;\\r\\n\\t\\tif (l) ans = gcd(ans, l->query(t, b, st, en));\\r\\n\\t\\tif (r) ans = gcd(ans, r->query(t, b, st, en));\\r\\n\\t\\treturn ans;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nSegtree segtree;\\r\\n\\r\\nvoid init(int R, int C) {\\r\\n\\tsrand(12341234);\\r\\n\\tsegtree = Segtree(0, R - 1);\\r\\n}\\r\\n\\r\\nvoid update(int P, int Q, ll K) { segtree.update(P, Q, K); }\\r\\n\\r\\nll calculate(int P, int Q, int U, int V) {\\r\\n\\treturn segtree.query(P, U, Q, V);\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"approach-2---memory-optimized-2d-sparse-segment-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#approach-2---memory-optimized-2d-sparse-segment-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Approach 2 - Memory-optimized 2D sparse segment tree\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Although the previous approach is somewhat simpler, this approach was intended,\\r\\nand involves optimizing the memory usage of a sparse segment tree from\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(N \\\\log(\\\\text{size of range}))\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mo stretchy=\\\"false\\\">(</mo><mtext>size of range</mtext><mo stretchy=\\\"false\\\">)</mo><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(N \\\\log(\\\\text{size of range}))</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mopen\\\">(</span><span class=\\\"mord text\\\"><span class=\\\"mord\\\">size of range</span></span><span class=\\\"mclose\\\">))</span></span></span></span>\"\n      }), \" to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Essentially, we don't instantiate nodes in the segment tree if they are not leaf\\r\\nnodes and only contain a single leaf node in their subtree, as those nodes are\\r\\nredundant. What we end up with is a segment tree with \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\\\"application/x-tex\\\">N</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span>\"\n      }), \" leaves and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"2N - 1\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">2N - 1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">2</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n      }), \"\\r\\nnodes. See \", _jsx(_components.a, {\n        href: \"/plat/sparse-seg?lang=cpp#solution\",\n        children: \"the sparse segment tree module\"\n      }), \"\\r\\nfor more details.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Note that we can only apply this trick to the segment trees of the \", _jsx(_components.strong, {\n        children: \"columns\"\n      }), \".\\r\\nThis means that the memory complexity is \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(Q \\\\log R)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>Q</mi><mi>log</mi><mo>⁡</mo><mi>R</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(Q \\\\log R)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">Q</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.00773em;\\\">R</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \", which is good\\r\\nenough to score 100 points.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include \\\"game.h\\\"\\r\\n#include <stdlib.h>\\r\\n\\r\\ntypedef long long ll;\\r\\n\\r\\nstatic int R, C;\\r\\n\\r\\nstruct X_NODE {\\r\\n\\tX_NODE(int s, int e): s(s), e(e), left(NULL), right(NULL), value(0LL) {}\\r\\n\\tint s, e;\\r\\n\\tX_NODE *left, *right;\\r\\n\\tll value;\\r\\n};\\r\\n\\r\\nstruct Y_NODE {\\r\\n\\tY_NODE(): left(NULL), right(NULL), xtree(1,C) {}\\r\\n\\tY_NODE *left, *right;\\r\\n\\tX_NODE xtree;\\r\\n} *root;\\r\\n\\r\\nll gcd2(ll x, ll y) {\\r\\n\\tif (y == 0) return x;\\r\\n\\treturn gcd2(y, x % y);\\r\\n}\\r\\n\\r\\nvoid init(int r,int c) {\\r\\n\\tR = r, C = c;\\r\\n\\troot = new Y_NODE();\\r\\n}\\r\\n\\r\\nvoid update2(X_NODE *node, int q, ll k) {\\r\\n\\tint s = node->s, e = node->e, m = (s + e) >> 1;\\r\\n\\tif (s == e) {\\r\\n\\t\\tnode->value = k;\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\tX_NODE **child = &(q <= m ? node->left : node->right);\\r\\n\\tif (*child == NULL) {\\r\\n\\t\\t*child = new X_NODE(q, q);\\r\\n\\t\\t(*child)->value = k;\\r\\n\\t} else if ((*child)->s <= q && q <= (*child)->e) {\\r\\n\\t\\tupdate2(*child, q, k);\\r\\n\\t} else {\\r\\n\\t\\tdo {\\r\\n\\t\\t\\tif (q <= m) e = m;\\r\\n\\t\\t\\telse s = m + 1;\\r\\n\\t\\t\\tm = (s + e) >> 1;\\r\\n\\t\\t} while ((q <= m) == ((*child)->e <= m));\\r\\n\\t\\tX_NODE *nnode = new X_NODE(s, e);\\r\\n\\t\\tif ((*child)->e <= m) nnode->left = *child;\\r\\n\\t\\telse nnode->right = *child;\\r\\n\\t\\t*child = nnode;\\r\\n\\t\\tupdate2(*child, q, k);\\r\\n\\t}\\r\\n\\tnode->value = gcd2(\\r\\n\\t\\tnode->left ? node->left->value : 0,\\r\\n\\t\\tnode->right ? node->right->value : 0\\r\\n\\t);\\r\\n}\\r\\n\\r\\nll query2(X_NODE *node, int s, int e) {\\r\\n\\tif (node == NULL || node->s > e || node->e < s) return 0;\\r\\n\\tif (s <= node->s && node->e <= e){\\r\\n\\t\\treturn node->value;\\r\\n\\t}\\r\\n\\treturn gcd2(query2(node->left, s, e), query2(node->right, s, e));\\r\\n}\\r\\n\\r\\nvoid update1(Y_NODE *node, int s, int e, int p, int q, ll k) {\\r\\n\\tint m = (s + e) >> 1;\\r\\n\\tif (s == e) {\\r\\n\\t\\tupdate2(&node->xtree, q, k);\\r\\n\\t\\treturn;\\r\\n\\t}\\r\\n\\tif (p <= m) {\\r\\n\\t\\tif (node->left == NULL) node->left = new Y_NODE();\\r\\n\\t\\tupdate1(node->left, s, m, p, q, k);\\r\\n\\t} else {\\r\\n\\t\\tif (node->right == NULL) node->right = new Y_NODE();\\r\\n\\t\\tupdate1(node->right, m+1, e, p, q, k);\\r\\n\\t}\\r\\n\\tll v = gcd2(\\r\\n\\t\\tnode->left ? query2(&node->left->xtree, q, q) : 0,\\r\\n\\t\\tnode->right ? query2(&node->right->xtree, q, q) : 0\\r\\n\\t);\\r\\n\\tupdate2(&node->xtree, q, v);\\r\\n}\\r\\n\\r\\nvoid update(int p, int q, ll k) {\\r\\n\\t++p, ++q;\\r\\n\\tupdate1(root, 1, R, p, q, k);\\r\\n}\\r\\n\\r\\nll query1(Y_NODE *node, int s, int e, int p, int q, int u, int v) {\\r\\n\\tif (node == NULL || s > u || e < p) return 0;\\r\\n\\tif (p <= s && e <= u) return query2(&node->xtree, q, v);\\r\\n\\tint m = (s + e) >> 1;\\r\\n\\treturn gcd2(\\r\\n\\t\\tquery1(node->left, s, m, p, q, u, v),\\r\\n\\t\\tquery1(node->right, m + 1, e, p, q, u, v)\\r\\n\\t);\\r\\n}\\r\\n\\r\\nll calculate(int p, int q, int u, int v) {\\r\\n\\t++p, ++q, ++u, ++v;\\r\\n\\treturn query1(root, 1, R, p, q, u, v);\\r\\n}\\n\"\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"ioi-13-game","source":"IOI 2013","title":"Game","author":"Andi Qu"},"parent":{"name":"ioi-13-game","relativePath":"ioi-13-game.mdx"},"toc":{"cpp":[{"depth":2,"value":"Approach 1 - Sparse segment tree of BBSTs","slug":"approach-1---sparse-segment-tree-of-bbsts"},{"depth":2,"value":"Approach 2 - Memory-optimized 2D sparse segment tree","slug":"approach-2---memory-optimized-2d-sparse-segment-tree"}],"java":[{"depth":2,"value":"Approach 1 - Sparse segment tree of BBSTs","slug":"approach-1---sparse-segment-tree-of-bbsts"},{"depth":2,"value":"Approach 2 - Memory-optimized 2D sparse segment tree","slug":"approach-2---memory-optimized-2d-sparse-segment-tree"}],"py":[{"depth":2,"value":"Approach 1 - Sparse segment tree of BBSTs","slug":"approach-1---sparse-segment-tree-of-bbsts"},{"depth":2,"value":"Approach 2 - Memory-optimized 2D sparse segment tree","slug":"approach-2---memory-optimized-2d-sparse-segment-tree"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"2DRQ","title":"2D Range Queries"}}}}]},"problemInfo":{"uniqueId":"ioi-13-game","url":"https://oj.uz/problem/view/IOI13_game"}},"pageContext":{"id":"ioi-13-game"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}