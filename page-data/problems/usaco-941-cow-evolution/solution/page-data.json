{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-941-cow-evolution/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-941\", source = \"USACO Bronze 2019 Open\", title = \"Cow Evolution\", author = \"Jesse Choe, Ryan Chou, Chuyang Wang, Vivian Han\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    span: \"span\",\n    img: \"img\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Youtube: _missingComponent(\"Youtube\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {HeaderLink, Youtube, MATHSPAN, LanguageSection, PySection, JavaSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"solution\",\n      children: [_jsx(_components.a, {\n        href: \"#solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_evolution_bronze_open19.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"video-solution\",\n      children: [_jsx(_components.a, {\n        href: \"#video-solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Video Solution\"]\n    }), \"\\n\", _jsx(Youtube, {\n      id: \"4YTijr0BbrA\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"explanation\",\n      children: [_jsx(_components.a, {\n        href: \"#explanation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Explanation\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"First, it may help to think of an instance where we cannot form a proper evolutionary tree. This would be an instance such that no matter how we form the tree, it would be inevitable that some characteristic would evolve in two distinct places in the tree. It turns out that the minimal such bad example looks like this:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{population1: A } \\\\\\\\\\r \\\\texttt{population2: B } \\\\\\\\\\r \\\\texttt{population3: A B}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mrow><mtext mathvariant=\\\"monospace\\\">population1:</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">A</mtext><mtext> </mtext></mrow><mspace linebreak=\\\"newline\\\"></mspace><mrow><mtext mathvariant=\\\"monospace\\\">population2:</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">B</mtext><mtext> </mtext></mrow><mspace linebreak=\\\"newline\\\"></mspace><mrow><mtext mathvariant=\\\"monospace\\\">population3:</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">A</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">B</mtext></mrow></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{population1: A } \\\\\\\\\\r \\\\texttt{population2: B } \\\\\\\\\\r \\\\texttt{population3: A B}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">population1: A </span></span></span><span class=\\\"mspace newline\\\"></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">population2: B </span></span></span><span class=\\\"mspace newline\\\"></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">population3: A B</span></span></span></span></span>\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"In other words, we have a population with just trait \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \", a population with just trait \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \", and a population with both. If we want to build a tree out of this input, we would need to split on either \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \" or \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \" at the root, but then the remaining two subtrees would both need to have an edge that adds the other characteristic. For example, if the root split into \\\"\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \"\\\" and \\\"not \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \"\\\" branches, then both branches would need to contain an edge that adds the \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \" trait.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It will help to actually look at things from the viewpoint of the characteristics instead of from the viewpoint of the populations, so let's \\\"transpose\\\" the input above:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{A: population1 population3 } \\\\\\\\\\r \\\\texttt{B: population2 population3}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mrow><mtext mathvariant=\\\"monospace\\\">A:</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">population1</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">population3</mtext><mtext> </mtext></mrow><mspace linebreak=\\\"newline\\\"></mspace><mrow><mtext mathvariant=\\\"monospace\\\">B:</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">population2</mtext><mtext> </mtext><mtext mathvariant=\\\"monospace\\\">population3</mtext></mrow></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{A: population1 population3 } \\\\\\\\\\r \\\\texttt{B: population2 population3}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">A: population1 population3 </span></span></span><span class=\\\"mspace newline\\\"></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8333em;vertical-align:-0.2222em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">B: population2 population3</span></span></span></span></span>\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The fundamental problem here is that there are populations in \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \" only, populations in \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \" only, and populations in both \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \". If we look at the Venn diagram for the sets \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \", the picture therefore looks like this:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.span, {\n        className: \"gatsby-resp-image-wrapper\",\n        style: {\n          position: \"relative\",\n          display: \"block\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          maxWidth: \"156px\"\n        },\n        children: [\"\\n      \", _jsxs(_components.a, {\n          className: \"gatsby-resp-image-link\",\n          href: \"/visual-site/static/5c82609dcc55eb75da1eee1c0642a342/2863b/venn_1.png\",\n          style: {\n            display: \"block\"\n          },\n          target: \"_blank\",\n          rel: \"noopener\",\n          children: [\"\\n    \", _jsx(_components.span, {\n            className: \"gatsby-resp-image-background-image\",\n            style: {\n              paddingBottom: \"53.84615384615385%\",\n              position: \"relative\",\n              bottom: \"0\",\n              left: \"0\",\n              backgroundImage: \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABLklEQVQoz31S7XLCIBD0/R9CX6y2o5OYxAQ4OOD4utDRZKyNtjf8Ydm9L3ZX/475Hv8Qds9UY0MvcZDYCwRLixgs9RKXgz6+EefC7aiF9hSzo0gxK6TTAOcBFNIDHMF1wjzaWcXNVfuQNl19tOJ4ERvQuNAJc+t0EVuKg7LLnZn7vq+1giVpvNDO+Ejkm6ZZRqu1tpOJuayVR3DS+CWxUmq/35ecwAaFXhrv0/z1eTwcDsy8cpDA0io2LlzBLg8hBIPIpWgXFJJCDzZwyUKIe+UbpxMYYv6Z+TxATGUz3mmAU682oA+pHfWvhYWUz1fQLqRc6jynXKyPx9vCpKWYcpnvoEJqRsiFt//MPAvtuslcJtMJM2lXmAvzBLYTKyiNf7bN7tU3zPOrw/id1b4BkUl/zT2ZddEAAAAASUVORK5CYII=')\",\n              backgroundSize: \"cover\",\n              display: \"block\"\n            }\n          }), \"\\n  \", _jsx(_components.img, {\n            className: \"gatsby-resp-image-image\",\n            alt: \"Venn Diagram 1\",\n            title: \"Venn Diagram 1\",\n            src: \"/visual-site/static/5c82609dcc55eb75da1eee1c0642a342/2863b/venn_1.png\",\n            srcSet: \"/visual-site/static/5c82609dcc55eb75da1eee1c0642a342/2863b/venn_1.png 156w\",\n            sizes: \"(max-width: 156px) 100vw, 156px\",\n            style: {\n              width: \"100%\",\n              height: \"100%\",\n              margin: \"0\",\n              verticalAlign: \"middle\",\n              position: \"absolute\",\n              top: \"0\",\n              left: \"0\"\n            },\n            loading: \"lazy\"\n          }), \"\\n  \"]\n        }), \"\\n    \"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's call this situation a \\\"crossing\\\" pair of sets. In general, two sets can be disjoint (no overlap), nesting (one inside the other), or crossing (overlap but not nesting). If any two of the characteristics \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \" in our instance represent crossing sets as above, then we cannot build a proper tree. On the other hand, if all the characteristics represent sets that don't cross (they are either disjoint or nested), then we get a Venn diagram like this:\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.span, {\n        className: \"gatsby-resp-image-wrapper\",\n        style: {\n          position: \"relative\",\n          display: \"block\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          maxWidth: \"343px\"\n        },\n        children: [\"\\n      \", _jsxs(_components.a, {\n          className: \"gatsby-resp-image-link\",\n          href: \"/visual-site/static/bfeaf9322a5c536b2b678c8347d4bd8f/56e50/venn_2.png\",\n          style: {\n            display: \"block\"\n          },\n          target: \"_blank\",\n          rel: \"noopener\",\n          children: [\"\\n    \", _jsx(_components.span, {\n            className: \"gatsby-resp-image-background-image\",\n            style: {\n              paddingBottom: \"48.07692307692307%\",\n              position: \"relative\",\n              bottom: \"0\",\n              left: \"0\",\n              backgroundImage: \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABRklEQVQoz0WS61KEMAyFef+nVNdVXBZZSnNPE6fgQKd/mqYn30k6ZGZEsDqQIimQAvct5hl5LhRbgQoQsp3BwbwV4Fel14YkmplA8tpwQ6kkEV2gtVbZlmWZpgeKm/v/44K8oZDY++1WgMTb+Px9u31ZS1HbkI88EkNW3KGuykCyX8jH/buSAKt5I7GjJpCot8wU82WjuWB3pHZhA+tzrbf7OBdktYjLLLKyGrBWUvPdQkQ/ovTHPRZRSVZUUUfR+/ioF60WYLH2M81vn1+nKImR2FCAD8IK1d1RbPp9HcLmbcNupEUspT7mpUWQmHuYt0rSK69ALfL5nBExM711NVZbgfchdXJTjcyK/DlOKNYZWYc9u8tgJ3HYW1pQUPQgisgVeHxMrbl5WytVkg0lIoez7xGh5mrXGM+10/puQfpf6rPo3f4DrClHu/ye5O8AAAAASUVORK5CYII=')\",\n              backgroundSize: \"cover\",\n              display: \"block\"\n            }\n          }), \"\\n  \", _jsx(_components.img, {\n            className: \"gatsby-resp-image-image\",\n            alt: \"Venn Diagram 2\",\n            title: \"Venn Diagram 2\",\n            src: \"/visual-site/static/bfeaf9322a5c536b2b678c8347d4bd8f/56e50/venn_2.png\",\n            srcSet: \"/visual-site/static/bfeaf9322a5c536b2b678c8347d4bd8f/f29da/venn_2.png 208w, /visual-site/static/bfeaf9322a5c536b2b678c8347d4bd8f/56e50/venn_2.png 343w\",\n            sizes: \"(max-width: 343px) 100vw, 343px\",\n            style: {\n              width: \"100%\",\n              height: \"100%\",\n              margin: \"0\",\n              verticalAlign: \"middle\",\n              position: \"absolute\",\n              top: \"0\",\n              left: \"0\"\n            },\n            loading: \"lazy\"\n          }), \"\\n  \"]\n        }), \"\\n    \"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you look at this picture carefully, hopefully you see a tree formed by the nesting structure of the sets:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.span, {\n        className: \"gatsby-resp-image-wrapper\",\n        style: {\n          position: \"relative\",\n          display: \"block\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          maxWidth: \"192px\"\n        },\n        children: [\"\\n      \", _jsxs(_components.a, {\n          className: \"gatsby-resp-image-link\",\n          href: \"/visual-site/static/4abb259dba19b9bbd79eb6345a4aa526/3b721/tree_1.png\",\n          style: {\n            display: \"block\"\n          },\n          target: \"_blank\",\n          rel: \"noopener\",\n          children: [\"\\n    \", _jsx(_components.span, {\n            className: \"gatsby-resp-image-background-image\",\n            style: {\n              paddingBottom: \"86.97916666666667%\",\n              position: \"relative\",\n              bottom: \"0\",\n              left: \"0\",\n              backgroundImage: \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACO0lEQVQ4y5WTW0/TYBjH98n8EsTLeSAxJIvIBSaGeEe8MF4ZDxizKbhNmWJGIqhEEDDBiIa5Uw87sbXd3q4btd162Nat7/uYtjAnzojPRdO+fX79P4d/fTAuiHtdPUA3V3I51HZOCPkzzTeGdNPapnUxlD13J3l3owwANj4DjAmxbQwAHUMP7+RvxKi99KF3PsDklL7vVLXea13XBUEAALkptVQFITTazhjY+2hB1N4nUYUXAEhJMpY/5YzewNBa9GH1I91smdYw8xfsPctad+YFO7nIxPYRtgezy0zgeeHxdgUA5uPsxEL23mbFbeF32JuH2e3Px5lAmF4/4AHI7bViIEyvfRcBILTL+4PZpe08AAxsgt18nyfrtar8kLlaPVOs1qqCrmuWTQTZGLjzM7sWVao23PA2R06UCVK6YlNp1MVOb5DKcTbGNYGvHbVVs++Vppm9BOvULIkoW24Isnms/LUoX4/lbq3SqmY+2KxcWaTWk3VOUq+FM1cjdEnSAeDhVnk6yr5LSWWpdSmYmnpGc03dgd8k0OUldvZlXlLNuRV24hEV3OEoQZ18ypxfSCfKCgCZe8X6nzChXa5U1/zBzIVgpiRpDmzZOP65mOUVAOCaxka6rnWcar8UjvaLsrcJvmm8TYreqiihlRcdz/q8USGELMsatQv5u+eH944yXW3NRKn7H8q2uwHbPnahjcnQ0qP2xJhgcrKq199qU5H8dJSRte6ogf4ZDqx1+pE93mnvf8jxv+TZ4Z/xjaw5xyoP4wAAAABJRU5ErkJggg==')\",\n              backgroundSize: \"cover\",\n              display: \"block\"\n            }\n          }), \"\\n  \", _jsx(_components.img, {\n            className: \"gatsby-resp-image-image\",\n            alt: \"Evolution tree diagram\",\n            title: \"Evolution tree diagram\",\n            src: \"/visual-site/static/4abb259dba19b9bbd79eb6345a4aa526/3b721/tree_1.png\",\n            srcSet: \"/visual-site/static/4abb259dba19b9bbd79eb6345a4aa526/3b721/tree_1.png 192w\",\n            sizes: \"(max-width: 192px) 100vw, 192px\",\n            style: {\n              width: \"100%\",\n              height: \"100%\",\n              margin: \"0\",\n              verticalAlign: \"middle\",\n              position: \"absolute\",\n              top: \"0\",\n              left: \"0\"\n            },\n            loading: \"lazy\"\n          }), \"\\n  \"]\n        }), \"\\n    \"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A tree like this is easy to convert into a proper evolutionary tree. E.g., if we have three children \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \", \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \", and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"C\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\\\"application/x-tex\\\">C</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span></span></span></span>\"\n      }), \", we could just make three sequential two-way splits that add the \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"A\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\\\"application/x-tex\\\">A</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\">A</span></span></span></span>\"\n      }), \", \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"B\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\\\"application/x-tex\\\">B</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.05017em;\\\">B</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"C\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\\\"application/x-tex\\\">C</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span></span></span></span>\"\n      }), \" characteristics.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So we actually don't need to build a proper evolutionary tree, but we just need to test if any of our characteristics represent crossing sets; if so (and only if so), a proper tree is impossible to build. This leads to probably the easiest solution of the problem, shown in my code below where I build all the sets of populations having each characteristic and then just test if any pair of these sets is crossing.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\nsys.stdin = open('evolution.in', 'r')\\r\\nsys.stdout = open('evolution.out', 'w')\\r\\n\\r\\nn = int(input())\\r\\ncows = []\\r\\nallchars = set()\\r\\n\\r\\nfor i in range(n):\\r\\n\\tline = input().split()\\r\\n\\tchars = list(line[1:])\\r\\n\\tcows.append(chars)\\r\\n\\tallchars.update(chars)\\r\\n\\r\\nallchars = list(allchars)\\r\\n\\r\\n# Check if the tree is evolutionarily proper relative to characteristics a and b\\r\\ndef scan(a, b):\\r\\n\\t\\\"\\\"\\\"\\\"\\r\\n\\tIf we find a cow which has the characteristic a, \\r\\n\\tanother cow which has the characteristic b, and \\r\\n\\tanother cow with both characteristics a and b, then \\r\\n\\tthe tree isn't evolutionarily proper.\\r\\n\\t\\r\\n\\tReturns a boolean\\r\\n\\t\\\"\\\"\\\"\\r\\n\\tonlya, onlyb, both = 0, 0, 0\\r\\n\\t# Iterating through every branch.\\r\\n\\tfor i in range(n):\\r\\n\\t\\thasa, hasb = 0, 0\\r\\n\\t\\t# Iterating through the characteristics of that branch.\\r\\n\\t\\tfor j in range(len(cows[i])):\\r\\n\\t\\t\\tif cows[i][j] == allchars[a]:\\r\\n\\t\\t\\t\\thasa = 1\\r\\n\\t\\t\\tif cows[i][j] == allchars[b]:\\r\\n\\t\\t\\t\\thasb = 1\\r\\n\\t\\tif hasa and not hasb: \\r\\n\\t\\t\\tonlya = 1\\r\\n\\t\\tif hasb and not hasa:\\r\\n\\t\\t\\tonlyb = 1\\r\\n\\t\\tif hasa and hasb:\\r\\n\\t\\t\\tboth = 1\\r\\n\\treturn onlya and onlyb and both\\r\\n\\t\\r\\n# Iterating through every pair of characteristics.\\r\\nfor i in range(len(allchars)):\\r\\n\\tfor j in range(i + 1, len(allchars)):\\r\\n\\t\\tif scan(i, j):\\r\\n\\t\\t\\tprint('no')\\r\\n\\t\\t\\tsys.exit()\\r\\nprint('yes')\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class Evolution {\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader br = new BufferedReader(new FileReader(\\\"evolution.in\\\"));\\r\\n\\t\\tint popNum = Integer.parseInt(br.readLine());\\r\\n\\t\\tint nxtIdx = 0;\\r\\n\\r\\n\\t\\tboolean[][] hasChar = new boolean[25][125];\\r\\n\\t\\t// hasChar[i][j] = true if population i has characteristic j\\r\\n\\t\\tMap<String, Integer> convert = new HashMap<>();  // convert each characteristic to a number\\r\\n\\r\\n\\t\\tfor (int i = 0; i < popNum; i++) {\\r\\n\\t\\t\\tString[] line = br.readLine().split(\\\" \\\");\\r\\n\\t\\t\\tfor (int j = 1; j < line.length; j++) {\\r\\n\\t\\t\\t\\tif (!convert.containsKey(line[j])) {\\r\\n\\t\\t\\t\\t\\tconvert.put(line[j], nxtIdx++);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tint idx = convert.get(line[j]);\\r\\n\\t\\t\\t\\thasChar[i][idx] = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tbr.close();\\r\\n\\r\\n\\t\\tboolean works = true;\\r\\n\\t\\tfor (int a = 0; a < nxtIdx && works; a++) {\\r\\n\\t\\t\\tfor (int b = 0; b < a && works; b++) {  // iterate over all pairs of characteristics a and b\\r\\n\\t\\t\\t\\tint aNum = 0;  // keep track of the # pops with only a\\r\\n\\t\\t\\t\\tint bNum = 0;  // only b \\r\\n\\t\\t\\t\\tint abNum = 0;  // both a and b\\r\\n\\t\\t\\t\\tfor (int i = 0; i < popNum; i++) {\\r\\n\\t\\t\\t\\t\\tif (hasChar[i][a] && hasChar[i][b]) abNum++;\\r\\n\\t\\t\\t\\t\\telse if (hasChar[i][a]) aNum++;\\r\\n\\t\\t\\t\\t\\telse if (hasChar[i][b]) bNum++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t// if there are pops with only a, only b, AND both a and b, then the tree doesn't work\\r\\n\\t\\t\\t\\t// (see explanation if this doesn't make sense)\\r\\n\\t\\t\\t\\tworks = works && !(aNum > 0 && bNum > 0 && abNum > 0);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tBufferedWriter bw = new BufferedWriter(new FileWriter(\\\"evolution.out\\\"));\\r\\n\\t\\tbw.write((works)? \\\"yes\\\\n\\\": \\\"no\\\\n\\\");\\r\\n\\t\\tbw.close();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"// Taken from official analysis by Brian Dean\\r\\n#include <iostream>\\r\\n#include <fstream>\\r\\n#include <vector>\\r\\nusing namespace std;\\r\\n \\r\\nint N;\\r\\nconst int MAX_CHAR = 25;\\r\\nvector<string> characteristics[MAX_CHAR];  // store characteristics of each pop\\r\\nvector<string> all_characteristics;  // list all characteristics mentioned\\r\\n \\r\\n// Do two sets \\\"cross\\\" -- I.e., are there elements in A, B, and A intersect B?\\r\\nbool crossing(int a, int b) {\\r\\n\\tint A = 0, B = 0, AB = 0; // keep track of the # pops with only A, only B, both A and B\\r\\n\\tfor (int i = 0; i < N; i++) {  // check whether pop i has A and B\\r\\n\\t\\tvector<string> &v = characteristics[i];\\r\\n\\t\\tbool has_a = false, has_b = false;\\r\\n\\t\\tfor (int j = 0; j < v.size(); j++) {\\r\\n\\t\\t\\tif (v[j] == all_characteristics[a]) {\\r\\n\\t\\t\\t\\thas_a = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (v[j] == all_characteristics[b]) {\\r\\n\\t\\t\\t\\thas_b = true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}  // update counts\\r\\n\\t\\tif (has_a && has_b) {\\r\\n\\t\\t\\tAB++;\\r\\n\\t\\t} else if (has_a) {\\r\\n\\t\\t\\tA++;\\r\\n\\t\\t} else if (has_b) {\\r\\n\\t\\t\\tB++;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn AB > 0 && A > 0 && B > 0;\\r\\n}\\r\\n \\r\\nint main() {\\r\\n\\tifstream fin (\\\"evolution.in\\\");\\r\\n\\tfin >> N;\\r\\n\\tstring s;\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\tint K;\\r\\n\\t\\tfin >> K;\\r\\n\\t\\tfor (int j = 0; j < K; j++) {\\r\\n\\t\\t\\tfin >> s;\\r\\n\\t\\t\\tcharacteristics[i].push_back(s);\\r\\n\\t\\t\\tbool found = false;\\r\\n\\t\\t\\tfor (int k = 0; k < all_characteristics.size(); k++)\\r\\n\\t\\t\\t\\tif (all_characteristics[k] == s) {\\r\\n\\t\\t\\t\\t\\tfound = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\tif (!found) {\\r\\n\\t\\t\\t\\tall_characteristics.push_back(s);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tint M = all_characteristics.size();\\r\\n\\tbool ok = true;\\r\\n\\tfor (int a = 0; a < M; a++)\\r\\n\\tfor (int b = a + 1; b < M; b++)\\r\\n\\t\\tif (crossing(a, b)) {\\r\\n\\t\\t\\tok = false;\\r\\n\\t\\t}\\r\\n \\r\\n\\tofstream fout (\\\"evolution.out\\\");\\r\\n\\tfout << (ok ? \\\"yes\\\\n\\\" : \\\"no\\\\n\\\");\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-941","source":"USACO Bronze 2019 Open","title":"Cow Evolution","author":"Jesse Choe, Ryan Chou, Chuyang Wang, Vivian Han"},"parent":{"name":"usaco-941","relativePath":"usaco-941.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Video Solution","slug":"video-solution"},{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"intro-graphs","title":"Introduction to Graphs"}}}}]},"problemInfo":{"uniqueId":"usaco-941","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=941"}},"pageContext":{"id":"usaco-941"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}