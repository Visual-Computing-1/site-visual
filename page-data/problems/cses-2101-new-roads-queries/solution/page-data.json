{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-2101-new-roads-queries/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-2101\", source = \"CSES\", title = \"New Roads Queries\", author = \"Dustin Miao\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {MATHSPAN, HeaderLink, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"If we construct a graph where edges have weights equal to the time they are added, the problem boils down to efficiently finding the path with the minimum maximum edge for each query.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let's consider a single query between nodes \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u, v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi><mo separator=\\\"true\\\">,</mo><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u, v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.625em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \". One way of approaching this is to sort the edge weights from smallest to largest, and then add edges one by one until \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" are connected. If we use a \", _jsx(_components.a, {\n        href: \"/gold/dsu\",\n        children: \"disjoint set union\"\n      }), \", the time complexity for each query is \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(m \\\\cdot \\\\alpha(n))\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>m</mi><mo>⋅</mo><mi>α</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(m \\\\cdot \\\\alpha(n))</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">m</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.0037em;\\\">α</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">))</span></span></span></span>\"\n      }), \", which is too slow.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, this hints at a faster solution. Note that our slow approach bears many similarities with \", _jsx(_components.a, {\n        href: \"/gold/mst/#kruskals\",\n        children: \"Kruskal's MST algorithm\"\n      }), \", which implies that the path between \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"u\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\\\"application/x-tex\\\">u</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">u</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \" on any minimum spanning tree will minimize the maximum edge weight. For a more formal proof, see \", _jsx(_components.a, {\n        href: \"https://www.geeksforgeeks.org/minimum-bottleneck-spanning-treembst/\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"here\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All that is left to do is to efficiently query for the maximum edge on a tree path. One way to do this is with \", _jsx(_components.a, {\n        href: \"/plat/binary-jump\",\n        children: \"binary jumping\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(m \\\\cdot \\\\alpha(n) + n\\\\log n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>m</mi><mo>⋅</mo><mi>α</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo><mo>+</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(m \\\\cdot \\\\alpha(n) + n\\\\log n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">m</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.0037em;\\\">α</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\t\\r\\nconst int MAXN = 2e5;\\r\\nconst int LOGN = 18; // log of MAXN base 2\\r\\n \\r\\n// Simple DSU class with Small to Large merging\\r\\ntemplate<size_t N> struct UnionFind {\\r\\n\\tint par[N], sze[N], max_size;\\r\\n \\r\\n\\tUnionFind(int n=N) { init(n); }\\r\\n \\r\\n\\tvoid init(int n=N) {\\r\\n\\t\\tiota(par, par + n, 0);\\r\\n\\t\\tfill(sze, sze + n, 1);\\r\\n\\t\\tmax_size = 1;\\r\\n\\t}\\r\\n \\r\\n\\tint find(int a) {\\r\\n\\t\\tif (a == par[a])\\r\\n\\t\\t\\treturn a;\\r\\n\\t\\treturn par[a] = find(par[a]);\\r\\n\\t}\\r\\n \\r\\n\\tbool merge(int a, int b) {\\r\\n\\t\\ta = find(a), b = find(b);\\r\\n\\t\\tif (a == b) \\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t\\r\\n\\t\\tif (sze[a] > sze[b]) {\\r\\n\\t\\t\\tpar[b] = a;\\r\\n\\t\\t\\tsze[a] += sze[b];\\r\\n\\t\\t\\tmax_size = max(max_size, sze[a]);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\tpar[a] = b;\\r\\n\\t\\t\\tsze[b] += sze[a];\\r\\n\\t\\t\\tmax_size = max(max_size, sze[b]);\\r\\n\\t\\t}\\r\\n\\t\\treturn 1;\\r\\n\\t}\\r\\n \\r\\n\\tint size(int a) { \\r\\n\\t\\treturn sze[find(a)]; \\r\\n\\t}\\r\\n};\\r\\n \\r\\nint N, M, Q;\\r\\nvector<pair<int, int>> G[MAXN];\\r\\nUnionFind<MAXN> dsu;\\r\\n \\r\\nnamespace LCA {\\r\\n\\tint dep[MAXN], par[MAXN][LOGN], val[MAXN][LOGN];\\r\\n \\r\\n\\tvoid dfs_init(int u, int p, int d) {\\r\\n\\t\\tdep[u] = d;\\r\\n\\t\\tpar[u][0] = p;\\r\\n\\t\\tfor (auto [v, w] : G[u]) \\r\\n\\t\\t\\tif (p != v) {\\r\\n\\t\\t\\t\\tval[v][0] = w;\\r\\n\\t\\t\\t\\tdfs_init(v, u, d + 1);\\r\\n\\t\\t\\t}\\r\\n\\t}\\r\\n \\r\\n\\tvoid init() {\\r\\n\\t\\tmemset(dep, -1, sizeof(dep));\\r\\n\\t\\tmemset(par, 0, sizeof(par));\\r\\n\\t\\tmemset(val, 0, sizeof(val));\\r\\n \\r\\n\\t\\tfor (int i = 1; i <= N; i++)\\r\\n\\t\\t\\tif (dep[i] == -1)\\r\\n\\t\\t\\t\\tdfs_init(i, i, 0);\\r\\n\\t\\tfor (int k = 1; k < LOGN; k++)\\r\\n\\t\\t\\tfor (int i = 1; i <= N; i++) {\\r\\n\\t\\t\\t\\tpar[i][k] = par[par[i][k - 1]][k - 1];\\r\\n\\t\\t\\t\\tval[i][k] = max(val[i][k - 1], val[par[i][k - 1]][k - 1]);\\r\\n\\t\\t\\t}\\r\\n\\t}\\r\\n \\r\\n\\tint query(int a, int b) {\\r\\n\\t\\tif (dep[a] > dep[b])\\r\\n\\t\\t\\tswap(a, b);\\r\\n\\t\\t\\r\\n\\t\\t// gets a and b to the same depth\\r\\n\\t\\tint ans = 0;\\r\\n\\t\\tfor (int d = LOGN - 1; d >= 0; d--)\\r\\n\\t\\t\\tif (dep[b] - (1 << d) >= dep[a]) {\\r\\n\\t\\t\\t\\tans = max(ans, val[b][d]);\\r\\n\\t\\t\\t\\tb = par[b][d];\\r\\n\\t\\t\\t}\\r\\n \\r\\n\\t\\tassert(dep[a] == dep[b]);\\r\\n \\r\\n\\t\\tif (a == b) \\r\\n\\t\\t\\treturn ans;\\r\\n \\r\\n\\t\\tfor (int d = LOGN - 1; d >= 0; d--) \\r\\n\\t\\t\\tif (par[a][d] != par[b][d]) {\\r\\n\\t\\t\\t\\tans = max(ans, val[a][d]);\\r\\n\\t\\t\\t\\ta = par[a][d];\\r\\n\\t\\t\\t\\tans = max(ans, val[b][d]);\\r\\n\\t\\t\\t\\tb = par[b][d];\\r\\n\\t\\t\\t}\\r\\n\\t\\tif (par[a][0] != par[b][0])\\r\\n\\t\\t\\treturn -1;\\r\\n\\t\\tans = max(ans, val[a][0]);\\r\\n\\t\\tans = max(ans, val[b][0]);\\r\\n \\r\\n\\t\\treturn ans;\\r\\n\\t}\\r\\n}\\r\\n \\r\\n \\r\\nint main() {\\r\\n\\tdsu.init();\\r\\n \\r\\n\\tcin >> N >> M >> Q;\\r\\n\\tfor (int i = 1; i <= M; i++) {\\r\\n\\t\\tint u, v;\\r\\n\\t\\tcin >> u >> v;\\r\\n\\t\\tif (dsu.merge(u, v)) {\\r\\n\\t\\t\\tG[u].emplace_back(v, i);\\r\\n\\t\\t\\tG[v].emplace_back(u, i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n \\r\\n\\tLCA::init();\\r\\n \\r\\n\\twhile (Q--) {\\r\\n\\t\\tint u, v;\\r\\n\\t\\tcin >> u >> v;\\r\\n\\t\\tcout << LCA::query(u, v) << '\\\\n';\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-2101","source":"CSES","title":"New Roads Queries","author":"Dustin Miao"},"parent":{"name":"cses-2101","relativePath":"cses-2101.mdx"},"toc":{"cpp":[{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"dsu","title":"Disjoint Set Union"}}}}]},"problemInfo":{"uniqueId":"cses-2101","url":"https://cses.fi/problemset/task/2101/"}},"pageContext":{"id":"cses-2101"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}