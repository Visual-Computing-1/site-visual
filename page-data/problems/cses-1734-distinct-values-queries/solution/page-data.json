{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1734-distinct-values-queries/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1734\", source = \"CSES\", title = \"Distinct Values Queries\", author = \"Benjamin Qi, Andrew Wang, Óscar Garries\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    Spoiler: _missingComponent(\"Spoiler\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\")\n  }, _props.components), {Spoiler, MATHSPAN, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(Spoiler, {\n      title: \"Hint\",\n      children: _jsx(_components.p, {\n        children: \"Sort the queries in a specific order before answering them.\"\n      })\n    }), \"\\n\", _jsxs(Spoiler, {\n      title: \"Solution\",\n      children: [_jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Time Complexity:\"\n        }), \" \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"\\\\mathcal{O}(N\\\\log{N})\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N\\\\log{N})</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n        })]\n      }), _jsx(_components.p, {\n        children: \"Answer queries in order of the right indices. Use a BIT to keep track of indices\\r\\nthat contain distinct values. For every value, update the latest index for it\\r\\nand answer all queries at the current index. This ensures later indices are\\r\\nincluded in the BIT to accurately answer queries.\"\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-cpp\",\n          children: \"#include <bits/stdc++.h>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\nconst int MX = 4e5 + 5;\\r\\n\\r\\nint bit[MX];\\r\\nint n, q, sol[MX];\\r\\nvector<pair<int, int>> query[MX];\\r\\nvector<int> x(MX);\\r\\nmap<int, int> fst;\\r\\n\\r\\nint qry (int i) {\\r\\n\\tint res = 0;\\r\\n\\tfor (; i; i -= i&(-i)) {\\r\\n\\t\\tres += bit[i];\\r\\n\\t}\\r\\n\\treturn res;\\r\\n}\\r\\n\\r\\nvoid upd (int i, int val) {\\r\\n\\tfor (; i <= n; i += i&(-i)) {\\r\\n\\t\\tbit[i] += val;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main () {\\r\\n\\tcin >> n >> q;\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tcin >> x[i];\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < q; i++) {\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\tquery[a].push_back(make_pair(b, i));\\r\\n\\t}\\r\\n\\tfor (int i = n; i >= 1; i--) {\\r\\n\\t\\tint z = x[i - 1];\\r\\n\\t\\tif (fst.count(z)) upd(fst[z], -1);\\r\\n\\t\\tfst[z] = i;\\r\\n\\t\\tupd(i, 1);\\r\\n\\t\\tfor (auto t : query[i]) {\\r\\n\\t\\t\\tsol[t.second] = qry(t.first);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < q; i++) {\\r\\n\\t\\tcout << sol[i] << '\\\\n';\\r\\n\\t}\\r\\n}\\n\"\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1734","source":"CSES","title":"Distinct Values Queries","author":"Benjamin Qi, Andrew Wang, Óscar Garries"},"parent":{"name":"cses-1734","relativePath":"cses-1734.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"PURS","title":"Point Update Range Sum"}}}}]},"problemInfo":{"uniqueId":"cses-1734","url":"https://cses.fi/problemset/task/1734"}},"pageContext":{"id":"cses-1734"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}