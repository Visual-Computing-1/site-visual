{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-cellular-network/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cf-702C\", source = \"CF\", title = \"Cellular Network\", author = \"Nathan Wang, Benjamin Qi, Maggie Liu, Brad Ma\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\")\n  }, _props.components), {HeaderLink, LanguageSection, CPPSection, JavaSection, MATHSPAN, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://codeforces.com/blog/entry/46324?locale=en\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Editorial\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-1---binary-search-on-a-sorted-array\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-1---binary-search-on-a-sorted-array\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 1 - Binary Search on a Sorted Array\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\n// returns the first index in the array that is >= value, or arr.size() if no such index exists\\r\\nint firstAtLeast(const vector<int>& arr, int value) {\\r\\n\\tint lo = 0, hi = arr.size();\\r\\n\\twhile (lo < hi) {\\r\\n\\t\\tint mid = (lo+hi)/2;\\r\\n\\t\\tif (arr[mid] >= value) hi = mid;\\r\\n\\t\\telse lo = mid+1;\\r\\n\\t}\\r\\n\\treturn lo;\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tint n, m; cin >> n >> m;\\r\\n\\tvector<int> cities, towers;\\r\\n\\t\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tint city; cin >> city; cities.push_back(city);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\tint tower; cin >> tower; towers.push_back(tower);\\r\\n\\t}\\r\\n\\r\\n\\tint minR = 0;\\r\\n\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\tint towerRight = firstAtLeast(towers, cities[i]);\\r\\n\\t\\tint towerLeft = towerRight - 1;\\r\\n\\r\\n\\t\\tint minRForThisCity = 2e9;\\r\\n\\t\\tif (towerRight < m) {\\r\\n\\t\\t\\tassert(towers[towerRight] >= cities[i]);\\r\\n\\t\\t\\tminRForThisCity = min(minRForThisCity, towers[towerRight] - cities[i]);\\r\\n\\t\\t}\\r\\n\\t\\tif (towerLeft >= 0) {\\r\\n\\t\\t\\tassert(towers[towerLeft] <= cities[i]);\\r\\n\\t\\t\\tminRForThisCity = min(minRForThisCity, cities[i] - towers[towerLeft]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tminR = max(minR, minRForThisCity);\\r\\n\\t}\\r\\n\\r\\n\\tcout << minR << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class CellularNetwork {\\r\\n\\tstatic final int TWO_BILLION = 2000000000;\\r\\n\\r\\n\\t// returns the first index in the array that is >= value,\\r\\n\\t// or towers.length if no such index exists\\r\\n\\tstatic int firstAtLeast(int[] towers, int value) {\\r\\n\\t\\tint low = 0, high = towers.length;\\r\\n\\t\\twhile (low < high) {\\r\\n\\t\\t\\tint mid = (low + high) / 2;\\r\\n\\t\\t\\tif (towers[mid] >= value) {\\r\\n\\t\\t\\t\\thigh = mid;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse {\\r\\n\\t\\t\\t\\tlow = mid + 1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn low;\\r\\n\\t}\\r\\n\\r\\n\\tpublic static void main (String[] args) {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\t\\tint n = io.nextInt();\\r\\n\\t\\tint m = io.nextInt();\\r\\n\\r\\n\\t\\tint[] cities = new int[n];\\r\\n\\t\\tint[] towers = new int[m];\\r\\n\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tcities[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\t\\ttowers[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint minR = 0;\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tint towerRight = firstAtLeast(towers, cities[i]);\\r\\n\\t\\t\\tint towerLeft = towerRight - 1;\\r\\n\\r\\n\\t\\t\\tint minRForThisCity = TWO_BILLION;\\r\\n\\t\\t\\t// make sure that an index actually exists,\\r\\n\\t\\t\\t// if not, it will return the length of the\\r\\n\\t\\t\\t// array which is equal to m\\r\\n\\t\\t\\tif (towerRight < m) {\\r\\n\\t\\t\\t\\tminRForThisCity = Math.min(minRForThisCity, towers[towerRight] - cities[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (towerLeft >= 0) {\\r\\n\\t\\t\\t\\tminRForThisCity = Math.min(minRForThisCity, cities[i] - towers[towerLeft]);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tminR = Math.max(minR, minRForThisCity);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tio.println(minR);\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-2---two-pointers\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-2---two-pointers\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 2 - Two Pointers\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\ntypedef long long ll;\\r\\ntypedef pair <int, int> pii;\\r\\ntypedef vector<int> vi;\\r\\n\\r\\n#define mp make_pair\\r\\n#define pb push_back\\r\\n\\r\\n#define FOR(i, a, b) for (int i=a; i<b; i++)\\r\\n#define F0R(i, a) for (int i=0; i<a; i++)\\r\\n\\r\\n#define f first\\r\\n#define s second\\r\\n#define lb lower_bound\\r\\n#define ub upper_bound\\r\\n\\r\\nconst int MOD = 1000000007;\\r\\ndouble PI = 4*atan(1);\\r\\n\\r\\nint dist[100000], ans = 0;\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0);cin.tie(0);\\r\\n\\tF0R(i,100000) dist[i] = 2*MOD;\\r\\n\\tint n,m; cin >> n >> m;\\r\\n\\tvi a(n), b(m);\\r\\n\\tF0R(i,n) cin >> a[i];\\r\\n\\tF0R(i,m) cin >> b[i];\\r\\n\\tint c1 = 0;\\r\\n\\tF0R(i,n) {\\r\\n\\t\\twhile (c1<(m-1) && b[c1+1]<=a[i]) c1++;\\r\\n\\t\\tdist[i] = min(dist[i], abs(a[i]-b[c1]));\\r\\n\\t}\\r\\n\\tc1 = m-1;\\r\\n\\tfor (int i = n-1; i >= 0; --i) {\\r\\n\\t\\twhile (c1>0 && b[c1-1]>=a[i]) c1--;\\r\\n\\t\\tdist[i] = min(dist[i],abs(a[i]-b[c1]));\\r\\n\\t}\\r\\n\\tF0R(i,n) ans = max(ans,dist[i]);\\r\\n\\tcout << ans;\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class CellularNetwork2 {\\r\\n\\tstatic final int MOD = 1000000007;\\r\\n\\tstatic final int MAXIMUM_SIZE = 100000;\\r\\n\\r\\n\\tpublic static void main (String[] args) {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\r\\n\\t\\tint n = io.nextInt();\\r\\n\\t\\tint m = io.nextInt();\\r\\n\\t\\tint[] dist = new int[MAXIMUM_SIZE];\\r\\n\\r\\n\\t\\tArrays.fill(dist, 2 * MOD);\\r\\n\\r\\n\\t\\tint[] a = new int[n];\\r\\n\\t\\tint[] b = new int[m];\\r\\n\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\ta[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\t\\tb[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint pointer1 = 0;\\r\\n\\r\\n\\t\\t// pointer going left to right\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\twhile (pointer1 < (m - 1) && b[pointer1 + 1] <= a[i]) {\\r\\n\\t\\t\\t\\t// keep on incrementing\\r\\n\\t\\t\\t\\tpointer1++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdist[i] = Math.min(dist[i], Math.abs(a[i] - b[pointer1]));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tpointer1 = m - 1;\\r\\n\\r\\n\\t\\t// pointer going right to left\\r\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\r\\n\\t\\t\\twhile (pointer1 > 0 && b[pointer1 - 1] >= a[i]) {\\r\\n\\t\\t\\t\\tpointer1--;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tdist[i] = Math.min(dist[i], Math.abs(a[i] - b[pointer1]));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint answer = 0;\\r\\n\\t\\t// the maximum in the array is the answer\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tanswer = Math.max(answer, dist[i]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tio.println(answer);\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n}\\t\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution-3---using-a-set\",\n      children: [_jsx(_components.a, {\n        href: \"#solution-3---using-a-set\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution 3 - Using a Set\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We use the set \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{towers}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">towers</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{towers}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.5536em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">towers</span></span></span></span></span>\"\n      }), \" to store the coordinates of the cellular\\r\\ntowers. For each city, we want to find the closest tower and calculate the\\r\\ndistance. The minimal \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"r\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\\\"application/x-tex\\\">r</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">r</span></span></span></span>\"\n      }), \" will be the maximum of all these distances. To find\\r\\nthe closest tower to a certain city, we check the towers to the left and right\\r\\nand determine which one is closer.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For each city, we use\\r\\n\", _jsx(_components.a, {\n        href: \"http://www.cplusplus.com/reference/algorithm/lower_bound/\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: _jsx(_components.code, {\n          children: \"lower_bound\"\n        })\n      }), \" to\\r\\nfind the closest tower to the right of the city. If this tower is found,\\r\\ncalculate the distance between this tower and the city. If the tower is not at\\r\\nthe beginning of the set, the previous tower in the set will be the tower to the\\r\\nleft of the city. Define \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{dist}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">dist</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{dist}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6111em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">dist</span></span></span></span></span>\"\n      }), \" to be the minimum of the distance to\\r\\nthe tower on the right and the distance to the tower on the left. Then, set \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"r\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>r</mi></mrow><annotation encoding=\\\"application/x-tex\\\">r</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.02778em;\\\">r</span></span></span></span>\"\n      }), \"\\r\\nto be the maximum of itself and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\texttt{dist}\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mtext mathvariant=\\\"monospace\\\">dist</mtext></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\texttt{dist}</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6111em;\\\"></span><span class=\\\"mord text\\\"><span class=\\\"mord texttt\\\">dist</span></span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <set>\\r\\n#include <algorithm>\\r\\nusing namespace std;\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tint n, m;\\r\\n\\tcin >> n >> m;\\r\\n\\tint cities[n];\\r\\n\\tset<int> towers;\\r\\n\\tint tower;\\r\\n\\tfor (int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tcin >> cities[i];\\r\\n\\t}\\r\\n\\tfor (int i = 0; i < m; i++)\\r\\n\\t{\\r\\n\\t\\tcin >> tower;\\r\\n\\t\\ttowers.insert(tower);\\r\\n\\t}\\r\\n\\tint r = 0;\\r\\n\\tfor (int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tint dist = 2e9 + 1;\\r\\n\\t\\t//find closest tower to the right of the city\\r\\n\\t\\tauto closesttower = towers.lower_bound(cities[i]);\\r\\n\\t\\tif (closesttower != towers.end())\\r\\n\\t\\t{\\r\\n\\t\\t\\t//if a tower is found, update the distance\\r\\n\\t\\t\\tdist = *closesttower - cities[i];\\r\\n\\t\\t}\\r\\n\\t\\t//find closest tower to the left of the city\\r\\n\\t\\tif (closesttower != towers.begin())\\r\\n\\t\\t{\\r\\n\\t\\t\\tclosesttower--;\\r\\n\\t\\t\\t//update dist with the minimum of the distances\\r\\n\\t\\t\\tdist = min(dist, cities[i] - *closesttower);\\r\\n\\t\\t}\\r\\n\\t\\tr = max(r, dist);\\r\\n\\t}\\r\\n\\tcout << r << endl;\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class CellularNetwork {\\r\\n\\t//BeginCodeSnip{Kattio}\\n\\tstatic class Kattio extends PrintWriter {\\n\\t\\tprivate BufferedReader r;\\n\\t\\tprivate StringTokenizer st;\\n\\t\\t// standard input\\n\\t\\tpublic Kattio() { this(System.in, System.out); }\\n\\t\\tpublic Kattio(InputStream i, OutputStream o) {\\n\\t\\t\\tsuper(o);\\n\\t\\t\\tr = new BufferedReader(new InputStreamReader(i));\\n\\t\\t}\\n\\t\\t// USACO-style file input\\n\\t\\tpublic Kattio(String problemName) throws IOException {\\n\\t\\t\\tsuper(problemName + \\\".out\\\");\\n\\t\\t\\tr = new BufferedReader(new FileReader(problemName + \\\".in\\\"));\\n\\t\\t}\\n\\t\\t// returns null if no more input\\n\\t\\tpublic String next() {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\twhile (st == null || !st.hasMoreTokens())\\n\\t\\t\\t\\t\\tst = new StringTokenizer(r.readLine());\\n\\t\\t\\t\\treturn st.nextToken();\\n\\t\\t\\t} catch (Exception e) { }\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tpublic int nextInt() { return Integer.parseInt(next()); }\\n\\t\\tpublic double nextDouble() { return Double.parseDouble(next()); }\\n\\t\\tpublic long nextLong() { return Long.parseLong(next()); }\\n\\t}\\n\\t//EndCodeSnip\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\tKattio io = new Kattio();\\r\\n\\r\\n\\t\\tint n = io.nextInt();\\r\\n\\t\\tint m = io.nextInt();\\r\\n\\t\\tint[] cities = new int[n];\\r\\n\\t\\tTreeSet<Integer> towers = new TreeSet<>();\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tcities[i] = io.nextInt();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\t\\tint tower = io.nextInt();\\r\\n\\t\\t\\ttowers.add(tower);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint r = 0;\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tint distance = Integer.MAX_VALUE;\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t * .lower() and .higher() methods return a value of type\\r\\n\\t\\t\\t * Integer if the value exists and null if it doesn't\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tInteger closestTower = towers.lower(cities[i]);\\r\\n\\t\\t\\tInteger\\tfarthestTower = towers.higher(cities[i]);\\r\\n\\t\\t\\tif (closestTower != null) {\\r\\n\\t\\t\\t\\tdistance = cities[i] - closestTower;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (farthestTower != null) {\\r\\n\\t\\t\\t\\tdistance = Math.min(distance, farthestTower - cities[i]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tr = Math.max(r,distance);\\r\\n\\t\\t}\\r\\n\\t\\tio.println(r);\\r\\n\\t\\tio.close();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cf-702C","source":"CF","title":"Cellular Network","author":"Nathan Wang, Benjamin Qi, Maggie Liu, Brad Ma"},"parent":{"name":"cf-702C","relativePath":"cf-702C.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution 1 - Binary Search on a Sorted Array","slug":"solution-1---binary-search-on-a-sorted-array"},{"depth":2,"value":"Solution 2 - Two Pointers","slug":"solution-2---two-pointers"},{"depth":2,"value":"Solution 3 - Using a Set","slug":"solution-3---using-a-set"}],"java":[{"depth":2,"value":"Solution 1 - Binary Search on a Sorted Array","slug":"solution-1---binary-search-on-a-sorted-array"},{"depth":2,"value":"Solution 2 - Two Pointers","slug":"solution-2---two-pointers"},{"depth":2,"value":"Solution 3 - Using a Set","slug":"solution-3---using-a-set"}],"py":[{"depth":2,"value":"Solution 1 - Binary Search on a Sorted Array","slug":"solution-1---binary-search-on-a-sorted-array"},{"depth":2,"value":"Solution 2 - Two Pointers","slug":"solution-2---two-pointers"},{"depth":2,"value":"Solution 3 - Using a Set","slug":"solution-3---using-a-set"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"binary-search","title":"Binary Search"}}}},{"node":{"module":{"frontmatter":{"id":"intro-sorted-sets","title":"More Operations on Sorted Sets"}}}},{"node":{"module":{"frontmatter":{"id":"two-pointers","title":"Two Pointers"}}}}]},"problemInfo":{"uniqueId":"cf-702C","url":"https://codeforces.com/contest/702/problem/C"}},"pageContext":{"id":"cf-702C"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}