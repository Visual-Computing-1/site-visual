{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1194-monsters/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1194\", source = \"CSES\", title = \"Monsters\", author = \"Isaac Noel, Sofia Yang\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"abstract\",\n      children: [_jsx(_components.a, {\n        href: \"#abstract\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Abstract\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We want to find if A can reach the edge of the maze without being touched by\\r\\nmonsters by BFS. If possible, retrace and print its path.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution\",\n      children: [_jsx(_components.a, {\n        href: \"#solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Because the monsters move optimally, if a monster can reach a location in the\\r\\nmaze before A, then A may never move to that spot. Thus, for A to enter a spot,\\r\\nthe distance from that location to A must be less than the distance from that\\r\\nlocation to the nearest monster. Knowing this, we may BFS to find all locations\\r\\nthat are visitable by A. This will run in \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N^2\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">N^2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \" time because each location will\\r\\nbe visited a constant amount of times.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While conducting the bfs, store the previous location of every location (\\\"from\\\"\\r\\narray in code below). This way, once A reaches the edge, we can retrace A's\\r\\npath, following the path of previous locations and storing the direction\\r\\ntraveled.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <queue>\\r\\n#include <climits>\\r\\n#include <cstring>\\r\\n#include <algorithm>\\r\\n#define pii pair<int, int>\\r\\n#define mn 1005\\r\\nusing namespace std;\\r\\n\\r\\nint N, M;\\r\\nqueue<pii> q;\\r\\nint paths[mn][mn];\\r\\npii from[mn][mn];\\r\\nint oo = INT_MAX;\\r\\npii A;\\r\\nstring ans;\\r\\nbool possible = false;\\r\\n\\r\\nvoid retrace(pii node){  // retrace from final node, adding direction from previous node to a string. This string will be backwards but will be reversed before output.\\r\\n\\tpii origin = from[node.first][node.second];\\r\\n\\tif(origin ==  pii(0,0)) return;\\r\\n\\tif(origin.first == node.first+1) ans.push_back('U');\\r\\n\\tif(origin.first == node.first-1) ans.push_back('D');\\r\\n\\tif(origin.second == node.second+1) ans.push_back('L');\\r\\n\\tif(origin.second==node.second-1) ans.push_back('R');\\r\\n\\tretrace(origin);\\r\\n\\r\\n}\\r\\nvoid check(pii origin, pii dest){ // check if the considered destination may be traveled to\\r\\n\\tint pl = paths[origin.first][origin.second];\\r\\n\\tif(pl+1<paths[dest.first][dest.second]){\\r\\n\\t\\tpaths[dest.first][dest.second]  = pl+1;\\r\\n\\t\\tq.push(dest);\\r\\n\\t\\tfrom[dest.first][dest.second] = origin;\\r\\n\\t}\\r\\n}\\r\\nbool mora = false; // false if bfs for monsters, true if bfs for A\\r\\nvoid bfs(){\\r\\n\\twhile(!q.empty()){\\r\\n\\t\\tpii loc = q.front(), next; q.pop();\\r\\n\\t\\tnext = loc; next.first++; check(loc, next); // go through adjacent locations\\r\\n\\t\\tnext = loc; next.first--; check(loc, next);\\r\\n\\t\\tnext = loc; next.second++; check(loc, next);\\r\\n\\t\\tnext = loc; next.second--; check(loc, next);\\r\\n\\t\\tif(mora && (loc.first == 1 || loc.second == 1 || loc.first == N || loc.second == M)){\\r\\n\\t\\t\\tcout << \\\"YES\\\" << endl;\\r\\n\\t\\t\\tcout << paths[loc.first][loc.second] << endl;\\r\\n\\t\\t\\tretrace(loc);\\r\\n\\t\\t\\tpossible = true;\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\nint main() {\\r\\n\\tcin >> N >> M;\\r\\n\\tfor(int i = 1; i <= N; i++){\\r\\n\\t\\tstring s;\\r\\n\\t\\tcin >> s;\\r\\n\\t\\tfor(int j = 1; j <= M; j++){\\r\\n\\t\\t\\tpaths[i][j] = oo;\\r\\n\\t\\t\\tif(s[j-1] == '#') paths[i][j] = 0;\\r\\n\\t\\t\\tif(s[j-1] == 'M') {q.push(pii(i,j)); paths[i][j]  = 0;}\\r\\n\\t\\t\\tif(s[j-1] == 'A') {A.first = i; A.second = j;}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tbfs(); // monster bfs\\r\\n\\tmora = true; // change next bfs to A bfs\\r\\n\\tfrom[A.first][A.second] = pii(0,0); // give the retrace a terminating location\\r\\n\\tpaths[A.first][A.second] = 0; q.push(A); // get ready for next bfs\\r\\n\\tbfs(); // bfs with A\\r\\n\\tif(possible){\\r\\n\\t\\treverse(ans.begin(), ans.end());\\r\\n\\t\\tcout << ans << endl;\\r\\n\\t}\\r\\n\\telse cout << \\\"NO\\\" << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class monsters {\\r\\n\\tpublic static int[] dX = {1, -1, 0, 0};\\r\\n\\tpublic static int[] dY = {0, 0, 1, -1};\\r\\n\\tpublic static String dirs = \\\"DURL\\\";\\r\\n\\tpublic static int N, M;\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(br.readLine());\\r\\n\\t\\tN = Integer.parseInt(st.nextToken());\\r\\n\\t\\tM = Integer.parseInt(st.nextToken());\\r\\n\\t\\tchar[][] grid = new char[N][M];\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tgrid[i] = br.readLine().toCharArray();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tint[][] dist = new int[N][M]; //Distance grid for monsters.\\r\\n\\t\\tboolean[][] visited = new boolean[N][M]; //Visited grid for monsters.\\r\\n\\r\\n\\t\\tQueue<point> q = new LinkedList<>();\\r\\n\\t\\t//Process the grid.\\r\\n\\t\\tpoint start = new point(-1, -1);\\r\\n\\t\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\t\\tfor (int j = 0; j < M; j++) {\\r\\n\\t\\t\\t\\t//Add each monster to the queue.\\r\\n\\t\\t\\t\\tif (grid[i][j] == 'M') {\\r\\n\\t\\t\\t\\t\\tq.add(new point(i, j));\\r\\n\\t\\t\\t\\t\\tdist[i][j] = 0;\\r\\n\\t\\t\\t\\t\\tvisited[i][j] = true;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (grid[i][j] == 'A') {\\r\\n\\t\\t\\t\\t\\tstart = new point(i, j);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//Run a BFS for the monsters.\\r\\n\\t\\twhile (!q.isEmpty()) {\\r\\n\\t\\t\\tpoint cur = q.poll();\\r\\n\\t\\t\\tint x = cur.x;\\r\\n\\t\\t\\tint y = cur.y;\\r\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\t\\t//The next location.\\r\\n\\t\\t\\t\\tint x1 = x + dX[i];\\r\\n\\t\\t\\t\\tint y1 = y + dY[i];\\r\\n\\t\\t\\t\\tif (onGrid(x1, y1) && !visited[x1][y1] && grid[x1][y1] != '#') {\\r\\n\\t\\t\\t\\t\\t//Mark the location as visited.\\r\\n\\t\\t\\t\\t\\tvisited[x1][y1] = true;\\r\\n\\t\\t\\t\\t\\tdist[x1][y1] = dist[x][y] + 1;\\r\\n\\t\\t\\t\\t\\tq.add(new point(x1, y1));\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t//Initialize for human BFS.\\r\\n\\t\\tq = new LinkedList<>();\\r\\n\\t\\tq.add(new point(start.x, start.y));\\r\\n\\t\\tint[][] dist1 = new int[N][M]; //Distance grid for the human.\\r\\n\\t\\tdist1[start.x][start.y] = 0;\\r\\n\\r\\n\\t\\tboolean[][] visited1 = new boolean[N][M]; //Visited grid for the human.\\r\\n\\t\\tvisited1[start.x][start.y] = true;\\r\\n\\r\\n\\t\\t//step[i][j] is the step direction that we take to reach point (i, j).\\r\\n\\t\\tchar[][] step = new char[N][M];\\r\\n\\t\\t//prevLoc[i][j] is the previous point before reaching point (i, j).\\r\\n\\t\\tpoint[][] prevLoc = new point[N][M];\\r\\n\\t\\tprevLoc[start.x][start.y] = new point(-1, -1);\\r\\n\\r\\n\\t\\t//Run a BFS for the human.\\r\\n\\t\\twhile (!q.isEmpty()) {\\r\\n\\t\\t\\tpoint cur = q.poll();\\r\\n\\t\\t\\tint x = cur.x;\\r\\n\\t\\t\\tint y = cur.y;\\r\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\t\\t//The next location.\\r\\n\\t\\t\\t\\tint x1 = x + dX[i];\\r\\n\\t\\t\\t\\tint y1 = y + dY[i];\\r\\n\\t\\t\\t\\tchar d = dirs.charAt(i);\\r\\n\\r\\n\\t\\t\\t\\t//Reached a boundary square.\\r\\n\\t\\t\\t\\tif (!onGrid(x1, y1)) {\\r\\n\\t\\t\\t\\t\\tSystem.out.println(\\\"YES\\\");\\r\\n\\t\\t\\t\\t\\tSystem.out.println(dist1[x][y]);\\r\\n\\t\\t\\t\\t\\tStringBuilder ans = new StringBuilder();\\r\\n\\t\\t\\t\\t\\t//Go backwards to print all the steps.\\r\\n\\t\\t\\t\\t\\twhile (x != -1) {\\r\\n\\t\\t\\t\\t\\t\\tif (prevLoc[x][y].x != -1) {\\r\\n\\t\\t\\t\\t\\t\\t\\tans.append(step[x][y]);\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\tint tmp = x;\\r\\n\\t\\t\\t\\t\\t\\tx = prevLoc[x][y].x;\\r\\n\\t\\t\\t\\t\\t\\ty = prevLoc[tmp][y].y;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tSystem.out.println(ans.reverse());\\r\\n\\t\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tif (!visited1[x1][y1] && grid[x1][y1] != '#') {\\r\\n\\t\\t\\t\\t\\tif (visited[x1][y1] && dist[x1][y1] <= dist1[x][y] + 1) {\\r\\n\\t\\t\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t//Mark the location as visited.\\r\\n\\t\\t\\t\\t\\tvisited1[x1][y1] = true;\\r\\n\\t\\t\\t\\t\\tdist1[x1][y1] = dist1[x][y] + 1;\\r\\n\\t\\t\\t\\t\\tq.add(new point(x1, y1));\\r\\n\\t\\t\\t\\t\\tprevLoc[x1][y1] = new point(x, y);\\r\\n\\t\\t\\t\\t\\tstep[x1][y1] = d;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tSystem.out.println(\\\"NO\\\");\\r\\n\\t}\\r\\n\\r\\n\\t//Whether or not the point is on the grid.\\r\\n\\tpublic static boolean onGrid(int x, int y) {\\r\\n\\t\\treturn (x >= 0 && x < N && y >= 0 && y < M);\\r\\n\\t}\\r\\n\\r\\n\\tpublic static class point {\\r\\n\\t\\tpublic int x, y;\\r\\n\\r\\n\\t\\tpublic point(int x, int y) {\\r\\n\\t\\t\\tthis.x = x;\\r\\n\\t\\t\\tthis.y = y;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1194","source":"CSES","title":"Monsters","author":"Isaac Noel, Sofia Yang"},"parent":{"name":"cses-1194","relativePath":"cses-1194.mdx"},"toc":{"cpp":[{"depth":2,"value":"Abstract","slug":"abstract"},{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Abstract","slug":"abstract"},{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Abstract","slug":"abstract"},{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"bfs","title":"Breadth First Search (BFS)"}}}}]},"problemInfo":{"uniqueId":"cses-1194","url":"https://cses.fi/problemset/task/1194"}},"pageContext":{"id":"cses-1194"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}