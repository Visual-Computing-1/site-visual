{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/ioi-2019transfer/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"ioi-19-transfer\", source = \"IOI 2019\", title = \"Data Transfer\", author = \"Andi Qu\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    Spoiler: _missingComponent(\"Spoiler\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\")\n  }, _props.components), {Spoiler, MATHSPAN, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Let's just focus on subtask 2, since subtask 1's solution is essentially the\\r\\nsame.\"\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"Hint 1\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"9 = \\\\log_2{256} + 1\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>9</mn><mo>=</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mn>256</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">9 = \\\\log_2{256} + 1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">9</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">=</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.9386em;vertical-align:-0.2441em;\\\"></span><span class=\\\"mop\\\"><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t vlist-t2\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.207em;\\\"><span style=\\\"top:-2.4559em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span><span class=\\\"vlist-s\\\">​</span></span><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.2441em;\\\"><span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord\\\">256</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n        }), \". This means we can append 8 bits (to store an integer less\\r\\nthan 256) and an extra bit.\"]\n      })\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"Hint 2\",\n      children: _jsx(_components.p, {\n        children: \"XOR is your friend in problems involving bitwise operations.\"\n      })\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"Hint 3\",\n      children: _jsx(_components.p, {\n        children: \"The extra bit can't store any meaningful information about the original 255\\r\\nbits. Can it store something meaningful about the first 8 bits that we append?\"\n      })\n    }), \"\\n\", _jsxs(Spoiler, {\n      title: \"Solution\",\n      children: [_jsxs(_components.p, {\n        children: [\"Let \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"x\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n        }), \" initially be 0. Iterate through the original 255 bits and if the \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"i\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n        }), \"-th\\r\\nbit is 1, then XOR \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"x\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n        }), \" with \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"i\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\\\"application/x-tex\\\">i</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"></span><span class=\\\"mord mathnormal\\\">i</span></span></span></span>\"\n        }), \". We can then append the 8 bits of \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"x\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n        }), \" to the\\r\\ndata.\"]\n      }), _jsxs(_components.p, {\n        children: [\"This is convenient because we can use \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"x\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n        }), \" to determine whether any of the first\\r\\n263 bits of data that we send have been corrupted, since at most one bit is\\r\\ncorrupted.\"]\n      }), _jsxs(_components.p, {\n        children: [\"If any of those bits are corrupted though, how do we tell whether it's the first\\r\\n255 bits or \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"x\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n        }), \" that has been corrupted?\"]\n      }), _jsxs(_components.p, {\n        children: [\"Consider the number of 1s in \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"x\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n        }), \"'s bitwise representation. If this number is\\r\\nodd, we append 1 to the data as the extra bit, and 0 otherwise. We can then\\r\\ncompare this extra bit to \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"x\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\\\"application/x-tex\\\">x</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span></span></span></span>\"\n        }), \" if we know that there is a corruption.\"]\n      }), _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-cpp\",\n          children: \"#include \\\"transfer.h\\\"\\r\\n\\r\\nstd::vector<int> get_attachment(std::vector<int> source) {\\r\\n\\tstd::vector<int> v;\\r\\n\\tint x = 0;\\r\\n\\tfor (int i = 0; i < source.size(); i++)\\r\\n\\t\\tif (source[i]) x ^= (i + 1);\\r\\n\\r\\n\\tint last = 0;\\r\\n\\tif (source.size() < 64) {\\r\\n\\t\\tfor (int i = 0; i < 6; i++) {\\r\\n\\t\\t\\tv.push_back(x & 1);\\r\\n\\t\\t\\tif (x & 1) last = 1 - last;\\r\\n\\t\\t\\tx >>= 1;\\r\\n\\t\\t}\\r\\n\\t} else {\\r\\n\\t\\tfor (int i = 0; i < 8; i++) {\\r\\n\\t\\t\\tv.push_back(x & 1);\\r\\n\\t\\t\\tif (x & 1) last = 1 - last;\\r\\n\\t\\t\\tx >>= 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tv.push_back(last);\\r\\n\\treturn v;\\r\\n}\\r\\n\\r\\nstd::vector<int> retrieve(std::vector<int> data) {\\r\\n\\tint last = data.back();\\r\\n\\tdata.pop_back();\\r\\n\\tint actual_last = 0, x = 0;\\r\\n\\tif (data.size() < 71) {\\r\\n\\t\\tfor (int i = 0; i < 6; i++) {\\r\\n\\t\\t\\tx <<= 1;\\r\\n\\t\\t\\tx += data.back();\\r\\n\\t\\t\\tif (data.back()) actual_last = 1 - actual_last;\\r\\n\\t\\t\\tdata.pop_back();\\r\\n\\t\\t}\\r\\n\\t} else {\\r\\n\\t\\tfor (int i = 0; i < 8; i++) {\\r\\n\\t\\t\\tx <<= 1;\\r\\n\\t\\t\\tx += data.back();\\r\\n\\t\\t\\tif (data.back()) actual_last = 1 - actual_last;\\r\\n\\t\\t\\tdata.pop_back();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (actual_last != last) return std::vector<int>(data.begin(), data.end());\\r\\n\\r\\n\\tint actual_x = 0;\\r\\n\\tfor (int i = 0; i < data.size(); i++) {\\r\\n\\t\\tif (data[i]) actual_x ^= (i + 1);\\r\\n\\t}\\r\\n\\r\\n\\tint error = actual_x ^ x;\\r\\n\\tif (error == 0) return data;\\r\\n\\r\\n\\tdata[error - 1] = 1 - data[error - 1];\\r\\n\\treturn data;\\r\\n}\\n\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We're essentially just creating a\\r\\n\", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Hamming_code\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Hamming code\"\n      }), \".\"]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"ioi-19-transfer","source":"IOI 2019","title":"Data Transfer","author":"Andi Qu"},"parent":{"name":"ioi-19-transfer","relativePath":"ioi-19-transfer.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"interactive","title":"Interactive and Communication Problems"}}}}]},"problemInfo":{"uniqueId":"ioi-19-transfer","url":"https://oj.uz/problem/view/IOI19_transfer"}},"pageContext":{"id":"ioi-19-transfer"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}