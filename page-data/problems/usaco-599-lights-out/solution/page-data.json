{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-599-lights-out/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-599\", source = \"USACO Gold 2016 January\", title = \"Lights Out\", author = \"Albert Ye\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\")\n  }, _props.components), {MATHSPAN, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"Official solution:\\r\\n\", _jsx(_components.a, {\n        href: \"http://usaco.org/current/data/sol_lightsout_platinum_jan16.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"http://usaco.org/current/data/sol_lightsout_platinum_jan16.html\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The official solution just doesn't use hashing.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We want to be able to pinpoint Bessie's location after traversing some edges and\\r\\nvertices, and then add the shortest distance to the exit from this location for\\r\\neach starting index. Then, we want to compare this total distance to the\\r\\nshortest distance to the end just from the starting vertex to find the answer.\\r\\nFinding the minimum distance to the end from each vertex can be done in\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" time, as illustrated in the code. The question that remains\\r\\nis how to pinpoint Bessie's location after traversing some edges and vertices\\r\\nfrom each starting point.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As the official solution states, it is better to visualize the map as a string\\r\\nconsisting of angles and edges rather than a polynomial. We can pinpoint\\r\\nBessie's location if the current path is not repeated somewhere else in the map.\\r\\nIf we were to frame this as a string-matching problem, we would want to find the\\r\\nshortest substring of the map such that it only appears once.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We use hashing to find the shortest substring of the map. Distinguishing\\r\\nvertices from angles, we brute force through lengths in increasing order and use\\r\\na one-base polynomial hash to check if the substring appears only once. If we\\r\\nfind an appropriate substring, we find the total distance that we travelled\\r\\nbefore finding out where we were.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^3)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^3)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">3</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\ntypedef pair<int, int> pii;\\r\\n#define f first\\r\\n#define s second\\r\\nusing ll = long long;\\r\\n\\r\\nconst ll X = 97;\\r\\nconst ll M = 999999929;\\r\\n\\r\\nint n, m, H[505], p[505];\\r\\nvector<int> k;\\r\\npii arr[205];\\r\\n\\r\\nvoid gen_hash()\\r\\n{\\r\\n\\tp[0] = 1;\\r\\n\\tfor(int i = 1; i < m; i++)\\r\\n\\t{\\r\\n\\t\\tp[i] = int(p[i-1]*X%M);\\r\\n\\t}\\r\\n\\tH[0] = k[0];\\r\\n\\tfor(int i = 1; i < m; i++)\\r\\n\\t{\\r\\n\\t\\tH[i] = int((H[i-1]*X+k[i]) % M);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint cwdist[205][205], dist[205];\\r\\nvoid gen_dist()\\r\\n{\\r\\n\\tfor(int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tfor(int j = i; j < n; j++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tcwdist[i][(j+1)%n] = cwdist[i][j] + abs((arr[j].f - arr[(j+1)%n].f) + (arr[j].s - arr[(j+1)%n].s));\\r\\n\\t\\t\\tif(j+1 != n) cwdist[(j+1)%n][i] = INT_MAX;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tfor(int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tdist[i] = min(cwdist[0][i], cwdist[i][0]);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tfreopen(\\\"lightsout.in\\\", \\\"r\\\", stdin);\\r\\n\\tfreopen(\\\"lightsout.out\\\", \\\"w\\\", stdout);\\r\\n\\tcin >> n;\\r\\n\\tfor(int i = 0; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tcin >> arr[i].f >> arr[i].s;\\r\\n\\t}\\r\\n\\tk.push_back(0);\\r\\n\\tfor(int i = 1; i < n; i++)\\r\\n\\t{\\r\\n\\t\\tint pre = i-1;\\r\\n\\t\\tk.push_back(abs(arr[pre].f-arr[i].f)+abs(arr[pre].s-arr[i].s));\\r\\n\\t\\tint nxt = (i+1)%n;\\r\\n\\t\\tif(arr[i].f - arr[pre].f > 0)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif(arr[nxt].s - arr[i].s > 0) k.push_back(1100001);\\r\\n\\t\\t\\telse k.push_back(1100002);\\r\\n\\t\\t} else if(arr[i].f - arr[pre].f < 0)\\r\\n\\t\\t{\\r\\n\\t\\t\\tif(arr[nxt].s - arr[i].s > 0) k.push_back(1100002);\\r\\n\\t\\t\\telse k.push_back(1100001);\\r\\n\\t\\t} else\\r\\n\\t\\t{\\r\\n\\t\\t\\tif(arr[i].s - arr[pre].s > 0)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif(arr[nxt].f - arr[i].f > 0) k.push_back(1100002);\\r\\n\\t\\t\\t\\telse k.push_back(1100001);\\r\\n\\t\\t\\t} else if(arr[i].s - arr[pre].s < 0)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif(arr[nxt].f - arr[i].f > 0) k.push_back(1100001);\\r\\n\\t\\t\\t\\telse k.push_back(1100002);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tk.push_back(abs(arr[0].f-arr[n-1].f)+abs(arr[0].s-arr[n-1].s));\\r\\n\\tm = k.size()+1;\\r\\n\\t// for(int i = 0; i < m; i++) cerr << k[i] << \\\" \\\";\\r\\n\\tcerr << endl;\\r\\n\\tgen_dist();\\r\\n\\tgen_hash();\\r\\n\\tdist[0] = 0;\\r\\n\\tint ans = 0;\\r\\n\\tfor(int sp = 0; sp < m-1; sp++)\\r\\n\\t{\\r\\n\\t\\tint know = -1;\\r\\n\\t\\tfor(int L = 1; L < m-sp; L++)\\r\\n\\t\\t{\\r\\n\\t\\t\\tint x = (H[sp+L] - ((ll)H[sp]*p[L])%M + M)%M;\\r\\n\\t\\t\\tint nocc = 0;\\r\\n\\t\\t\\tfor(int pt = 0; pt < m-L; pt++)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif((H[pt+L] - ((ll)H[pt]*p[L])%M + M)%M == x)\\r\\n\\t\\t\\t\\t\\tnocc++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif(nocc == 1)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tknow = (sp+L+1)/2;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tint a = cwdist[(sp+2)/2][0];\\r\\n\\t\\tif(know != -1)\\r\\n\\t\\t{\\r\\n\\t\\t\\ta = dist[know] + cwdist[(sp+2)/2][know];\\r\\n\\t\\t}\\r\\n\\t\\tint b = dist[(sp+2)/2];\\r\\n\\t\\t// cerr << a << \\\" \\\" << b << endl;\\r\\n\\t\\tans = max(ans, a-b);\\r\\n\\t}\\r\\n\\tcout << ans << endl;\\r\\n}\\n\"\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-599","source":"USACO Gold 2016 January","title":"Lights Out","author":"Albert Ye"},"parent":{"name":"usaco-599","relativePath":"usaco-599.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"string-hashing","title":"String Hashing"}}}}]},"problemInfo":{"uniqueId":"usaco-599","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=599"}},"pageContext":{"id":"usaco-599"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}