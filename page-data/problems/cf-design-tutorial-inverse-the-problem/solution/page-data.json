{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cf-design-tutorial-inverse-the-problem/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cf-472D\", source = \"Codeforces\", title = \"Design Tutorial Inverse the Problem\", author = \"Weiming Zhou\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {MATHSPAN, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"https://codeforces.com/blog/entry/14028\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2\\\\log N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mi>log</mi><mo>‚Å°</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2\\\\log N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" with Kruskal's MST or \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" with \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N^2\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">N^2</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \" Prims.\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"// https://codeforces.com/contest/472/submission/117118910\\r\\n\\r\\n#include <bits/stdc++.h> \\r\\nusing namespace std;\\r\\n\\r\\nusing ll = long long;\\r\\n\\r\\nusing vi = vector<int>;\\r\\n#define pb push_back\\r\\n#define all(x) begin(x), end(x)\\r\\n#define sz(x) (int)(x).size()\\r\\n\\r\\nusing pii = pair<int,int>; //note pii, not pi\\r\\n#define f first\\r\\n#define s second\\r\\n#define mp make_pair\\r\\n\\r\\nconst int MX = 2e3 + 10;\\r\\n \\r\\nint dist[MX][MX], n, par[MX], sz[MX];\\r\\nvector<pii> adj[MX];\\r\\nvector<pair<int, pii>> edges;\\r\\n \\r\\nint find(int x){\\r\\n\\tif(x != par[x]) par[x] = find(par[x]); \\r\\n\\treturn par[x];\\r\\n}\\r\\n \\r\\nvoid Union(int a, int b){\\r\\n\\ta = find(a), b = find(b);\\r\\n\\tif(a == b) return ;\\r\\n\\tif(sz[a] > sz[b]) swap(a, b);\\r\\n\\tpar[b] = a;\\r\\n\\tsz[a] += sz[b];\\r\\n}\\r\\n\\t\\r\\nvoid mkdsu(){\\r\\n\\tfor(int i = 0; i <= n; i++){\\r\\n\\t\\tpar[i] = i, sz[i] = 1;\\r\\n\\t}\\r\\n}\\r\\n \\r\\nbool cmp(const pair<int, pii> &a, const pair<int, pii>& b){\\r\\n\\treturn a.f < b.f;\\r\\n}\\r\\n \\r\\nvoid kruskals(){\\r\\n\\tint tot = 0;\\r\\n\\tmkdsu();\\r\\n\\tsort(all(edges), cmp); \\r\\n\\tfor(const auto& e : edges){\\r\\n\\t\\tif(tot == n) break;\\r\\n\\t\\tint u = e.s.f, v = e.s.s, w = e.f;\\r\\n\\t\\tif(find(u) != find(v)){\\r\\n\\t\\t\\tUnion(u, v);\\r\\n\\t\\t\\ttot = max(tot, sz[find(u)]);\\r\\n\\t\\t\\tadj[u].pb(mp(v, w)); \\r\\n\\t\\t\\tadj[v].pb(mp(u, w));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n \\r\\nbool dfs(int u, int p, int src, int d){\\r\\n\\tif(dist[src][u] != d || (src != u && dist[src][u] == 0)) return false; \\r\\n\\tbool ans = 1;\\r\\n\\tfor(const auto& e : adj[u]){\\r\\n\\t\\tif(e.f == p) continue;\\r\\n\\t\\tans &= dfs(e.f, u, src, d + e.s); \\r\\n\\t}\\r\\n\\treturn ans;\\r\\n}\\r\\n \\r\\nint main(){\\r\\n\\tcin.tie(0) -> sync_with_stdio(0);\\r\\n\\tbool ans = 1; \\r\\n\\tcin >> n;\\r\\n\\tfor(int i = 1; i <= n; i++){\\r\\n\\t\\tfor(int j = 1; j <= n; j++){\\r\\n\\t\\t\\tcin >> dist[i][j];\\r\\n\\t\\t\\tif(i != j){\\r\\n\\t\\t\\t\\tif(j < i && dist[i][j] != dist[j][i]) ans = 0; \\r\\n\\t\\t\\t\\tif(i < j) edges.pb(mp(dist[i][j], mp(i, j)));\\r\\n\\t\\t\\t}else{\\r\\n\\t\\t\\t\\tif(dist[i][j] != 0) ans = 0; \\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\tkruskals();\\r\\n\\t\\r\\n\\tfor(int i = 1; i <= n; i++){\\r\\n\\t\\tans &= dfs(i, 0, i, 0);\\r\\n\\t}\\r\\n\\t\\r\\n\\tif(ans) cout << \\\"YES\\\\n\\\";\\r\\n\\telse cout << \\\"NO\\\\n\\\";\\r\\n\\t\\r\\n\\treturn 0;\\r\\n}\\r\\n \\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cf-472D","source":"Codeforces","title":"Design Tutorial Inverse the Problem","author":"Weiming Zhou"},"parent":{"name":"cf-472D","relativePath":"cf-472D.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"mst","title":"Minimum Spanning Trees"}}}}]},"problemInfo":{"uniqueId":"cf-472D","url":"https://codeforces.com/contest/472/problem/D"}},"pageContext":{"id":"cf-472D"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}