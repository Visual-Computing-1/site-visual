{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-2179-even-outdegree-edges/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-2179\", source = \"CSES\", title = \"Even Outdegree Edges\", author = \"Andi Qu\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    ol: \"ol\",\n    li: \"li\",\n    a: \"a\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\")\n  }, _props.components), {MATHSPAN, HeaderLink, LanguageSection, CPPSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Without loss of generality, assume that the number of edges is even and there's\\r\\nonly one connected component in the graph.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Consider the following simpler problem: given a rooted tree, direct the edges so\\r\\nthat all nodes except for the root have an even out-degree; the root's degree\\r\\nmay be of any parity.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"We can solve this simpler problem recursively through a DFS. Imagine that we're\\r\\nprocessing some subtree rooted at node \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \". First, process each of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \"'s\\r\\nchildren's subtrees \", _jsxs(_components.strong, {\n        children: [\"but don't direct \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"v\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n        }), \"'s incident edges yet\"]\n      }), \". Although the\\r\\nchildren's out-degree parity may be arbitrary after this, we can then direct\\r\\neach of \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"v\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>v</mi></mrow><annotation encoding=\\\"application/x-tex\\\">v</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">v</span></span></span></span>\"\n      }), \"'s incident edges to make them all even. This solution works in\\r\\n\", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(N)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" time.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It turns out that this also solves the version of the problem where the root of\\r\\nthe tree must also have even out-degree! This is because the sum of out-degrees\\r\\nis equal to the number of edges - since the out-degrees of all nodes besides the\\r\\nroot are even, the out-degree of the root must also be even.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"To generalize this solution to an arbitrary graph, we simply:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Find the DFS tree (which will be a spanning tree).\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Direct all edges that aren't part of this tree \\\"upwards\\\".\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Run the solution for a tree on the DFS tree (except some nodes must have\\r\\n\", _jsx(_components.strong, {\n          children: \"odd\"\n        }), \" out-degree now).\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Step 2 works because of the fact that all edges that aren't part of the DFS tree\\r\\nare \", _jsx(_components.strong, {\n        children: \"back-edges\"\n      }), \" (i.e. edges where one node is a parent of the other). For\\r\\nmore information about the DFS tree, read\\r\\n\", _jsx(_components.a, {\n        href: \"https://codeforces.com/blog/entry/68138\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"this CF blog post\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsx(LanguageSection, {\n      children: _jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nvector<int> graph[100001];\\r\\nint visited[100001], odd[100001], timer = 1;\\r\\nvector<pair<int, int>> ans;\\r\\n\\r\\nvoid dfs(int node, int parent = 0) {\\r\\n\\tvisited[node] = timer++;\\r\\n\\tfor (int i : graph[node]) if (i != parent) {\\r\\n\\t\\tif (!visited[i]) {\\r\\n\\t\\t\\tdfs(i, node);\\r\\n\\t\\t\\tif (odd[i]) {\\r\\n\\t\\t\\t\\tans.push_back({i, node});\\r\\n\\t\\t\\t\\todd[i] = 0;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tans.push_back({node, i});\\r\\n\\t\\t\\t\\todd[node] ^= 1;\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else if (visited[node] > visited[i]) {\\r\\n\\t\\t\\tans.push_back({node, i});\\r\\n\\t\\t\\todd[node] ^= 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcin.tie(0)->sync_with_stdio(0);\\r\\n\\tint n, m;\\r\\n\\tscanf(\\\"%d %d\\\", &n, &m);\\r\\n\\twhile (m--) {\\r\\n\\t\\tint u, v;\\r\\n\\t\\tscanf(\\\"%d %d\\\", &u, &v);\\r\\n\\t\\tgraph[u].push_back(v);\\r\\n\\t\\tgraph[v].push_back(u);\\r\\n\\t}\\r\\n\\tfor (int i = 1; i <= n; i++) if (!visited[i]) dfs(i);\\r\\n\\tif (accumulate(odd + 1, odd + n + 1, 0)) printf(\\\"IMPOSSIBLE\\\");\\r\\n\\telse for (pair<int, int> i : ans) printf(\\\"%d %d\\\\n\\\", i.first, i.second);\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-2179","source":"CSES","title":"Even Outdegree Edges","author":"Andi Qu"},"parent":{"name":"cses-2179","relativePath":"cses-2179.mdx"},"toc":{"cpp":[{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"intro-tree","title":"Introduction to Tree Algorithms"}}}}]},"problemInfo":{"uniqueId":"cses-2179","url":"https://cses.fi/problemset/task/2179"}},"pageContext":{"id":"cses-2179"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}