{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/cses-1133-tree-distances-ii/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"cses-1133\", source = \"CSES\", title = \"Tree Distances II\", author = \"Andi Qu\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    MATHSPAN: _missingComponent(\"MATHSPAN\")\n  }, _props.components), {MATHSPAN, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal O(n)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>n</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal O(n)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It's easy to find the sum of distances from a single node - just root the tree\\r\\nat that node, do a DFS, and add the depths of each other node to the answer.\\r\\nUnfortunately, \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" can go up to \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"2 \\\\cdot 10^5\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>2</mn><mo>⋅</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">2 \\\\cdot 10^5</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">2</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">⋅</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">5</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \", so we can't just do this for\\r\\neach node.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If we have the answer for some node (let's say node 1), how can we quickly find\\r\\nthe answer for its neighbours?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The key observation is that if we reroot the tree at node 1's neighbour (let's\\r\\nsay node 2), then\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"The depths of all nodes in node 2's subtree \", _jsx(_components.strong, {\n          children: \"decrease by 1\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"The depths of all nodes outside of its subtree \", _jsx(_components.strong, {\n          children: \"increase by 1\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This gives us a nice way to transition from node 1's answer to node 2's answer\\r\\nusing only \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\\\"application/x-tex\\\">n</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.4306em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span></span></span></span>\"\n      }), \" and the size of node 2's subtree! Observe that the change in the\\r\\nanswer is exactly \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n - 2(\\\\text{node 2's subtree size})\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy=\\\"false\\\">(</mo><mtext>node 2’s subtree size</mtext><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">n - 2(\\\\text{node 2&#x27;s subtree size})</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord\\\">2</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord text\\\"><span class=\\\"mord\\\">node 2’s subtree size</span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"We can use DFS to find both the answer for node 1 and the size of each node's\\r\\nsubtree when rooted at node 1, and then DFS again to compute all the answers.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\ntypedef long long ll;\\r\\nusing namespace std;\\r\\n\\r\\nint n;\\r\\nvector<int> graph[200001];\\r\\nll dp[200001], ans[200001];\\r\\n\\r\\nvoid dfs1(int node = 1, int parent = 0, ll depth = 0) {\\r\\n\\tans[1] += depth;\\r\\n\\tdp[node] = 1;\\r\\n\\tfor (int i : graph[node]) if (i != parent) {\\r\\n\\t\\tdfs1(i, node, depth + 1);\\r\\n\\t\\tdp[node] += dp[i];\\r\\n\\t}\\r\\n}\\r\\n\\r\\nvoid dfs2(int node = 1, int parent = 0) {\\r\\n\\tfor (int i : graph[node]) if (i != parent) {\\r\\n\\t\\tans[i] = ans[node] + n - 2 * dp[i];\\r\\n\\t\\tdfs2(i, node);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tios_base::sync_with_stdio(0);\\r\\n\\tcin.tie(0);\\r\\n\\tcin >> n;\\r\\n\\tfor (int i = 1; i < n; i++) {\\r\\n\\t\\tint a, b;\\r\\n\\t\\tcin >> a >> b;\\r\\n\\t\\tgraph[a].push_back(b);\\r\\n\\t\\tgraph[b].push_back(a);\\r\\n\\t}\\r\\n\\tdfs1();\\r\\n\\tdfs2();\\r\\n\\tfor (int i = 1; i <= n; i++) cout << ans[i] << ' ';\\r\\n\\treturn 0;\\r\\n}\\n\"\n      })\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"cses-1133","source":"CSES","title":"Tree Distances II","author":"Andi Qu"},"parent":{"name":"cses-1133","relativePath":"cses-1133.mdx"},"toc":{"cpp":[],"java":[],"py":[]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"intro-tree","title":"Introduction to Tree Algorithms"}}}}]},"problemInfo":{"uniqueId":"cses-1133","url":"https://cses.fi/problemset/task/1133"}},"pageContext":{"id":"cses-1133"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}