{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-969-milk-pumping/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-969\", source = \"USACO Gold 2019 December\", title = \"Milk Pumping\", author = \"Qi Wang, Ryan Chou\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    JavaSection: _missingComponent(\"JavaSection\")\n  }, _props.components), {HeaderLink, LanguageSection, CPPSection, MATHSPAN, JavaSection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_pump_gold_dec19.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The larger the denominator, the smaller the result will be. We also want to minimize the cost of the path. This hints at a shortest-path problem. Due to the low number of junction points, we can fix the minimum flow rate and search for the lowest cost path we could take.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsxs(CPPSection, {\n        children: [_jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Time Complexity:\"\n          }), \" \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"\\\\mathcal{O}(M^2 \\\\log N + MN)\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>M</mi><mn>2</mn></msup><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>M</mi><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(M^2 \\\\log N + MN)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">MN</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n          })]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nstruct Edge {\\r\\n\\tint v, c, fl;\\r\\n};\\r\\n\\r\\nint n, m;\\r\\nconst int PRECISION = 1e6;\\r\\nvector<vector<Edge>> adj;\\r\\n\\r\\n\\r\\nint dijkstra(int minf) {\\r\\n\\tpriority_queue<pair<int, int>> pq;\\r\\n\\tvector<int> cost(n, INT32_MAX);\\r\\n\\tvector<bool> visited(n, false);\\r\\n\\t\\r\\n\\tcost[0] = 0;\\r\\n\\tpq.push({0, 0});\\r\\n\\t\\r\\n\\twhile (!pq.empty()) {\\r\\n\\t\\tpair<int, int> nxt = pq.top();\\r\\n\\t\\tpq.pop();\\r\\n\\r\\n\\t\\tif (nxt.second != cost[nxt.first] || visited[nxt.first]) {\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\tfor (Edge u : adj[nxt.first]) {\\r\\n\\t\\t\\tint ct = u.c + nxt.second;\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t * if the path has a flow value greater \\r\\n\\t\\t\\t * than our minimum, we can't consider it\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tif (u.fl < minf || visited[u.v]) {\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\t       \\r\\n\\t\\t\\t// path more optimal\\r\\n\\t\\t\\tif (cost[u.v] > ct) {\\r\\n\\t\\t\\t\\tcost[u.v] = ct;\\r\\n\\t\\t\\t\\tpq.push({u.v, ct});\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn cost[n - 1] == INT32_MAX ? -1 : cost[n - 1];\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tfreopen(\\\"pump.in\\\", \\\"r\\\", stdin);\\r\\n\\tfreopen(\\\"pump.out\\\", \\\"w\\\", stdout);\\r\\n\\r\\n\\tcin >> n >> m;\\r\\n\\r\\n\\tadj.resize(n);\\r\\n\\tvector<int> flows;\\r\\n\\tfor (int i = 0; i < m; i++) {\\r\\n\\t\\tint u, v, c, fl;\\r\\n\\t\\tcin >> u >> v >> c >> fl;\\r\\n\\r\\n\\t\\tflows.push_back(fl);\\r\\n\\t\\tadj[--u].push_back({--v, c, fl});\\r\\n\\t\\tadj[v].push_back({u, c, fl});\\r\\n\\t}\\r\\n\\r\\n\\tint ans = -1;\\r\\n\\t// we only have to consider the flow values given to us\\r\\n\\tfor (int flow : flows) {\\r\\n\\t\\tint cur = dijkstra(flow);\\r\\n\\r\\n\\t\\t// can't complete this path\\r\\n\\t\\tif (cur == -1) {\\r\\n\\t\\t\\tcontinue;\\r\\n\\t\\t}\\r\\n\\t\\tdouble ratio = double(flow) / double(cur);\\r\\n\\t\\tans = max(ans, (int) (ratio * PRECISION));\\r\\n\\t}\\r\\n\\tcout << ans << '\\\\n';\\r\\n}\\n\"\n          })\n        })]\n      }), _jsxs(JavaSection, {\n        children: [_jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Time Complexity:\"\n          }), \" \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"\\\\mathcal{O}(M \\\\log N + N)\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><mi>M</mi><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>N</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(M \\\\log N + N)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mop\\\">lo<span style=\\\"margin-right:0.01389em;\\\">g</span></span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">+</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n          })]\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"//Created by Qi Wang\\r\\nimport java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class pump{\\r\\n\\tstatic int N;\\r\\n\\tstatic int M;\\r\\n\\tstatic List<Node>[] adjList;\\r\\n\\tstatic boolean[] vist;\\r\\n\\tstatic int[] costs;\\r\\n\\tstatic int max = Integer.MIN_VALUE;\\r\\n\\t@SuppressWarnings(\\\"unchecked\\\")\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tInputReader in = new InputReader(\\\"pump.in\\\");\\r\\n\\t\\tN = in.nextInt();\\r\\n\\t\\tM = in.nextInt();\\r\\n\\r\\n\\t\\tadjList = new List[N];\\r\\n\\r\\n\\t\\tfor(int i = 0; i<N; i++){\\r\\n\\t\\t\\tadjList[i] = new ArrayList<>();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor(int i = 0; i<M; i++){\\r\\n\\t\\t\\tint from = in.nextInt()-1;\\r\\n\\t\\t\\tint to = in.nextInt()-1;\\r\\n\\t\\t\\tint cost = in.nextInt();\\r\\n\\t\\t\\tint flow = in.nextInt();\\r\\n\\r\\n\\t\\t\\tadjList[from].add(new Node(to, cost, flow));\\r\\n\\t\\t\\tadjList[to].add(new Node(from, cost, flow));\\r\\n\\t\\t}\\r\\n\\r\\n    //Since flow is 1000 at most, we can just iterate through every value. Or you can just test the flow values present in testcase.\\r\\n\\t\\tfor(int minF = 0; minF <= 1000; minF++){\\r\\n\\t\\t\\tcosts = new int[N]; Arrays.fill(costs, Integer.MAX_VALUE); vist = new boolean[N];\\r\\n      //Running dijkstra with the min flow that we set.\\r\\n\\t\\t\\tint[] res = dijkstra(minF);\\r\\n      //Failed getting to the destination\\r\\n\\t\\t\\tif(res[0] < 0) continue;\\r\\n\\t\\t\\tdouble frac = (double)res[1]/res[0];\\r\\n      //Maxing so we have the maximal answer.\\r\\n\\t\\t\\tmax = Math.max(max, (int)Math.floor(frac * 1e6));\\r\\n\\t\\t}\\r\\n\\t\\tPrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\\\"pump.out\\\")));\\r\\n\\t\\tout.println(max);\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\r\\n\\tpublic static int[] dijkstra(int minF){\\r\\n\\t\\tPriorityQueue<Node> pq = new PriorityQueue<>();\\r\\n\\t\\tint min = Integer.MAX_VALUE;\\r\\n\\t\\tpq.add(new Node(0, 0, 0));\\r\\n\\t\\tcosts[0] = 0;\\r\\n\\t\\twhile(!pq.isEmpty()){\\r\\n\\t\\t\\tNode cur = pq.poll();\\r\\n\\t\\t\\tint n = cur.No;\\r\\n\\r\\n\\t\\t\\tif(vist[n]) continue; vist[n] = true;\\r\\n\\r\\n\\t\\t\\tfor(int i = 0; i<adjList[n].size(); i++){\\r\\n\\t\\t\\t\\tint t = adjList[n].get(i).No;\\r\\n\\t\\t\\t\\tint c = adjList[n].get(i).c + cur.c;\\r\\n\\r\\n\\t\\t\\t\\tif(adjList[n].get(i).f < minF) continue;\\r\\n\\t\\t\\t\\tif(vist[t]) continue;\\r\\n\\r\\n\\t\\t\\t\\tif(costs[t] > c){\\r\\n\\t\\t\\t\\t\\tcosts[t] = c;\\r\\n\\t\\t\\t\\t\\tmin = Math.min(min, adjList[n].get(i).f);\\r\\n\\t\\t\\t\\t\\tpq.add(new Node(t, c, adjList[n].get(i).f));\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\t\\treturn new int[] {costs[N-1] == Integer.MAX_VALUE ? -1 : costs[N-1], min};\\r\\n\\t}\\r\\n\\r\\n\\tprivate static class Node implements Comparable{\\r\\n\\t\\tint No;\\r\\n\\t\\tint c;\\r\\n\\t\\tint f;\\r\\n\\t\\tpublic Node(int n, int c, int f){\\r\\n\\t\\t\\tNo = n;\\r\\n\\t\\t\\tthis.c = c;\\r\\n\\t\\t\\tthis.f = f;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t@Override\\r\\n\\t\\tpublic int compareTo(Object o){\\r\\n\\t\\t\\treturn c - ((Node)o).c;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t@Override\\r\\n\\t\\tpublic String toString(){\\r\\n\\t\\t\\treturn No + \\\" \\\" + c + \\\" \\\" + f;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tprivate static class InputReader {\\r\\n\\t    public BufferedReader reader;\\r\\n\\t    public StringTokenizer tokenizer;\\r\\n\\r\\n\\t    public InputReader() {\\r\\n\\t        try {\\r\\n\\t            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\\r\\n\\t        } catch (Exception e) {\\r\\n\\t            throw new NullPointerException(\\\"Could not create input stream\\\");\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\r\\n\\t    public InputReader(String fileName) {\\r\\n\\t        try {\\r\\n\\t            reader = new BufferedReader(new FileReader(new File(fileName)), 32768);\\r\\n\\t        } catch (Exception ex) {\\r\\n\\t            throw new NullPointerException(\\\"Input file does not exist! Put it in the project folder.\\\");\\r\\n\\t        }\\r\\n\\t        tokenizer = null;\\r\\n\\t    }\\r\\n\\r\\n\\t    public String next() {\\r\\n\\t        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\\r\\n\\t            try {\\r\\n\\t                tokenizer = new StringTokenizer(reader.readLine());\\r\\n\\t            } catch (IOException e) {\\r\\n\\t                throw new RuntimeException(e);\\r\\n\\t            }\\r\\n\\t        }\\r\\n\\t        return tokenizer.nextToken();\\r\\n\\t    }\\r\\n\\r\\n\\t    public boolean hasNextInt() throws IOException { return reader.ready(); }\\r\\n\\r\\n\\t    public int nextInt() {\\r\\n\\t        return Integer.parseInt(next());\\r\\n\\t    }\\r\\n\\r\\n\\t    public double nextDouble() {\\r\\n\\t        return Double.parseDouble(next());\\r\\n\\t    }\\r\\n\\r\\n\\t    public long nextLong() {\\r\\n\\t        return Long.parseLong(next());\\r\\n\\t    }\\r\\n\\r\\n\\t    public char nextChar() {\\r\\n\\t        return next().charAt(0);\\r\\n\\t    }\\r\\n\\r\\n\\t    /**\\r\\n\\t     * When you call next(), that entire line will be skipped.\\r\\n\\t     * No flushing buffers.\\r\\n\\t     * Doesn't work when you want to scan the remaining line.\\r\\n\\t     *\\r\\n\\t     * @return entire line\\r\\n\\t     */\\r\\n\\r\\n\\t    public String nextLine() {\\r\\n\\t        String str = \\\"\\\";\\r\\n\\t        try {\\r\\n\\t            str = reader.readLine();\\r\\n\\t            tokenizer = null;\\r\\n\\t        } catch (IOException e) {\\r\\n\\t            throw new RuntimeException(e);\\r\\n\\t        }\\r\\n\\t        return str;\\r\\n\\t    }\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })]\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-969","source":"USACO Gold 2019 December","title":"Milk Pumping","author":"Qi Wang, Ryan Chou"},"parent":{"name":"usaco-969","relativePath":"usaco-969.mdx"},"toc":{"cpp":[{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"shortest-paths","title":"Shortest Paths with Non-Negative Edge Weights"}}}}]},"problemInfo":{"uniqueId":"usaco-969","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=969"}},"pageContext":{"id":"usaco-969"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}