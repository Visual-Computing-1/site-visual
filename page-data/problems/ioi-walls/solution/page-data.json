{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/ioi-walls/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"ioi-00-walls\", source = \"IOI 2000\", title = \"Walls\", author = \"Kevin Sheng\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    PySection: _missingComponent(\"PySection\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, PySection, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"explanation\",\n      children: [_jsx(_components.a, {\n        href: \"#explanation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Explanation\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rather than treating the towns as nodes, instead treat the regions themselves as nodes with\\r\\nthe walls as the edges still.\\r\\nWe perform BFS from each node, logging the minimum distance from every region to every other region.\\r\\nFinally, we try all meeting regions and print out the one that minimizes the number of walls the members have to cross.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(M^2 L)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>M</mi><mn>2</mn></msup><mi>L</mi><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(M^2 L)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mord mathnormal\\\">L</span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <vector>\\r\\n#include <map>\\r\\n#include <algorithm>\\r\\n\\r\\nusing std::cout;\\r\\nusing std::endl;\\r\\nusing std::vector;\\r\\nusing std::pair;\\r\\n\\r\\nint main() {\\r\\n\\tint region_num;\\r\\n\\tint town_num;\\r\\n\\tint member_num;\\r\\n\\tstd::cin >> region_num >> town_num >> member_num;\\r\\n\\r\\n\\tvector<int> members(member_num);\\r\\n\\tfor (int& m : members) {\\r\\n\\t\\tstd::cin >> m;\\r\\n\\t\\tm--;\\r\\n\\t}\\r\\n\\tvector<vector<int>> town_regions(town_num);\\r\\n\\t// contains the walls (represented as a pair of towns) for each region\\r\\n\\tvector<vector<pair<int, int>>> regions(region_num);\\r\\n\\tfor (int r = 0; r < region_num; r++) {\\r\\n\\t\\tint border_num;\\r\\n\\t\\tstd::cin >> border_num;\\r\\n\\t\\tvector<int> towns(border_num);\\r\\n\\t\\tfor (int& t : towns) {\\r\\n\\t\\t\\tstd::cin >> t;\\r\\n\\t\\t\\tt--;\\r\\n\\t\\t\\ttown_regions[t].push_back(r);\\r\\n\\t\\t}\\r\\n\\t\\tfor (int t = 0; t < border_num; t++) {\\r\\n\\t\\t\\tregions[r].push_back({towns[t], towns[(t + 1) % border_num]});\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t// the walls previously processed (along with their associated regions)\\r\\n\\tstd::map<pair<int, int>, int> prev_walls;\\r\\n\\tvector<vector<int>> neighbors(region_num);\\r\\n\\tfor (int r = 0; r < region_num; r++) {\\r\\n\\t\\tfor (const pair<int, int>& w : regions[r]) {\\r\\n\\t\\t\\t// if we've seen this wall before, add that associated region\\r\\n\\t\\t\\tif (prev_walls.count(w)) {\\r\\n\\t\\t\\t\\t// dupes might happen but that doesn't really matter\\r\\n\\t\\t\\t\\tneighbors[r].push_back(prev_walls[w]);\\r\\n\\t\\t\\t\\tneighbors[prev_walls[w]].push_back(r);\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tprev_walls[w] = r;\\r\\n\\t\\t\\t\\tpair<int, int> reverse{w.second, w.first};\\r\\n\\t\\t\\t\\tprev_walls[reverse] = r;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tvector<vector<int>> min_crossings(region_num, vector<int>(region_num));\\r\\n\\t// BFS from each region and log the minimum distances\\r\\n\\tfor (int start = 0; start < region_num; start++) {\\r\\n\\t\\tint moves = 0;\\r\\n\\t\\tvector<bool> visited(region_num);\\r\\n\\t\\tvector<int> frontier{start};\\r\\n\\t\\tvisited[start] = true;\\r\\n\\t\\twhile (!frontier.empty()) {\\r\\n\\t\\t\\tvector<int> in_line;\\r\\n\\t\\t\\tmoves++;\\r\\n\\t\\t\\tfor (int r : frontier) {\\r\\n\\t\\t\\t\\tfor (int n : neighbors[r]) {\\r\\n\\t\\t\\t\\t\\tif (!visited[n]) {\\r\\n\\t\\t\\t\\t\\t\\tmin_crossings[start][n] = moves;\\r\\n\\t\\t\\t\\t\\t\\tvisited[n] = true;\\r\\n\\t\\t\\t\\t\\t\\tin_line.push_back(n);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tfrontier = in_line;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// get the best meeting region through brute force\\r\\n\\tint min_crossing_sum = INT32_MAX;\\r\\n\\tint best_region = -1;\\r\\n\\tfor (int meeting = 0; meeting < region_num; meeting++) {\\r\\n\\t\\tint this_min_cross = 0;\\r\\n\\t\\tfor (int m : members) {\\r\\n\\t\\t\\tint m_min_crossings = INT32_MAX;\\r\\n\\t\\t\\tfor (int t : town_regions[m]) {\\r\\n\\t\\t\\t\\tm_min_crossings = std::min(m_min_crossings, min_crossings[t][meeting]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tthis_min_cross += m_min_crossings;\\r\\n\\t\\t}\\r\\n\\t\\tif (this_min_cross < min_crossing_sum) {\\r\\n\\t\\t\\tmin_crossing_sum = this_min_cross;\\r\\n\\t\\t\\tbest_region = meeting;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tcout << min_crossing_sum << endl << best_region + 1 << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"region_num = int(input())\\r\\ntown_num = int(input())\\r\\nmember_num = int(input())\\r\\nmembers = [int(i) - 1 for i in input().split()]\\r\\nassert member_num == len(members)\\r\\n\\r\\ntown_regions = [[] for _ in range(town_num)]\\r\\n# contains the walls (represented as a pair of towns) for each region\\r\\nregions = [[] for _ in range(region_num)]\\r\\nfor r in range(region_num):\\r\\n\\tborder_num = int(input())\\r\\n\\tborder_towns = [int(i) - 1 for i in input().split()]\\r\\n\\tassert border_num == len(border_towns)\\r\\n\\tfor t in border_towns:\\r\\n\\t\\ttown_regions[t].append(r)\\r\\n\\tfor t in range(border_num):\\r\\n\\t\\tregions[r].append((border_towns[t], border_towns[(t + 1) % border_num]))\\r\\n\\r\\n# the walls previously processed (along with their associated regions)\\r\\nprev_walls = {}\\r\\nneighbors = [[] for _ in range(region_num)]\\r\\nfor r in range(region_num):\\r\\n\\tfor w in regions[r]:\\r\\n\\t\\tif w in prev_walls:\\r\\n\\t\\t\\t# dupes might happen but that doesn't really matter\\r\\n\\t\\t\\tneighbors[r].append(prev_walls[w])\\r\\n\\t\\t\\tneighbors[prev_walls[w]].append(r)\\r\\n\\t\\telse:\\r\\n\\t\\t\\tprev_walls[w] = r\\r\\n\\t\\t\\tprev_walls[(w[1], w[0])] = r\\r\\n\\r\\n# list multiplication is a bit faster than list comprehension\\r\\nmin_crossings = [[0] * region_num for _ in range(region_num)]\\r\\n# BFS from each region and log the minimum distances\\r\\nfor start in range(region_num):\\r\\n\\tmoves = 0\\r\\n\\tvisited = [False] * region_num\\r\\n\\tvisited[start] = True\\r\\n\\tfrontier = [start]\\r\\n\\twhile frontier:\\r\\n\\t\\tin_line = []\\r\\n\\t\\tmoves += 1\\r\\n\\t\\tfor r in frontier:\\r\\n\\t\\t\\tfor n in neighbors[r]:\\r\\n\\t\\t\\t\\tif not visited[n]:\\r\\n\\t\\t\\t\\t\\tmin_crossings[start][n] = moves\\r\\n\\t\\t\\t\\t\\tvisited[n] = True\\r\\n\\t\\t\\t\\t\\tin_line.append(n)\\r\\n\\t\\tfrontier = in_line\\r\\n\\r\\n# get the best meeting region through brute force\\r\\nmin_crossing_sum = float('inf')\\r\\nbest_region = -1\\r\\nfor meeting in range(region_num):\\r\\n\\tthis_min_cross = sum(\\r\\n\\t\\tmin([min_crossings[t][meeting] for t in town_regions[m]]) for m in members\\r\\n\\t)\\r\\n\\tif this_min_cross < min_crossing_sum:\\r\\n\\t\\tmin_crossing_sum = this_min_cross\\r\\n\\t\\tbest_region = meeting\\r\\n\\r\\nprint(min_crossing_sum)\\r\\nprint(best_region + 1)  # +1 because the region is 1-indexed\\n\"\n          })\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"ioi-00-walls","source":"IOI 2000","title":"Walls","author":"Kevin Sheng"},"parent":{"name":"ioi-00-walls","relativePath":"ioi-00-walls.mdx"},"toc":{"cpp":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Explanation","slug":"explanation"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"bfs","title":"Breadth First Search (BFS)"}}}}]},"problemInfo":{"uniqueId":"ioi-00-walls","url":"https://dmoj.ca/problem/ioi00p4"}},"pageContext":{"id":"ioi-00-walls"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}