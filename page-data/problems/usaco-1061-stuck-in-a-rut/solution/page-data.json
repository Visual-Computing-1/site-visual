{
    "componentChunkName": "component---src-templates-solution-template-tsx",
    "path": "/problems/usaco-1061-stuck-in-a-rut/solution",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"usaco-1061\", source = \"USACO Bronze 2020 December\", title = \"Stuck in a Rut\", author = \"Ryan Chou, Alex Yang, Raymond Luo\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\",\n    h2: \"h2\",\n    span: \"span\",\n    img: \"img\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    Info: _missingComponent(\"Info\")\n  }, _props.components), {HeaderLink, MATHSPAN, LanguageSection, CPPSection, PySection, JavaSection, Info, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"http://www.usaco.org/current/data/sol_prob3_bronze_dec20.html\",\n        target: \"_blank\",\n        rel: \"nofollow noopener noreferrer\",\n        children: \"Official Analysis (C++ and Java)\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"solution\",\n      children: [_jsx(_components.a, {\n        href: \"#solution\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Since \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"x, y \\\\leq 10^9\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>x</mi><mo separator=\\\"true\\\">,</mo><mi>y</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">x, y \\\\leq 10^9</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8304em;vertical-align:-0.1944em;\\\"></span><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"mpunct\\\">,</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">≤</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">9</span></span></span></span></span></span></span></span></span></span></span>\"\n      }), \", we can't simulate each time period. Instead, try to identify when pairs of cows intersect.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"One important observation is that cows can't move backwards, so the only way for two cows to collide is if \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n[x] > e[x] \",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi><mo stretchy=\\\"false\\\">[</mo><mi>x</mi><mo stretchy=\\\"false\\\">]</mo><mo>&gt;</mo><mi>e</mi><mo stretchy=\\\"false\\\">[</mo><mi>x</mi><mo stretchy=\\\"false\\\">]</mo></mrow><annotation encoding=\\\"application/x-tex\\\">n[x] &gt; e[x] </annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"mclose\\\">]</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">&gt;</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\">x</span><span class=\\\"mclose\\\">]</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"n[y] < e[y]\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>n</mi><mo stretchy=\\\"false\\\">[</mo><mi>y</mi><mo stretchy=\\\"false\\\">]</mo><mo>&lt;</mo><mi>e</mi><mo stretchy=\\\"false\\\">[</mo><mi>y</mi><mo stretchy=\\\"false\\\">]</mo></mrow><annotation encoding=\\\"application/x-tex\\\">n[y] &lt; e[y]</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">n</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span><span class=\\\"mclose\\\">]</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">&lt;</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathnormal\\\">e</span><span class=\\\"mopen\\\">[</span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.03588em;\\\">y</span><span class=\\\"mclose\\\">]</span></span></span></span>\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This ensures that the cows are positioned like this:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsxs(_components.span, {\n        className: \"gatsby-resp-image-wrapper\",\n        style: {\n          position: \"relative\",\n          display: \"block\",\n          marginLeft: \"auto\",\n          marginRight: \"auto\",\n          maxWidth: \"832px\"\n        },\n        children: [\"\\n      \", _jsxs(_components.a, {\n          className: \"gatsby-resp-image-link\",\n          href: \"/visual-site/static/ee4afdf7fe57261c61c5638a51900b63/f937e/intersection_example.png\",\n          style: {\n            display: \"block\"\n          },\n          target: \"_blank\",\n          rel: \"noopener\",\n          children: [\"\\n    \", _jsx(_components.span, {\n            className: \"gatsby-resp-image-background-image\",\n            style: {\n              paddingBottom: \"72.11538461538461%\",\n              position: \"relative\",\n              bottom: \"0\",\n              left: \"0\",\n              backgroundImage: \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABJ0AAASdAHeZh94AAAA+UlEQVQ4y6WSS2+DMBCE+f9/iZ56ypX3ASmAoZHMo6pUtSVk7alwsy6kVls5K41kr/C3MzYBAGitwbVd+1TAACmlhSmtjXwGWGCe51BKYXvcx60FFkVhgGud3p9xfJX3OcyyDBcis36UudFXfOUHTNMUdHU40wK6grwdJkliI7vuUG8eieUa6AS6DrgALvcWGMfxDugq7r+d6W+HURSBiHaRtuL7PRxf8FBM9n+9TbN75f/UBwH6F/eBmaQUwjBE0zToug5t21oJIYx4/bT2hTDf1nWNqqowz/O3QwaWZYlhGDBNE8ZxtFp7q273rL7vsSzLz8j3Fkf+BLWfSlF8r5SaAAAAAElFTkSuQmCC')\",\n              backgroundSize: \"cover\",\n              display: \"block\"\n            }\n          }), \"\\n  \", _jsx(_components.img, {\n            className: \"gatsby-resp-image-image\",\n            alt: \"intersection example\",\n            title: \"intersection example\",\n            src: \"/visual-site/static/ee4afdf7fe57261c61c5638a51900b63/6a350/intersection_example.png\",\n            srcSet: \"/visual-site/static/ee4afdf7fe57261c61c5638a51900b63/f29da/intersection_example.png 208w, /visual-site/static/ee4afdf7fe57261c61c5638a51900b63/5d0f3/intersection_example.png 416w, /visual-site/static/ee4afdf7fe57261c61c5638a51900b63/6a350/intersection_example.png 832w, /visual-site/static/ee4afdf7fe57261c61c5638a51900b63/f937e/intersection_example.png 957w\",\n            sizes: \"(max-width: 832px) 100vw, 832px\",\n            style: {\n              width: \"100%\",\n              height: \"100%\",\n              margin: \"0\",\n              verticalAlign: \"middle\",\n              position: \"absolute\",\n              top: \"0\",\n              left: \"0\"\n            },\n            loading: \"lazy\"\n          }), \"\\n  \"]\n        }), \"\\n    \"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now we can sort cows by their static coordinates, which ensures that earlier collisions will execute first (i.e., simulating left to right), and simulate those collisions.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Time Complexity:\"\n      }), \" \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      })]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\nint main() {\\r\\n\\tint N; cin >> N;\\r\\n\\tvector<array<int, 3>> n_cows, e_cows;\\r\\n\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\tstring dir;\\r\\n\\t\\tint x, y;\\r\\n\\t\\tcin >> dir >> x >> y;\\r\\n\\r\\n\\t\\t// we need to add i as well because we need to output them in order\\r\\n\\t\\tif (dir == \\\"N\\\") {\\r\\n\\t\\t\\tn_cows.push_back({x, y, i});\\r\\n\\t\\t} else {\\r\\n\\t\\t\\te_cows.push_back({x, y, i});\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// sort north cows by x value\\r\\n\\tsort(n_cows.begin(), n_cows.end());\\r\\n\\r\\n\\t// sort east cows by y value\\r\\n\\tsort(e_cows.begin(), e_cows.end(), [](auto &left, auto &right) {\\r\\n\\t\\treturn left[1] < right[1];\\r\\n\\t});\\r\\n\\r\\n\\t/* \\r\\n\\t * we sort them by x/y value because we know that, for a single cow, \\r\\n\\t * it reaches a lower x/y value and then a higher one. \\r\\n\\t * Thus, it is more we would not miss any earlier collisions\\r\\n\\t * if we iterate from lower to a higher value. \\r\\n\\t */\\r\\n\\r\\n\\t// stores the amount of grass it eats\\r\\n\\tvector<int> stop(N);\\r\\n\\tfor (int i = 0; i < N; i++) {\\r\\n\\t\\tstop[i] = -1;\\r\\n  \\t}\\r\\n\\r\\n\\r\\n\\tfor (auto n_cow : n_cows) {\\r\\n    \\t\\tfor (auto e_cow : e_cows) {\\r\\n      \\t\\t\\t/*\\r\\n\\t\\t\\t * make sure that the north cow's x coord is less than the east cow's x coord,\\r\\n      \\t\\t\\t * and the north cow's y coord is less than an east cow's y coord.\\r\\n\\t\\t\\t */\\r\\n      \\t\\t\\tif (n_cow[0] > e_cow[0] && n_cow[1] < e_cow[1]) {\\r\\n\\t\\t\\t\\tint n_dist = e_cow[1] - n_cow[1];\\r\\n        \\t\\t\\tint e_dist = n_cow[0] - e_cow[0];\\r\\n\\r\\n        \\t\\t\\t/*\\r\\n\\t\\t\\t\\t * we need to check that the east cow is not stopped previously.\\r\\n        \\t\\t\\t * (Technically we need to check north cow too, but we don't need to \\r\\n        \\t\\t\\t * because we break out of the loop once a north cow stops.)\\r\\n\\t\\t\\t\\t */\\r\\n        \\t\\t\\tif (n_dist < e_dist && stop[e_cow[2]] == -1) {\\r\\n          \\t\\t\\t\\tstop[e_cow[2]] = e_dist;\\r\\n        \\t\\t\\t} else if (e_dist < n_dist && stop[e_cow[2]] == -1) {\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t * once we know that this north cow stops, we can move on to the next one, \\r\\n          \\t\\t\\t\\t * i.e. skip all of the rest of east cows.\\r\\n\\t\\t\\t\\t\\t */\\r\\n          \\t\\t\\t\\tstop[n_cow[2]] = n_dist;\\r\\n          \\t\\t\\t\\tbreak;\\r\\n        \\t\\t\\t}\\r\\n\\t\\t\\t} \\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n  \\tfor (int i = 0; i < N; i++) {\\r\\n    \\t\\tif (stop[i] == -1) {\\r\\n      \\t\\t\\tcout << \\\"Infinity\\\" << '\\\\n';\\r\\n    \\t\\t} else {\\r\\n      \\t\\t\\tcout << stop[i] << '\\\\n';\\r\\n    \\t\\t}\\r\\n  \\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"n = int(input())\\r\\nncows = []\\r\\necows = []\\r\\n\\r\\nfor i in range(n):\\r\\n\\tdir, x, y = input().split()\\r\\n\\t# Also append i since we have to return them\\r\\n\\t# in the same order they were given to us.\\r\\n\\tif dir == 'N':\\r\\n\\t\\tncows.append((int(x), int(y), i))\\r\\n\\telif dir == 'E':\\r\\n\\t\\tecows.append((int(x), int(y), i))\\r\\n\\r\\n# Sort north cows by x coordinates.\\r\\nncows.sort()\\r\\n# Sort east cows by y coordinates.\\r\\necows.sort(key=lambda cow: cow[1])\\r\\n\\r\\n# Stores times which cows stop.\\r\\nstoppin = [None] * n\\r\\n# Checking every combination of cows.\\r\\nfor ncow in ncows:\\r\\n\\tfor ecow in ecows:\\r\\n\\t\\t\\\"\\\"\\\"\\r\\n\\t\\tThe north cows can't move down and east cows\\r\\n\\t\\tcan't move backwards, so a north cow's x coord must\\r\\n\\t\\tbe less than an east cow's x coordinate, and an north \\r\\n\\t\\tcow's y coordinate must be less than an east cow's y coordinate\\r\\n\\t\\tfor them to collide.\\r\\n\\t\\t\\\"\\\"\\\"\\r\\n\\t\\tif ncow[0] > ecow[0] and ncow[1] < ecow[1]:\\r\\n\\t\\t\\t# Distance they travel.\\r\\n\\t\\t\\tntrav = ecow[1] - ncow[1]\\r\\n\\t\\t\\tetrav = ncow[0] - ecow[0]\\r\\n\\r\\n\\t\\t\\t\\\"\\\"\\\"\\r\\n\\t\\t\\tIf the north cow gets to the meeting place before\\r\\n\\t\\t\\tthe east cow and the east cow has not been stopped\\r\\n\\t\\t\\talready,\\r\\n\\t\\t\\t\\\"\\\"\\\"\\r\\n\\t\\t\\tif ntrav < etrav and stoppin[ecow[2]] == None:\\r\\n\\t\\t\\t\\t\\\"\\\"\\\"\\r\\n\\t\\t\\t\\tthen we can set the east cow's stopping point.\\r\\n\\t\\t\\t\\tWe only save the x coordinate because the y coord \\r\\n\\t\\t\\t\\tstays constant.\\r\\n\\t\\t\\t\\t\\\"\\\"\\\"\\r\\n\\t\\t\\t\\tstoppin[ecow[2]] = ncow[0]\\r\\n\\r\\n\\t\\t\\t# If the east cow gets there before, then we can save the \\r\\n\\t\\t\\t# north cow's position.\\r\\n\\t\\t\\tif ntrav > etrav and stoppin[ecow[2]] == None:\\r\\n\\t\\t\\t\\tstoppin[ncow[2]] = ecow[1]\\r\\n\\t\\t\\t\\t# We iterate per north cow, so we can move on to the\\r\\n\\t\\t\\t\\t# next north cow if this cow doesn't move anymore.\\r\\n\\t\\t\\t\\tbreak\\r\\n\\r\\n# Tracks how much they eat.\\r\\neat = [-1] * n\\r\\nfor nc in ncows:\\r\\n\\t# If the element is None, then the cow never stops\\r\\n\\t# and eats forever.\\r\\n\\tif stoppin[nc[2]] != None:\\r\\n\\t\\t# Eaten is (current position - original position)\\r\\n\\t\\teat[nc[2]] = stoppin[nc[2]] - nc[1]\\r\\n\\t\\t\\r\\nfor ec in ecows:\\r\\n\\tif stoppin[ec[2]] != None:\\r\\n\\t\\teat[ec[2]] = stoppin[ec[2]] - ec[0]\\r\\n\\r\\nfor x in eat:\\r\\n\\t# Never stops.\\r\\n\\tif x == -1:\\r\\n\\t\\tprint('Infinity')\\r\\n\\telse:\\r\\n\\t\\tprint(x)\\n\"\n          })\n        })\n      }), _jsxs(JavaSection, {\n        children: [_jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class StuckInARut {\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tPrintWriter pw = new PrintWriter(System.out);\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(r.readLine());\\r\\n\\r\\n\\t\\tint n = Integer.parseInt(st.nextToken());\\r\\n\\t\\tList<int[]> northCows = new ArrayList<>();\\r\\n\\t\\tList<int[]> eastCows = new ArrayList<>();\\r\\n\\t\\tfor (int i = 0; i < n; i++) {\\r\\n\\t\\t\\tst = new StringTokenizer(r.readLine());\\r\\n\\t\\t\\tString dir = st.nextToken();\\r\\n\\t\\t\\tint x = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tint y = Integer.parseInt(st.nextToken());\\r\\n\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t * Also append i since we have to return them\\r\\n\\t\\t\\t * in the same order they were given to us.\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tif (dir.equals(\\\"N\\\")) {\\r\\n\\t\\t\\t\\tnorthCows.add(new int[]{x, y, i});\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\teastCows.add(new int[]{x, y, i});\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\t/*\\r\\n\\t\\t * https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html\\r\\n\\t\\t * sort east cows by comparing x positions\\r\\n\\t\\t * (second element in array)\\r\\n\\t\\t */\\r\\n\\t\\teastCows.sort(Comparator.comparingInt(o -> o[1]));\\r\\n\\t\\t/*\\r\\n\\t\\t * sort east cows by comparing y positions\\r\\n\\t\\t * (first element in array)\\r\\n\\t\\t */\\r\\n\\t\\tnorthCows.sort(Comparator.comparingInt(o -> o[0]));\\r\\n\\r\\n\\t\\t// stores locations of stopped cows\\r\\n\\t\\tint[] stoppedLocations = new int[n];\\r\\n\\t\\tArrays.fill(stoppedLocations, -1);\\r\\n\\t\\t// check every combination of cows\\r\\n\\t\\tfor (int[] northCow : northCows) {\\r\\n\\t\\t\\tfor (int[] eastCow : eastCows) {\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t * The north cows can't move down, and the east cows\\r\\n\\t\\t\\t\\t * can't move backwards, so a north cow's x coordinate must\\r\\n\\t\\t\\t\\t * be less than an east cow's x coordinate, and a north\\r\\n\\t\\t\\t\\t * cow's y coordinate must be less than an east cow's y coordinate\\r\\n\\t\\t\\t\\t * for them to collide.\\r\\n\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\tif (northCow[0] > eastCow[0] && northCow[1] < eastCow[1]) {\\r\\n\\t\\t\\t\\t\\t// Distance they travel\\r\\n\\t\\t\\t\\t\\tint northDistance = eastCow[1] - northCow[1];\\r\\n\\t\\t\\t\\t\\tint eastDistance = northCow[0] - eastCow[0];\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t * If the north cow gets to the meeting place before\\r\\n\\t\\t\\t\\t\\t * the east cow and the east cow has not been stopped\\r\\n\\t\\t\\t\\t\\t * already,\\r\\n\\t\\t\\t\\t\\t  */\\r\\n\\t\\t\\t\\t\\tif (northDistance < eastDistance && \\r\\n\\t\\t\\t\\t\\t\\tstoppedLocations[eastCow[2]] == -1) {\\r\\n\\t\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\t * then we can set the east cow's stopping point.\\r\\n\\t\\t\\t\\t\\t\\t * We only save the x coordinate because the y coordinate\\r\\n\\t\\t\\t\\t\\t\\t * stays constant.\\r\\n\\t\\t\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\t\\t\\tstoppedLocations[eastCow[2]] = northCow[0];\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t * If the east cow gets there before, \\r\\n\\t\\t\\t\\t\\t * we can save the north cow's position.\\r\\n\\t\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\t\\tif (northDistance > eastDistance && \\r\\n\\t\\t\\t\\t\\t\\tstoppedLocations[eastCow[2]] == -1) {\\r\\n\\t\\t\\t\\t\\t\\tstoppedLocations[northCow[2]] = eastCow[1];\\r\\n\\t\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t\\t * We iterate per north cow, so we can move on to the\\r\\n\\t\\t\\t\\t\\t\\t * next north cow if this cow can't move anymore\\r\\n\\t\\t\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Tracks distance traveled.\\r\\n\\t\\tint[] distances = new int[n];\\r\\n\\t\\tArrays.fill(distances, -1);\\r\\n\\t\\tfor (int[] northCow : northCows) {\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t * If this array element hasn't been touched, \\r\\n\\t\\t\\t * the cow never stops and eats forever.\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tif (stoppedLocations[northCow[2]] != -1) {\\r\\n\\t\\t\\t\\t// Eaten is (current position - original position) \\r\\n\\t\\t\\t\\tdistances[northCow[2]] = stoppedLocations[northCow[2]] - northCow[1];\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int[] eastCow : eastCows) {\\r\\n\\t\\t\\tif (stoppedLocations[eastCow[2]] != -1) {\\r\\n\\t\\t\\t\\tdistances[eastCow[2]] = stoppedLocations[eastCow[2]] - eastCow[0];\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (int x : distances) {\\r\\n\\t\\t\\t// Ternary operator\\r\\n\\t\\t\\tpw.println(x == -1 ? \\\"Infinity\\\" : x);\\r\\n\\t\\t}\\r\\n\\t\\tpw.close();\\r\\n\\t}\\r\\n}\\r\\n\\n\"\n          })\n        }), _jsxs(Info, {\n          title: \"Ternary Operator\",\n          children: [_jsx(_components.p, {\n            children: \"A ternary operator is like a condensed if/else statement.\\r\\nIf a logical expression inside the parantheses is true,\\r\\nthe operator \\\"returns\\\" the first value in a pair seperated by a colon.\\r\\nOtherwise, it uses the second value.\\r\\nThe general structure is as follows:\"\n          }), _jsxs(_components.p, {\n            children: [_jsx(_components.code, {\n              children: \"foo = logic ?\"\n            }), \" [set \", _jsx(_components.code, {\n              children: \"foo\"\n            }), \" to this value if \", _jsx(_components.code, {\n              children: \"logic\"\n            }), \" evaluates to true] \", _jsx(_components.code, {\n              children: \":\"\n            }), \" [set \", _jsx(_components.code, {\n              children: \"foo\"\n            }), \" to this value \", _jsx(_components.code, {\n              children: \"logic\"\n            }), \" evaluates to false]\"]\n          }), _jsx(\"a\", {\n            href: \"https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html#:~:text=Another%20conditional%20operator,value2%20to%20result.%22\",\n            children: _jsx(_components.p, {\n              children: \"Oracle tutorial on ternary statements\"\n            })\n          })]\n        })]\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  source,\n  title,\n  author,\n  default: MDXContent\n};\n","frontmatter":{"id":"usaco-1061","source":"USACO Bronze 2020 December","title":"Stuck in a Rut","author":"Ryan Chou, Alex Yang, Raymond Luo"},"parent":{"name":"usaco-1061","relativePath":"usaco-1061.mdx"},"toc":{"cpp":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"java":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}],"py":[{"depth":2,"value":"Solution","slug":"solution"},{"depth":2,"value":"Implementation","slug":"implementation"}]}},"allProblemInfo":{"edges":[{"node":{"module":{"frontmatter":{"id":"simulation","title":"Simulation"}}}}]},"problemInfo":{"uniqueId":"usaco-1061","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1061"}},"pageContext":{"id":"usaco-1061"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}