{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/report/informes-procedural-texturing",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"informes-procedural-texturing\", title = \"Procedural Texturing\", author = \"Oscar Julián Tinjacá y Luis Miguel Báez\", description = \"Procedural Texturing\";\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    a: \"a\",\n    p: \"p\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Spoiler: _missingComponent(\"Spoiler\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\")\n  }, _props.components), {HeaderLink, Spoiler, Resources, Resource, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h1, {\n      id: \"procedural-texturing\",\n      children: [_jsx(_components.a, {\n        href: \"#procedural-texturing\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Procedural Texturing\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Las texturas de procedimiento son texturas (a veces también llamadas mapas) que genera la computadora utilizando un conjunto fijo de parámetros. ¡Esto significa que la computadora puede hacer variaciones únicas de una textura por sí misma!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"El proceso utilizado para hacer esto se llama generación procedimental.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"La generación de procedimientos es un término general para cuando una computadora genera datos automáticamente, en lugar de que el usuario tenga que hacerlo a mano.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Esto se usa a menudo en muchas otras áreas de trabajo y juegos en 3D. Minecraft, por ejemplo, tiene un mapa que se genera por procedimientos, lo que le permite ser tan grande. La mano de obra para hacer cosas de ese tamaño sería poco práctica.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Las texturas de procedimiento se pueden encontrar en algunos software 3D de forma predeterminada, y también en software de texturización creado específicamente.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Substance Painter es un buen ejemplo de software que tiene varios tipos de generadores de procedimientos para crear texturas únicas fácilmente.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"algoritmos-de-generación-de-laberintos\",\n      children: [_jsx(_components.a, {\n        href: \"#algoritmos-de-generaci%C3%B3n-de-laberintos\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Algoritmos de Generación de laberintos\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Algoritmos clásicos de generación de laberintos a nivel de software\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Randomized DFS\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Utilizando Recursividad\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Utilizando un Stack\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Randomized Kruskal's algorithm\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Randomized Prim's algorithm\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Wilson's algorithm\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Aldous-Broder algorithm\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Cellular automaton algorithms\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Como observamos anteriormente existen múltiples algoritmos para la generación aleatoria de laberintos a nivel de software, cada uno tiene ventajas y desventajas respecto a los demás dependiendo las necesidades y requerimientos qué se tengan. Sin embargo, nos encontramos con un gran problema cuando intentamos realizar esta generación utilizando estos algoritmos a nivel de hardware de forma paralela debido a qué la mayoría de estos algoritmos requieren información del estado de celdas previas y esto es imposible de realizar cuando se está ejecutando un procedimiento de forma paralela. Una posible solución a este problema es utilizar estructura de datos  mediante memoria compartida transversal a todos los procesos. No obstante, revisando la documentación de Fragment Shader / GLSL, no es posible realizar este procedimiento, por lo cual debemos descartar la gran mayoría de los algoritmos a nivel de software qué realizan este procedimiento.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"patrón-de-truchet\",\n      children: [_jsx(_components.a, {\n        href: \"#patr%C3%B3n-de-truchet\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Patrón de Truchet\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"En el siglo XVIII el cura dominico frances Sébastien Truchet qué estaba muy interesado en los patrones qué se podían formar con las baldosas, para formar figuras geométricas novedosas con ellas. Empezó dividiendo las baldosas por la mitad en diagonal y las pintaba solo la mitad.\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Baldosa-de-Truchet.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Después de ello se dió a la gran tarea de contar el número de distintas formas qué se pueden formar utilizando dos baldosas, rotandolas cada una. Sé dio cuenta qué se podian generar 54 patrones y el los agrupo en 10 grupos como se puede ver en la (imagen x)\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Truchet-Table.png\",\n        width: \"70%\",\n        height: \"70%\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"El número posible de combinaciones es muy grande y muchas de ellas tienen algún tipo de simetría qué puede ser interesante observar, como lo realizó Truchet  en la siguiente imagen:\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Truchet-Figure.png\",\n        width: \"70%\",\n        height: \"70%\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Casi 300 Años después el ingeniero metalúrgico Cyril Stanley Smith en un proyecto como profesor de la universidad escribió un artículo científico relacionado y en continuación al trabajo de Truchet relacionándolos con los efectos de la materia y introduciendo de la misma forma unos diseños sencillos pero interesantes qué se combinan entre sí, consiguiendo un entramado de zonas abiertas y cerradas similares a un laberinto como lo puede ver a continuación:\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Tile-1.png\"\n      })\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Maze.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Únicamente cambiando el diseño de una baldosa, se pueden formar laberintos geométricamente diferentes como se puede observar en la imagen de abajo.\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Tile-Square.png\"\n      })\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Maze-Square.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Así mismo, cambiando la baldosa utilizando una, dos y más líneas diagonales y circulares, se pueden conseguir muchas figuras geométricas con geometrías complejas pero estéticamente interesantes.\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"img\", {\n        src: \"https://visual-computing-1.github.io/visual-site/img/Types.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A continuación se encuentra la implementación de los Patrones de Truchet en p5.js y Fragment Shader, para la generación de laberintos aleatorios utilizando diferentes baldosas:\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"div\", {\n        id: \"ProceduralTexturing\"\n      })\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"P5.js\",\n      children: _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"let sh, u_time;\\r\\nlet button;\\r\\nlet options;\\r\\nlet u_option;\\r\\n\\r\\nconst mapping = { \\\"square\\\":   0, \\\"circle\\\":   1, \\\"triangle\\\": 2 };\\r\\n\\r\\nconst SIDE = 430;\\r\\nconst PADDING = SIDE / 4;\\r\\n\\r\\nlet u_seed;\\r\\n\\r\\nfunction preload(){\\r\\n  sh = readShader(\\\"https://visual-computing-1.github.io/visual-site/js/proceduralTexturing/ProceduralTexturing.frag\\\")\\r\\n}\\r\\n\\r\\nfunction setup() {\\r\\n  createCanvas(SIDE, SIDE, WEBGL)\\r\\n  u_time = createSlider(95, 100, 96, 1);\\r\\n  u_time.position(10, 25);\\r\\n  button = createButton(\\\"randomly generate\\\");\\r\\n  button.mousePressed(changeBG);\\r\\n  u_seed = random(1, 30);\\r\\n  \\r\\n  options = createSelect();\\r\\n  options.position(10, 10);\\r\\n  options.option(\\\"square\\\");   // square:   0\\r\\n  options.option(\\\"circle\\\");   // circle:   1\\r\\n  options.option(\\\"triangle\\\"); // triangle: 2\\r\\n  options.selected(\\\"square\\\");\\r\\n  u_option = \\\"square\\\";\\r\\n  \\r\\n  options.changed(changeOptions);\\r\\n  \\r\\n  sh.setUniform(\\\"u_option\\\", mapping[u_option]);\\r\\n}\\r\\n\\r\\nfunction draw() {\\r\\n  background(0);\\r\\n  shader(sh);\\r\\n  \\r\\n  sh.setUniform(\\\"u_time\\\", u_time.value());\\r\\n  sh.setUniform(\\\"u_resolution\\\", [width, height]);\\r\\n  sh.setUniform(\\\"u_seed\\\", u_seed);\\r\\n  \\r\\n  rect(-width + PADDING, -height + PADDING, width + PADDING, height + PADDING);\\r\\n}\\r\\n\\r\\nfunction changeBG() {\\r\\n  u_seed = random(1, 30);\\r\\n  sh.setUniform(\\\"u_seed\\\", u_seed);\\r\\n}\\r\\n\\r\\nfunction changeOptions() {\\r\\n  u_option = options.value();\\r\\n  sh.setUniform(\\\"u_option\\\", mapping[u_option]);\\r\\n}\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"Fragment Shader\",\n      children: _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"// Procedural Texturing using Truchet Pattern\\r\\n\\r\\n#ifdef GL_ES\\r\\nprecision mediump float;\\r\\n#endif\\r\\n\\r\\nuniform vec2 u_resolution;\\r\\nuniform float u_time;\\r\\nuniform float u_seed;\\r\\nuniform int u_option;\\r\\n\\r\\nfloat random(in vec2 coord) {\\r\\n    return fract(sin(dot(coord.xy, vec2(12.9898,78.233)))* 43758.5453123*u_seed);\\r\\n}\\r\\n\\r\\nvec2 truchetPattern(in vec2 pos, in float index){\\r\\n    index = fract(((index-0.5)*2.0));\\r\\n    if (index > 0.75) {\\r\\n        pos = vec2(1.0) - pos;\\r\\n    } else if (index > 0.5) {\\r\\n        pos = vec2(1.0-pos.x, pos.y);\\r\\n    } else if (index > 0.25) {\\r\\n        pos = 1.0-vec2(1.0-pos.x, pos.y);\\r\\n    }\\r\\n    return pos;\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\\r\\n    st *= 10.0;\\r\\n    st = (st - vec2(5.0)) * (abs(sin(u_time * 0.2)) * 5.0);\\r\\n\\r\\n    vec2 ipos = floor(st);  // integer\\r\\n    vec2 fpos = fract(st);  // fraction\\r\\n\\r\\n    vec2 tile = truchetPattern(fpos, random(ipos));\\r\\n\\r\\n    float color = 0.0;\\r\\n\\r\\n    if(u_option == 1) { // Circles\\r\\n        color = (\\r\\n            (\\r\\n                step(length(tile), 0.6) -\\r\\n                step(length(tile), 0.4)\\r\\n            ) +\\r\\n            (\\r\\n                step(length(tile - vec2(1.0)), 0.6) -\\r\\n                step(length(tile - vec2(1.0)), 0.4)\\r\\n            )\\r\\n        );\\r\\n    } else if(u_option == 2) { // Truchet (2 triangles)\\r\\n        color = step(tile.x, tile.y);\\r\\n    } else { // Maze\\r\\n        color = smoothstep(tile.x - 0.3, tile.x, tile.y) - smoothstep(tile.x, tile.x + 0.3, tile.y);\\r\\n    }\\r\\n    gl_FragColor = vec4(vec3(color), 1.0);\\r\\n}\\n\"\n        })\n      })\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"iframe\", {\n        srcDoc: \"\\r\\n<html>\\r\\n<head>\\r\\n<script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.1/p5.min.js></script>\\r\\n<script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> \\r\\n<script src='https://visual-computing-1.github.io/visual-site/js/proceduralTexturing/sketch.js'></script>\\r\\n</head>\\r\\n<body>\\r\\n</body>\\r\\n</html>\",\n        width: \"625px\",\n        height: \"475px\"\n      })\n    }), \"\\n\", _jsxs(Resources, {\n      title: \"References\",\n      children: [_jsx(Resource, {\n        source: \"Concept Art Empire\",\n        url: \"https://conceptartempire.com/procedural-textures-maps\",\n        title: \"What are Procedural Textures (Procedural Maps)?\",\n        children: _jsx(_components.p, {\n          children: \"Thomas Denham\"\n        })\n      }), _jsx(Resource, {\n        source: \"Hacker Ludico Blog Spot\",\n        url: \"https://hackerludico.blogspot.com/2017/06/una-simple-baldosa-i.html\",\n        title: \"UNA SIMPLE BALDOSA (I)\",\n        children: _jsx(_components.p, {\n          children: \"Chuso Jar\"\n        })\n      }), _jsx(Resource, {\n        source: \"The Book of Shaders\",\n        url: \"https://thebookofshaders.com/10/\",\n        title: \"Generative Designs\",\n        children: _jsx(_components.p, {\n          children: \"Patricio Gonzalez Vivo & Jen Lowe\"\n        })\n      })]\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  author,\n  description,\n  default: MDXContent\n};\n","frontmatter":{"title":"Procedural Texturing","author":"Oscar Julián Tinjacá y Luis Miguel Báez","contributors":null,"id":"informes-procedural-texturing","prerequisites":null,"description":"Procedural Texturing","frequency":null},"parent":{"name":"Informes-ProceduralTexturing","relativePath":"0_Report/Informes-ProceduralTexturing.mdx"},"fields":{"division":"report"},"toc":{"cpp":[{"depth":1,"value":"Procedural Texturing","slug":"procedural-texturing"},{"depth":2,"value":"Algoritmos de Generación de laberintos","slug":"algoritmos-de-generación-de-laberintos"},{"depth":2,"value":"Patrón de Truchet","slug":"patrón-de-truchet"}],"java":[{"depth":1,"value":"Procedural Texturing","slug":"procedural-texturing"},{"depth":2,"value":"Algoritmos de Generación de laberintos","slug":"algoritmos-de-generación-de-laberintos"},{"depth":2,"value":"Patrón de Truchet","slug":"patrón-de-truchet"}],"py":[{"depth":1,"value":"Procedural Texturing","slug":"procedural-texturing"},{"depth":2,"value":"Algoritmos de Generación de laberintos","slug":"algoritmos-de-generación-de-laberintos"},{"depth":2,"value":"Patrón de Truchet","slug":"patrón-de-truchet"}]}},"moduleProblemLists":null},"pageContext":{"id":"informes-procedural-texturing"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}