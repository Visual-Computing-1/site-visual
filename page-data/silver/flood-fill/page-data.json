{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/silver/flood-fill",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*\n<Resources>\n<Resource\nsource=\"GFG\"\ntitle=\"Flood Fill\"\nurl=\"flood-fill-algorithm-implement-fill-paint\"\n/>\n</Resources>*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"flood-fill\", redirects = [\"/silver/ff\"], title = \"Flood Fill\", author = \"Darren Yao\", contributors = \"Kevin Sheng\", prerequisites = [\"dfs\"], description = \"Finding connected components in a graph represented by a grid.\", frequency = 3;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    p: \"p\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    em: \"em\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    Warning: _missingComponent(\"Warning\"),\n    Problems: _missingComponent(\"Problems\")\n  }, _props.components), {HeaderLink, Resources, Resource, MATHSPAN, LanguageSection, CPPSection, JavaSection, PySection, FocusProblem, Warning, Problems, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"resources\",\n      children: [_jsx(_components.a, {\n        href: \"#resources\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Resources\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"IUSACO\",\n        title: \"10.5 - Flood Fill\",\n        children: _jsx(_components.p, {\n          children: \"module is based off this\"\n        })\n      }), _jsx(Resource, {\n        source: \"CP2\",\n        title: \"4.2.4 - Flood Fill\",\n        children: _jsx(_components.p, {\n          children: \"code + example\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"introduction\",\n      children: [_jsx(_components.a, {\n        href: \"#introduction\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Introduction\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Flood fill\"\n      }), \" is an algorithm that identifies and labels the connected\\r\\ncomponent that a particular cell belongs to in a multidimensional array.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For example, suppose that we want to split the following grid into components of\\r\\nconnected cells with the same number.\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsx(\"table\", {\n        className: \"text-center\",\n        children: _jsxs(\"tbody\", {\n          children: [_jsxs(\"tr\", {\n            children: [_jsx(\"td\", {\n              children: \"2\"\n            }), \"\\r\\n\", _jsx(\"td\", {\n              children: \"2\"\n            }), \"\\r\\n\", _jsx(\"td\", {\n              children: \"1\"\n            })]\n          }), _jsxs(\"tr\", {\n            children: [_jsx(\"td\", {\n              children: \"2\"\n            }), \"\\r\\n\", _jsx(\"td\", {\n              children: \"1\"\n            }), \"\\r\\n\", _jsx(\"td\", {\n              children: \"2\"\n            })]\n          }), _jsxs(\"tr\", {\n            children: [_jsx(\"td\", {\n              children: \"2\"\n            }), \"\\r\\n\", _jsx(\"td\", {\n              children: \"2\"\n            }), \"\\r\\n\", _jsx(\"td\", {\n              children: \"1\"\n            })]\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let's start the flood fill from the top-left cell. The color scheme will be red\\r\\nfor the node currently being processed, blue for nodes already visited, and\\r\\nuncolored for nodes not yet visited.\"\n    }), \"\\n\", _jsx(\"center\", {\n      children: _jsxs(\"div\", {\n        className: \"grid grid-cols-2 sm:grid-cols-3 gap-y-6 sm:gap-y-12 justify-evenly place-items-center max-w-lg\",\n        children: [_jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-red-200 dark:bg-red-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        }), _jsx(\"table\", {\n          className: \"text-center\",\n          children: _jsxs(\"tbody\", {\n            children: [_jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"2\"\n              })]\n            }), _jsxs(\"tr\", {\n              children: [_jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                className: \"bg-blue-200 dark:bg-blue-800\",\n                children: \"2\"\n              }), \"\\r\\n\", _jsx(\"td\", {\n                children: \"1\"\n              })]\n            })]\n          })\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As opposed to an explicit graph where the edges are given, a grid is an implicit\\r\\ngraph. This means that the neighbors are just the nodes directly adjacent in the\\r\\nfour cardinal directions.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Usually, grids given in problems will be \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\\\"application/x-tex\\\">N</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span>\"\n      }), \" by \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"M\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\\\"application/x-tex\\\">M</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span></span></span></span>\"\n      }), \", so the first line of the\\r\\ninput contains the numbers \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\\\"application/x-tex\\\">N</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span>\"\n      }), \" and \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"M\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\\\"application/x-tex\\\">M</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span></span></span></span>\"\n      }), \". In this example, we will use a\\r\\ntwo-dimensional integer array to store the grid, but depending on the problem, a\\r\\ntwo-dimensional character array or a two-dimensional boolean array may be more\\r\\nappropriate. Then, there are \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\\\"application/x-tex\\\">N</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span></span></span></span>\"\n      }), \" rows, each with \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"M\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\\\"application/x-tex\\\">M</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span></span></span></span>\"\n      }), \" numbers containing the\\r\\ncontents of each square in the grid. Example input might look like the following\\r\\n(varies between problems):\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"3 4\\r\\n1 1 2 1\\r\\n2 3 2 1\\r\\n1 3 3 3\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And we’ll want to input the grid as follows:\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\nconst int MAX_N = 1000;\\r\\n\\r\\nint grid[MAX_N][MAX_N];\\r\\nint row_num;\\r\\nint col_num;\\r\\n\\r\\nint main() {\\r\\n\\tcin >> row_num >> col_num;\\r\\n\\tfor (int r = 0; r < row_num; r++) {\\r\\n\\t\\tfor (int c = 0; c < col_num; c++) {\\r\\n\\t\\t\\tcin >> grid[r][c];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.StringTokenizer;\\r\\n\\r\\npublic class Floodfill {\\r\\n\\tprivate static int[][] grid;\\r\\n\\tprivate static int rowNum;\\r\\n\\tprivate static int colNum;\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader read = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tStringTokenizer dims = new StringTokenizer(read.readLine());\\r\\n\\t\\trowNum = Integer.parseInt(dims.nextToken());\\r\\n\\t\\tcolNum = Integer.parseInt(dims.nextToken());\\r\\n\\t\\tgrid = new int[rowNum][colNum];\\r\\n\\t\\tfor (int r = 0; r < rowNum; r++) {\\r\\n\\t\\t\\tgrid[r] = Arrays.stream(read.readLine().split(\\\" \\\"))\\r\\n\\t\\t\\t\\t\\t.mapToInt(Integer::parseInt)\\r\\n\\t\\t\\t\\t\\t.toArray();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"row_num, col_num = [int(i) for i in input().split()]\\r\\ngrid = []\\r\\nfor _ in range(row_num):\\r\\n\\tgrid.append([int(i) for i in input().split()])\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", \"\\n\", _jsxs(_components.p, {\n      children: [\"When doing flood fill, we will maintain an \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"N\\\\times M\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi><mo>×</mo><mi>M</mi></mrow><annotation encoding=\\\"application/x-tex\\\">N\\\\times M</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">×</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">M</span></span></span></span>\"\n      }), \" array of booleans to keep\\r\\ntrack of which squares have been visited, and a global variable to maintain the\\r\\nsize of the current component we are visiting. Make sure to store the grid, the\\r\\nvisited array, dimensions, and the current size variable globally.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This means that we want to recursively call the search function for the squares\\r\\nabove, below, and to the left and right of our current square. Due to its\\r\\nrecursive nature, floodfill can be thought of as a modified version of\\r\\n\", _jsx(_components.a, {\n        href: \"/silver/dfs\",\n        children: \"DFS\"\n      }), \". The algorithm to\\r\\nfind the size of a connected component in a grid using flood fill is as follows\\r\\n(we’ll also maintain a 2D visited array).\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The code below shows the global/static variables we need to maintain while doing\\r\\nflood fill and the flood fill algorithm itself:\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"const int MAX_N = 1000;\\r\\n\\r\\nint grid[MAX_N][MAX_N];  // the grid itself\\r\\nint row_num;\\r\\nint col_num;\\r\\nbool visited[MAX_N][MAX_N];  // keeps track of which nodes have been visited\\r\\nint curr_size = 0;  // reset to 0 each time we start a new component\\r\\n\\r\\nvoid floodfill(int r, int c, int color){\\r\\n\\tif (\\r\\n\\t\\t(r < 0 || r >= row_num || c < 0 || c >= col_num)  // if out of bounds\\r\\n\\t\\t|| grid[r][c] != color  // wrong color\\r\\n\\t\\t|| visited[r][c]  // already visited this square\\r\\n\\t) return;\\r\\n\\r\\n\\tvisited[r][c] = true; // mark current square as visited\\r\\n\\tcurr_size++; // increment the size for each square we visit\\r\\n\\r\\n\\t// recursively call flood fill for neighboring squares\\r\\n\\tfloodfill(r, c + 1, color);\\r\\n\\tfloodfill(r, c - 1, color);\\r\\n\\tfloodfill(r - 1, c, color);\\r\\n\\tfloodfill(r + 1, c, color);\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\t/*\\r\\n\\t * input code and other problem-specific stuff here\\r\\n\\t */\\r\\n\\tfor (int i = 0; i < row_num; i++) {\\r\\n\\t\\tfor (int j = 0; j < col_num; j++) {\\r\\n\\t\\t\\tif (!visited[i][j]) {\\r\\n\\t\\t\\t\\tcurr_size = 0;\\r\\n\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t * start a flood fill if the square hasn't already been visited,\\r\\n\\t\\t\\t\\t * and then store or otherwise use the component size\\r\\n\\t\\t\\t\\t * for whatever it's needed for\\r\\n\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\tfloodfill(i, j, grid[i][j]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"public class Floodfill {\\r\\n\\tprivate static int[][] grid;  // the grid itself\\r\\n\\tprivate static int rowNum;\\r\\n\\tprivate static int colNum;  // grid dimensions, rows and columns\\r\\n\\tprivate static boolean[][] visited;  // keeps track of which nodes have been visited\\r\\n\\tprivate static int currSize = 0;  // reset to 0 each time we start a new component\\r\\n\\r\\n\\tpublic static void main(String[] args) {\\r\\n\\t\\t/*\\r\\n\\t\\t * input code and other problem-specific stuff here\\r\\n\\t\\t */\\r\\n\\t\\tfor (int r = 0; r < rowNum; r++){\\r\\n\\t\\t\\tfor (int c = 0; c < colNum; c++){\\r\\n\\t\\t\\t\\tif(!visited[r][c]){\\r\\n\\t\\t\\t\\t\\tcurrSize = 0;\\r\\n\\t\\t\\t\\t\\t/*\\r\\n\\t\\t\\t\\t\\t * start a flood fill if the square hasn't already been visited,\\r\\n\\t\\t\\t\\t\\t * and then store or otherwise use the component size\\r\\n\\t\\t\\t\\t\\t * for whatever it's needed for\\r\\n\\t\\t\\t\\t\\t */\\r\\n\\t\\t\\t\\t\\tfloodfill(r, c, grid[r][c]);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tprivate static void floodfill(int r, int c, int color) {\\r\\n\\t\\tif (\\r\\n\\t\\t\\t(r < 0 || r >= rowNum || c < 0 || c >= colNum)  // if out of bounds\\r\\n\\t\\t\\t|| grid[r][c] != color  // wrong color\\r\\n\\t\\t\\t|| visited[r][c]  // already visited this square\\r\\n\\t\\t) return;\\r\\n\\r\\n\\t\\tvisited[r][c] = true; // mark current square as visited\\r\\n\\t\\tcurrSize++; // increment the size for each square we visit\\r\\n\\r\\n\\t\\t// recursively call flood fill for neighboring squares\\r\\n\\t\\tfloodfill(r, c + 1, color);\\r\\n\\t\\tfloodfill(r, c - 1, color);\\r\\n\\t\\tfloodfill(r - 1, c, color);\\r\\n\\t\\tfloodfill(r + 1, c, color);\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"import sys\\r\\n\\r\\nMAX_N = 100\\r\\nsys.setrecursionlimit(2 ** 30)  # pretty much disable the recurion limit\\r\\n\\r\\nrow_num = MAX_N\\r\\ncol_num = MAX_N\\r\\ngrid = [[0 for _ in range(col_num)] for _ in range(row_num)]\\r\\nvisited = [[False for _ in range(col_num)] for _ in range(row_num)]\\r\\ncurr_size = 0\\r\\n\\r\\n\\r\\ndef floodfill(r: int, c: int, color: int):\\r\\n\\tglobal curr_size\\r\\n\\r\\n\\tif (\\r\\n\\t\\t(r < 0 or r >= row_num or c < 0 or c >= col_num)  # if out of bounds\\r\\n\\t\\tor grid[r][c] != color  # wrong color\\r\\n\\t\\tor visited[r][c]  # already visited this square\\r\\n\\t): return\\r\\n\\r\\n\\tvisited[r][c] = True  # mark current square as visited\\r\\n\\tcurr_size += 1  # increment the size for each square we visit\\r\\n\\r\\n\\t# recursively call flood fill for neighboring squares\\r\\n\\tfloodfill(r, c + 1, color)\\r\\n\\tfloodfill(r, c - 1, color)\\r\\n\\tfloodfill(r - 1, c, color)\\r\\n\\tfloodfill(r + 1, c, color)\\r\\n\\r\\n\\r\\n\\\"\\\"\\\"\\r\\ninput code and other problem-specific stuff here\\r\\n\\\"\\\"\\\"\\r\\n\\r\\nfor r in range(row_num):\\r\\n\\tfor c in range(col_num):\\r\\n\\t\\tif not visited[r][c]:\\r\\n\\t\\t\\tcurr_size = 0\\r\\n\\t\\t\\t\\\"\\\"\\\"\\r\\n\\t\\t\\tstart a flood fill if the square hasn't already been visited,\\r\\n\\t\\t\\tand then store or otherwise use the component size\\r\\n\\t\\t\\tfor whatever it's needed for\\r\\n\\t\\t\\t\\\"\\\"\\\"\\r\\n\\t\\t\\tfloodfill(r, c, grid[r][c])\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"example---counting-rooms\",\n      children: [_jsx(_components.a, {\n        href: \"#example---counting-rooms\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Example - Counting Rooms\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sample\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation-1\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(Warning, {\n      children: [_jsx(_components.p, {\n        children: \"Recursive implementations of flood fill sometimes lead to\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.em, {\n            children: \"Stack overflow\"\n          }), \" if you didn't include the appropriate compiler options for\\r\\n\", _jsx(_components.a, {\n            href: \"/general/cpp-command#adjusting-stack-size-mac\",\n            children: \"adjusting the stack size\"\n          })]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.em, {\n            children: \"Memory limit exceeded\"\n          }), \" if you run the recursive implementation on a \", _jsx(_components.em, {\n            children: \"really\"\n          }), \"\\r\\nbig grid (i.e., running the above code on a \", _jsx(MATHSPAN, {\n            className: \"math math-inline\",\n            latex: \"4000\\\\times 4000\",\n            children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mn>4000</mn><mo>×</mo><mn>4000</mn></mrow><annotation encoding=\\\"application/x-tex\\\">4000\\\\times 4000</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7278em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord\\\">4000</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">×</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">4000</span></span></span></span>\"\n          }), \" grid may exceed\\r\\n256 MB)\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"Non-recursive implementations generally use less memory than recursive ones.\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A non-recursive implementation of flood fill adds adjacent nodes to a stack or queue, similar to \", _jsx(_components.a, {\n        href: \"/gold/bfs\",\n        children: \"BFS\"\n      }), \", and is usually implemented as follows:\"]\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <iostream>\\r\\n#include <string>\\r\\n#include <stack>\\r\\n\\r\\nusing namespace std;\\r\\n\\r\\nconst int MAX_N = 2500;\\r\\nconst int R_CHANGE[]{0, 1, 0, -1};\\r\\nconst int C_CHANGE[]{1, 0, -1, 0};\\r\\n\\r\\nint row_num;\\r\\nint col_num;\\r\\nstring building[MAX_N];\\r\\nbool visited[MAX_N][MAX_N];\\r\\n\\r\\nvoid floodfill(int r, int c) {\\r\\n\\t// Note: you can also use a queue and pop from the front for a BFS-based approach\\r\\n\\tstack<pair<int, int>> frontier;\\r\\n\\tfrontier.push({r, c});\\r\\n\\twhile(!frontier.empty()) {\\r\\n\\t\\tr = frontier.top().first;\\r\\n\\t\\tc = frontier.top().second;\\r\\n\\t\\tfrontier.pop();\\r\\n\\r\\n\\t\\tif (r < 0 || r >= row_num || c < 0 || c >= col_num\\r\\n\\t\\t\\t\\t|| building[r][c] == '#' || visited[r][c])\\r\\n\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\tvisited[r][c] = true;\\r\\n\\t\\tfor (int i = 0; i < 4; i++){\\r\\n\\t\\t\\tfrontier.push({r + R_CHANGE[i], c + C_CHANGE[i]});\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\nint main() {\\r\\n\\tcin >> row_num >> col_num;\\r\\n\\tfor (int i = 0; i < row_num; i++) {\\r\\n\\t\\tcin >> building[i];\\r\\n\\t}\\r\\n\\r\\n\\tint room_num = 0;\\r\\n\\tfor (int i = 0; i < row_num; i++) {\\r\\n\\t\\tfor (int j = 0; j < col_num; j++) {\\r\\n\\t\\t\\tif (building[i][j] == '.' && !visited[i][j]) {\\r\\n\\t\\t\\t\\tfloodfill(i, j);\\r\\n\\t\\t\\t\\troom_num++;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tcout << room_num << endl;\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(JavaSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class RoomCount {\\r\\n\\tpublic static final int R_CHANGE[] = {0, 1, 0, -1};\\r\\n\\tpublic static final int C_CHANGE[] = {1, 0, -1, 0};\\r\\n\\r\\n\\tprivate static boolean[][] visited;\\r\\n\\tprivate static char[][] building;\\r\\n\\tprivate static int rowNum;\\r\\n\\tprivate static int colNum;\\r\\n\\r\\n\\tpublic static void floodfill(int row, int col) {\\r\\n\\t\\t// Note: you can also use a queue and pop from the front for a BFS-based approach\\r\\n\\t\\tStack<Pos> frontier = new Stack<>();\\r\\n\\t\\tfrontier.push(new Pos(row, col));\\r\\n\\t\\twhile(!frontier.isEmpty()){\\r\\n\\t\\t\\tPos curr = frontier.pop();\\r\\n\\t\\t\\trow = curr.row;\\r\\n\\t\\t\\tcol = curr.col;\\r\\n\\r\\n\\t\\t\\tif (row < 0 || row >= rowNum || col < 0 || col >= colNum\\r\\n\\t\\t\\t\\t\\t|| building[row][col] == '#' || visited[row][col])\\r\\n\\t\\t\\t\\tcontinue;\\r\\n\\r\\n\\t\\t\\tvisited[row][col] = true;\\r\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\r\\n\\t\\t\\t\\tfrontier.add(new Pos(row + R_CHANGE[i], col + C_CHANGE[i]));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tpublic static void main(String[] args) throws IOException {\\r\\n\\t\\tBufferedReader read = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tStringTokenizer dims = new StringTokenizer(read.readLine());\\r\\n\\t\\trowNum = Integer.parseInt(dims.nextToken());\\r\\n\\t\\tcolNum = Integer.parseInt(dims.nextToken());\\r\\n\\r\\n\\t\\tbuilding = new char[rowNum][colNum];\\r\\n\\t\\tfor (int r = 0; r < rowNum; r++){\\r\\n\\t\\t\\tString row = read.readLine();\\r\\n\\t\\t\\tfor (int j = 0; j < colNum; j++){\\r\\n\\t\\t\\t\\tbuilding[r][j] = row.charAt(j);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvisited = new boolean[rowNum][colNum];\\r\\n\\t\\tint roomNum = 0;\\r\\n\\t\\tfor (int i = 0; i < rowNum; i++){\\r\\n\\t\\t\\tfor (int j = 0; j < colNum; j++){\\r\\n\\t\\t\\t\\tif (building[i][j] == '.' && !visited[i][j]) {\\r\\n\\t\\t\\t\\t\\tfloodfill(i, j);\\r\\n\\t\\t\\t\\t\\troomNum++;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tSystem.out.println(roomNum);\\r\\n\\t}\\r\\n}\\r\\n\\r\\nclass Pos {\\r\\n\\tint row;\\r\\n\\tint col;\\r\\n\\tpublic Pos(int row, int col) {\\r\\n\\t\\tthis.row = row;\\r\\n\\t\\tthis.col = col;\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })\n      }), _jsx(PySection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-py\",\n            children: \"row_num, col_num = [int(i) for i in input().split()]\\r\\ngrid = [input() for _ in range(row_num)]\\r\\nvisited = [[False for _ in range(col_num)] for _ in range(row_num)]\\r\\n\\r\\n\\r\\ndef floodfill(r: int, c: int):\\r\\n\\tglobal visited\\r\\n\\r\\n\\t\\\"\\\"\\\"\\r\\n\\tNote: you can also use queue and pop from the\\r\\n\\tfront (as opposed to popping from the back) for a BFS-based approach\\r\\n\\t\\\"\\\"\\\"\\r\\n\\tfrontier = [(r, c)]\\r\\n\\twhile frontier:\\r\\n\\t\\tr, c = frontier.pop()\\r\\n\\t\\tif (r < 0 or r >= row_num or c < 0 or c >= col_num\\r\\n\\t\\t\\t\\tor visited[r][c] or grid[r][c] == '#'):\\r\\n\\t\\t\\tcontinue\\r\\n\\r\\n\\t\\tvisited[r][c] = True\\r\\n\\t\\tfrontier.append((r - 1, c))\\r\\n\\t\\tfrontier.append((r, c - 1))\\r\\n\\t\\tfrontier.append((r + 1, c))\\r\\n\\t\\tfrontier.append((r, c + 1))\\r\\n\\r\\n\\r\\nroom_num = 0\\r\\nfor row in range(row_num):\\r\\n\\tfor col in range(col_num):\\r\\n\\t\\tif not visited[row][col] and grid[row][col] == '.':\\r\\n\\t\\t\\tfloodfill(row, col)\\r\\n\\t\\t\\troom_num += 1\\r\\nprint(room_num)\\n\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"general\",\n      hideSuggestProblemButton: true\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  redirects,\n  title,\n  author,\n  contributors,\n  prerequisites,\n  description,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"Flood Fill","author":"Darren Yao","contributors":"Kevin Sheng","id":"flood-fill","prerequisites":["dfs"],"description":"Finding connected components in a graph represented by a grid.","frequency":3},"parent":{"name":"Flood_Fill","relativePath":"3_Silver/Flood_Fill.mdx"},"fields":{"division":"silver"},"toc":{"cpp":[{"depth":2,"value":"Resources","slug":"resources"},{"depth":2,"value":"Introduction","slug":"introduction"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Example - Counting Rooms","slug":"example---counting-rooms"},{"depth":3,"value":"Implementation","slug":"implementation-1"},{"depth":2,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Resources","slug":"resources"},{"depth":2,"value":"Introduction","slug":"introduction"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Example - Counting Rooms","slug":"example---counting-rooms"},{"depth":3,"value":"Implementation","slug":"implementation-1"},{"depth":2,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Resources","slug":"resources"},{"depth":2,"value":"Introduction","slug":"introduction"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Example - Counting Rooms","slug":"example---counting-rooms"},{"depth":3,"value":"Implementation","slug":"implementation-1"},{"depth":2,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[{"listId":"sample","problems":[{"uniqueId":"cses-1192","name":"Counting Rooms","url":"https://cses.fi/problemset/task/1192","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/silver/flood-fill#problem-cses-1192","sketch":null}}]},{"listId":"general","problems":[{"uniqueId":"usaco-895","name":"Icy Perimeter","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=895","source":"Silver","difficulty":"Easy","isStarred":true,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-1365D","name":"Solve The Maze","url":"https://codeforces.com/contest/1365/problem/D","source":"CF","difficulty":"Easy","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-380","name":"Cross Country Skiing","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=380","source":"Old Silver","difficulty":"Easy","isStarred":true,"tags":["Flood Fill","Binary Search"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-570","name":"Switching on the Lights","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=570","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-596","name":"Build Gates","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=596","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-620","name":"Milk Pails","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=620","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-740","name":"Where's Bessie?","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=740","source":"Silver","difficulty":"Normal","isStarred":true,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-716","name":"Why Did the Cow Cross the Road III","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=716","source":"Silver","difficulty":"Normal","isStarred":true,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-860","name":"Mooyo Mooyo","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=860","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1110","name":"Comfortable Cows","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1110","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_prob1_silver_feb21.html","sketch":null}},{"uniqueId":"usaco-811","name":"Snow Boots","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=811","source":"Silver","difficulty":"Hard","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1134","name":"Maze Tac Toe","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1134","source":"Silver","difficulty":"Hard","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_prob1_silver_open21.html","sketch":null}},{"uniqueId":"usaco-836","name":"Multiplayer Moo","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=836","source":"Silver","difficulty":"Hard","isStarred":false,"tags":["Flood Fill"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_multimoo_silver_open18.html","sketch":null}}]}]}},"pageContext":{"id":"flood-fill"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}