{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/silver/dfs",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*<Resource source=\"IUSACO\" title=\"10.4 - DFS\">\ncode + example\n</Resource>\n<Resource source=\"PAPS\" title=\"12.2 - DFS\">\npseudocode + example + code\n</Resource>\n<Resource\nsource=\"CP2\"\ntitle=\"4.2.1, 4.2.3 - DFS, Finding Connected Components\"\n/>*/\n/*\n\n<Resource source=\"CPC\" title=\"7 - Graphs 1\" url=\"07_graphs_1\">fast-paced</Resource>\n<Resource source=\"cp-algo\" title=\"Depth First Search\" url=\"graph/depth-first-search.html\">hard to parse for a beginner</Resource>\n<Resource source=\"TC\" title=\"Graphs Section 2\" url=\"introduction-to-graphs-and-their-data-structures-section-2\" />\n\n*/\n/*You don't want to add an edge between two nodes that are already connected. If you have N connected components (some of the resources should go over what those are), then adding an edge reduces it to N - 1 connected components. Everything is connected when there's 1 connected component. So the answer is (# connected components - 1).*/\n/*Iterate through each node. If it has not been visited, visit it and all other nodes in its component. The number of times we perform the visiting operation is the number of connected components.*/\n/*Tested on CSES*/\n/*\n<LanguageSection>\n\n<CPPSection>\n\n</CPPSection>\n\n<JavaSection>\n\n</JavaSection>\n\n<CPPSection>\n\n## Increased recursion limit\n\nRefer to the module on [increasing stack size](/general/cpp-command#adjusting-stack-size-mac).\n\n</CPPSection>\n\n<JavaSection>\n\n## DFS With Stack\n\nA danger in using DFS when dealing with large bounds is the possibility of a common runtime error, **StackOverFlow Error** in Java. This commonly occurs when $N > 10^5$ due to the limited memory of the built-in \"stack\" of recursive calls. To resolve this, we can implement our solution iteravely by making our own stack instead of recursively calling a function. You can imagine adding to this stack being the equivalent of calling the recursive function and popping from this stack being the same as executing the function. (**Note**: StackOverFlow Error is more common in [floodfill](/silver/ff) problems due to the grid-like nature leading to high depths in recursion calls.)\n\nSolution using iterative DFS:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\npublic static ArrayList<Integer> adj[];\npublic static ArrayList<Integer> rep = new ArrayList<Integer>();\npublic static boolean visited[];\npublic static void main(String[] args) throws IOException\n{\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\nPrintWriter out = new PrintWriter(System.out);\nStringTokenizer st = new StringTokenizer(br.readLine());\nint N = Integer.parseInt(st.nextToken());\nint M = Integer.parseInt(st.nextToken());\nadj = new ArrayList[N+1];\nvisited = new boolean[N+1];\nfor (int i = 0; i <= N; i++) adj[i] = new ArrayList<Integer>();\nfor (int i = 0; i < M; i++){\nst = new StringTokenizer(br.readLine());\nint u = Integer.parseInt(st.nextToken());\nint v = Integer.parseInt(st.nextToken());\nadj[u].add(v); adj[v].add(u);\n}\nint ans = count_components();\nout.println(ans-1);\nfor (int i = 1; i < ans; i++){\nout.println(rep.get(i-1) + \" \" + rep.get(i));\n}\nout.close();\n}\n\npublic static void dfs(int node)\n{\nStack<Integer> dfs_stack = new Stack<Integer>();\ndfs_stack.push(node);\nwhile(!dfs_stack.isEmpty()){\nint cur = dfs_stack.pop();\nvisited[cur] = true;\nfor (int u: adj[cur])\nif(!visited[u])\ndfs_stack.push(u);\n}\n}\npublic static int count_components()\n{\nint count = 0;\nfor (int i = 1; i <= adj.length-1; i++){\nif(!visited[i]){\ncount++;\nrep.add(i);\ndfs(i);\n}\n}\nreturn count;\n}\n}\n```\n\n</JavaSection>\n\n<PySection>\n\n</PySection>\n\n</LanguageSection>\n*/\n/*all of these use BFS\n\n<Resource source=\"IUSACO\" title=\"10.7 - Bipartite Graphs\">\nUses BFS, but DFS accomplishes the same task.\n</Resource>\n<Resource\nsource=\"cp-algo\"\ntitle=\"Bipartite Check\"\nurl=\"graph/bipartite-check.html\"\n>\nUses BFS, but DFS accomplishes the same task.\n</Resource>\n<Resource source=\"CP2\" title=\"4.2.6 - Bipartite Check\"/>\n*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"dfs\", redirects = [\"/silver/bipartite\"], title = \"Depth First Search (DFS)\", author = \"Siyong Huang, Benjamin Qi\", contributors = \"Andrew Wang, Jason Chen\", prerequisites = [\"intro-graphs\", \"complete-rec\"], description = \"Recursively traversing a graph.\", frequency = 4;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    blockquote: \"blockquote\",\n    h2: \"h2\",\n    a: \"a\",\n    strong: \"strong\",\n    em: \"em\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    Spoiler: _missingComponent(\"Spoiler\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    JavaSection: _missingComponent(\"JavaSection\"),\n    PySection: _missingComponent(\"PySection\"),\n    Optional: _missingComponent(\"Optional\"),\n    Info: _missingComponent(\"Info\"),\n    Problems: _missingComponent(\"Problems\"),\n    Warning: _missingComponent(\"Warning\")\n  }, _props.components), {Resources, Resource, HeaderLink, FocusProblem, Spoiler, MATHSPAN, LanguageSection, CPPSection, JavaSection, PySection, Optional, Info, Problems, Warning, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [\"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CSA\",\n        title: \"Depth First Search\",\n        url: \"depth_first_search\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"up to but not including \\\"More about DFS\\\"\"\n        })\n      }), _jsx(Resource, {\n        source: \"CPH\",\n        title: \"12.1 - DFS\",\n        children: _jsx(_components.p, {\n          children: \"example diagram + code\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"From the second resource:\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Depth-first search (DFS) is a straightforward graph traversal technique. The\\r\\nalgorithm begins at a starting node, and proceeds to all other nodes that are\\r\\nreachable from the starting node using the edges of the graph.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Depth-first search always follows a single path in the graph as long as it\\r\\nfinds new nodes. After this, it returns to previous nodes and begins to\\r\\nexplore other parts of the graph. The algorithm keeps track of visited nodes,\\r\\nso that it processes each node only once.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"application---connected-components\",\n      children: [_jsx(_components.a, {\n        href: \"#application---connected-components\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Application - Connected Components\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"sample\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"A \", _jsx(_components.strong, {\n        children: \"connected component\"\n      }), \" is a maximal set of connected nodes in an undirected\\r\\ngraph. In other words, two nodes are in the same connected component \", _jsx(_components.em, {\n        children: \"if and\\r\\nonly if\"\n      }), \" they can reach each other via edges in the graph.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the above focus problem, the goal is to add the minimum possible number of\\r\\nedges such that the entire graph forms a single connected component.\"\n    }), \"\\n\", \"\\n\", _jsxs(_components.h3, {\n      id: \"solution---building-roads\",\n      children: [_jsx(_components.a, {\n        href: \"#solution---building-roads\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution - Building Roads\"]\n    }), \"\\n\", _jsxs(Spoiler, {\n      title: \"Solution\",\n      children: [_jsxs(_components.p, {\n        children: [\"Note that each edge decreases the number of connected components by either zero\\r\\nor one. So you must add at least \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"C-1\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>C</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">C-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n        }), \" edges, where \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"C\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\\\"application/x-tex\\\">C</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span></span></span></span>\"\n        }), \" is the number of\\r\\nconnected components in the input graph.\"]\n      }), _jsxs(_components.p, {\n        children: [\"There are many valid ways to pick \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"C-1\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>C</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\\\"application/x-tex\\\">C-1</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7667em;vertical-align:-0.0833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span><span class=\\\"mbin\\\">−</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2222em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"></span><span class=\\\"mord\\\">1</span></span></span></span>\"\n        }), \" new roads to build. The code below picks\\r\\na single representative from each of the \", _jsx(MATHSPAN, {\n          className: \"math math-inline\",\n          latex: \"C\",\n          children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\\\"application/x-tex\\\">C</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.6833em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.07153em;\\\">C</span></span></span></span>\"\n        }), \" components and links them together\\r\\nin a line.\"]\n      }), _jsxs(LanguageSection, {\n        children: [_jsx(CPPSection, {\n          children: _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-cpp\",\n              children: \"#include <cstdio>\\r\\n#include <vector>\\r\\n\\r\\nconst int MN = 1e5+10;\\r\\n\\r\\nint N, M, ans, rep[MN];\\r\\nstd::vector<int> adj_list[MN];\\r\\nbool visited[MN];\\r\\n\\r\\nvoid dfs(int node)\\r\\n{\\r\\n\\tvisited[node] = true;\\r\\n\\tfor(int u:adj_list[node])\\r\\n\\t\\tif(!visited[u])\\r\\n\\t\\t\\tdfs(u);\\r\\n}\\r\\nint count_components()\\r\\n{\\r\\n\\tint count=0;\\r\\n\\tfor(int i=1;i<=N;++i)\\r\\n\\t\\tif(!visited[i])\\r\\n\\t\\t{\\r\\n\\t\\t\\trep[count++]=i;\\r\\n\\t\\t\\tdfs(i);\\r\\n\\t\\t}\\r\\n\\treturn count;\\r\\n}\\r\\n\\r\\nint main()\\r\\n{\\r\\n\\tscanf(\\\"%d%d\\\", &N, &M);\\r\\n\\tfor(int i=0,u,v;i<M;++i)\\r\\n\\t\\tscanf(\\\"%d%d\\\", &u, &v), adj_list[u].push_back(v), adj_list[v].push_back(u);\\r\\n\\tans = count_components();\\r\\n\\tprintf(\\\"%d\\\\n\\\", ans-1);\\r\\n\\tfor(int i=1;i<ans;++i)\\r\\n\\t\\tprintf(\\\"%d %d\\\\n\\\", rep[i-1], rep[i]);\\r\\n\\treturn 0;\\r\\n}\\n\"\n            })\n          })\n        }), _jsx(JavaSection, {\n          children: _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-java\",\n              children: \"import java.util.*;\\r\\nimport java.io.*;\\r\\n\\r\\npublic class Main{\\r\\n\\tpublic static ArrayList<Integer> adj[];\\r\\n\\tpublic static ArrayList<Integer> rep = new ArrayList<Integer>();\\r\\n\\tpublic static boolean visited[];\\r\\n\\tpublic static void main(String[] args) throws IOException\\r\\n\\t{\\r\\n\\t\\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\r\\n\\t\\tPrintWriter out = new PrintWriter(System.out);\\r\\n\\t\\tStringTokenizer st = new StringTokenizer(br.readLine());\\r\\n\\t\\tint N = Integer.parseInt(st.nextToken());\\r\\n\\t\\tint M = Integer.parseInt(st.nextToken());\\r\\n\\t\\tadj = new ArrayList[N+1];\\r\\n\\t\\tvisited = new boolean[N+1];\\r\\n\\t\\tfor (int i = 0; i <= N; i++) adj[i] = new ArrayList<Integer>();\\r\\n\\t\\tfor (int i = 0; i < M; i++){\\r\\n\\t\\t\\tst = new StringTokenizer(br.readLine());\\r\\n\\t\\t\\tint u = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tint v = Integer.parseInt(st.nextToken());\\r\\n\\t\\t\\tadj[u].add(v); adj[v].add(u);\\r\\n\\t\\t}\\r\\n\\t\\tint ans = count_components();\\r\\n\\t\\tout.println(ans-1);\\r\\n\\t\\tfor (int i = 1; i < ans; i++){\\r\\n\\t\\t\\tout.println(rep.get(i-1) + \\\" \\\" + rep.get(i));\\r\\n\\t\\t}\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n\\r\\n\\tpublic static void dfs(int node)\\r\\n\\t{\\r\\n\\t\\tvisited[node] = true;\\r\\n\\t\\tfor (int u: adj[node])\\r\\n\\t\\t\\tif(!visited[u])\\r\\n\\t\\t\\t\\tdfs(u);\\r\\n\\t}\\r\\n\\tpublic static int count_components()\\r\\n\\t{\\r\\n\\t\\tint count = 0;\\r\\n\\t\\tfor (int i = 1; i <= adj.length-1; i++){\\r\\n\\t\\t\\tif(!visited[i]){\\r\\n\\t\\t\\t\\tcount++;\\r\\n\\t\\t\\t\\trep.add(i);\\r\\n\\t\\t\\t\\tdfs(i);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\treturn count;\\r\\n\\t}\\r\\n}\\n\"\n            })\n          })\n        }), _jsxs(PySection, {\n          children: [_jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-py\",\n              children: \"def solve(n, adj):\\r\\n\\tunvisited = set(range(1, n+1))\\r\\n\\tstarts = set()\\r\\n\\r\\n\\tdef dfs(current):\\r\\n\\t\\tfor next in adj[current]:\\r\\n\\t\\t\\tif next in unvisited:\\r\\n\\t\\t\\t\\tunvisited.remove(next)\\r\\n\\t\\t\\t\\tdfs(next)\\r\\n\\r\\n\\twhile unvisited:\\r\\n\\t\\tstart = unvisited.pop()\\r\\n\\t\\tstarts.add(start)\\r\\n\\t\\tdfs(start)\\r\\n\\r\\n\\tprint(len(starts) - 1)\\r\\n\\troot = starts.pop()\\r\\n\\tfor other in starts:\\r\\n\\t\\tprint(root, other)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n\\tn, m = map(int, input().split())\\r\\n\\tadj = [set() for _ in range(n+1)]\\r\\n\\tfor _ in range(m):\\r\\n\\t\\tu, v = map(int, input().split())\\r\\n\\t\\tadj[u].add(v)\\r\\n\\t\\tadj[v].add(u)\\r\\n\\tsolve(n, adj)\\n\"\n            })\n          }), _jsxs(_components.p, {\n            children: [\"Unfortunately, a danger in using DFS when dealing with large bounds is the\\r\\npossibility of a \", _jsx(_components.strong, {\n              children: \"RecursionError\"\n            }), \". This commonly occurs for \", _jsx(MATHSPAN, {\n              className: \"math math-inline\",\n              latex: \"N>10^3\",\n              children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi>N</mi><mo>&gt;</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding=\\\"application/x-tex\\\">N&gt;10^3</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.7224em;vertical-align:-0.0391em;\\\"></span><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span><span class=\\\"mrel\\\">&gt;</span><span class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"></span></span><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:0.8141em;\\\"></span><span class=\\\"mord\\\">1</span><span class=\\\"mord\\\"><span class=\\\"mord\\\">0</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">3</span></span></span></span></span></span></span></span></span></span></span>\"\n            }), \" since the\\r\\nrecursion limit in Python is set to\\r\\n\", _jsx(_components.a, {\n              href: \"https://stackoverflow.com/questions/3323001/what-is-the-maximum-recursion-depth-in-python-and-how-to-increase-it/33008014\",\n              target: \"_blank\",\n              rel: \"nofollow noopener noreferrer\",\n              children: \"1000\"\n            }), \"\\r\\nby default. So if you submit the above code, you'll get the following:\"]\n          }), _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              children: \"Traceback (most recent call last):\\r\\n  File \\\"input/code.py\\\", line 28, in <module>\\r\\n    solve(n, adj)\\r\\n  File \\\"input/code.py\\\", line 14, in solve\\r\\n    dfs(start, start)\\r\\n  File \\\"input/code.py\\\", line 9, in dfs\\r\\n    dfs(start, next)\\r\\n  File \\\"input/code.py\\\", line 9, in dfs\\r\\n    dfs(start, next)\\r\\n  File \\\"input/code.py\\\", line 9, in dfs\\r\\n    dfs(start, next)\\r\\n  [Previous line repeated 994 more times]\\r\\n  File \\\"input/code.py\\\", line 7, in dfs\\r\\n    if next in unvisited:\\r\\nRecursionError: maximum recursion depth exceeded in comparison\\n\"\n            })\n          }), _jsx(_components.p, {\n            children: \"We can fix this by increasing the recursion limit:\"\n          }), _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-py\",\n              children: \"import sys\\r\\nsys.setrecursionlimit(1000000)\\n\"\n            })\n          }), _jsx(_components.p, {\n            children: \"although we still get TLE on two test cases.\"\n          }), _jsxs(_components.p, {\n            children: [\"To resolve this, we can implement a non-recursive solution (which turns out to\\r\\nbe slightly faster). You can imagine adding to \", _jsx(_components.code, {\n              children: \"to_visit\"\n            }), \" as calling the\\r\\nfunction recursively and popping from \", _jsx(_components.code, {\n              children: \"to_visit\"\n            }), \" as starting the execution of\\r\\nthe recursive function (though they are not exactly equivalent in the strictest\\r\\nsense).\"]\n          }), _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-py\",\n              children: \"def solve(n, adj):\\r\\n\\tunvisited = set(range(1, n+1))\\r\\n\\tstarts = set()\\r\\n\\r\\n\\tdef dfs(start):\\r\\n\\t\\tto_visit = [start]\\r\\n\\t\\twhile to_visit:\\r\\n\\t\\t\\tcurrent = to_visit.pop()\\r\\n\\t\\t\\tfor next in adj[current]:\\r\\n\\t\\t\\t\\tif next in unvisited:\\r\\n\\t\\t\\t\\t\\tunvisited.remove(next)\\r\\n\\t\\t\\t\\t\\tto_visit.append(next)\\r\\n\\r\\n\\twhile unvisited:\\r\\n\\t\\tstart = unvisited.pop()\\r\\n\\t\\tstarts.add(start)\\r\\n\\t\\tdfs(start)\\r\\n\\r\\n\\tprint(len(starts) - 1)\\r\\n\\troot = starts.pop()\\r\\n\\tfor other in starts:\\r\\n\\t\\tprint(root, other)\\r\\n\\r\\nif __name__ == '__main__':\\r\\n\\tn, m = map(int, input().split())\\r\\n\\tadj = [set() for _ in range(n+1)]\\r\\n\\tfor _ in range(m):\\r\\n\\t\\tu, v = map(int, input().split())\\r\\n\\t\\tadj[u].add(v)\\r\\n\\t\\tadj[v].add(u)\\r\\n\\tsolve(n, adj)\\n\"\n            })\n          }), _jsxs(_components.p, {\n            children: [\"Recursion errors also come up frequently in \", _jsx(_components.a, {\n              href: \"/silver/ff\",\n              children: \"flood fill\"\n            }), \" problems.\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", \"\\n\", _jsx(Optional, {\n      title: \"Adjacency List Without an Array of Vectors\",\n      children: _jsxs(_components.p, {\n        children: [\"See \", _jsx(_components.a, {\n          href: \"https://codeforces.com/blog/entry/67883\",\n          target: \"_blank\",\n          rel: \"nofollow noopener noreferrer\",\n          children: \"here.\"\n        })]\n      })\n    }), \"\\n\", _jsx(Info, {\n      title: \"Pro Tip\",\n      children: _jsxs(_components.p, {\n        children: [\"Some problems that can be solved with DFS, such as \", _jsx(_components.a, {\n          href: \"http://www.usaco.org/index.php?page=viewproblem2&cpid=1110\",\n          target: \"_blank\",\n          rel: \"nofollow noopener noreferrer\",\n          children: \"Comfortable Cows\"\n        }), \", may be more easily solved with a queue (described in the \", _jsx(_components.a, {\n          href: \"/gold/bfs\",\n          children: \"BFS\"\n        }), \" module).\"]\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"general\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"application---graph-two-coloring\",\n      children: [_jsx(_components.a, {\n        href: \"#application---graph-two-coloring\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Application - Graph Two-Coloring\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"bipsample\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Graph two-coloring\"\n      }), \" refers to assigning a boolean value to each node of the\\r\\ngraph, dictated by the edge configuration. The most common example of a\\r\\ntwo-colored graph is a \", _jsx(_components.strong, {\n        children: \"bipartite graph\"\n      }), \", in which each edge connects two\\r\\nnodes of opposite colors.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In the above focus problem, the goal is to assign each node (friend) of the\\r\\ngraph to one of two colors (teams), subject to the constraint that edges\\r\\n(friendships) connect two nodes of opposite colors. In other words, we need to\\r\\ncheck whether the input is a bipartite graph and output a valid coloring if it\\r\\nis.\"\n    }), \"\\n\", \"\\n\", _jsxs(_components.h3, {\n      id: \"solution---building-teams\",\n      children: [_jsx(_components.a, {\n        href: \"#solution---building-teams\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Solution - Building Teams\"]\n    }), \"\\n\", _jsx(Resources, {\n      children: _jsx(Resource, {\n        source: \"CPH\",\n        title: \"12.3 - Bipartiteness check\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"Brief solution sketch with diagrams.\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The idea is that we can arbitrarily label a node and then run DFS. Every time we\\r\\nvisit a new (unvisited) node, we set its color based on the edge rule. When we\\r\\nvisit a previously visited node, check to see whether its color matches the edge\\r\\nrule.\"\n    }), \"\\n\", _jsxs(LanguageSection, {\n      children: [_jsx(CPPSection, {\n        children: _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-cpp\",\n            children: \"#include <cstdio>\\r\\n#include <vector>\\r\\n\\r\\nconst int MN = 1e5+10;\\r\\n\\r\\nint N, M;\\r\\nbool bad, vis[MN], group[MN];\\r\\nstd::vector<int> a[MN];\\r\\n\\r\\nvoid dfs(int n=1, bool g=0)\\r\\n{\\r\\n\\tvis[n]=1;\\r\\n\\tgroup[n]=g;\\r\\n\\tfor(int u:a[n])\\r\\n\\t\\tif(vis[u])\\r\\n\\t\\t{\\r\\n\\t\\t\\tif(group[u]==g)\\r\\n\\t\\t\\t\\tbad=1;\\r\\n\\t\\t}\\r\\n\\t\\telse\\r\\n\\t\\t\\tdfs(u, !g);\\r\\n}\\r\\nint main()\\r\\n{\\r\\n\\tscanf(\\\"%d%d\\\", &N, &M);\\r\\n\\tfor(int i=0,u,v;i<M;++i)\\r\\n\\t\\tscanf(\\\"%d%d\\\", &u, &v), a[u].push_back(v), a[v].push_back(u);\\r\\n\\tfor(int i=1;!bad && i<=N;++i)\\r\\n\\t\\tif(!vis[i])\\r\\n\\t\\t\\tdfs(i);\\r\\n\\tif(bad)\\r\\n\\t\\tprintf(\\\"IMPOSSIBLE\\\\n\\\");\\r\\n\\telse\\r\\n\\t\\tfor(int i=1;i<=N;++i) printf(\\\"%d%c\\\", group[i]+1, \\\" \\\\n\\\"[i==N]);\\r\\n\\treturn 0;\\r\\n}\\n\"\n          })\n        })\n      }), _jsxs(JavaSection, {\n        children: [_jsx(Warning, {\n          children: _jsx(_components.p, {\n            children: \"Because Java is so slow, an adjacency list using lists/arraylists results in\\r\\nTLE. Instead, the Java sample code uses the edge representation mentioned in the\\r\\noptional block above.\"\n          })\n        }), _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-java\",\n            children: \"import java.io.*;\\r\\nimport java.util.*;\\r\\n\\r\\npublic class BuildingTeams\\r\\n{\\r\\n\\tstatic InputReader in = new InputReader(System.in);\\r\\n\\tstatic PrintWriter out = new PrintWriter(System.out);\\r\\n\\r\\n\\tpublic static final int MN = 100010;\\r\\n\\tpublic static final int MM = 200010;\\r\\n\\r\\n\\tpublic static int N, M;\\r\\n\\tpublic static boolean bad;\\r\\n\\tpublic static boolean[]\\tvis = new boolean[MN], group = new boolean[MN];\\r\\n\\tpublic static int[] hd = new int[MN], nx = new int[MM*2], to = new int[MM*2];\\r\\n\\r\\n\\tpublic static void dfs(int n, boolean g)\\r\\n\\t{\\r\\n\\t\\tvis[n]=true;\\r\\n\\t\\tgroup[n]=g;\\r\\n\\t\\tfor(int id=hd[n];id!=0;id=nx[id])\\r\\n\\t\\t\\tif(vis[to[id]])\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tif(group[to[id]]==g)\\r\\n\\t\\t\\t\\t\\tbad=true;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\telse\\r\\n\\t\\t\\t\\tdfs(to[id], !g);\\r\\n\\t}\\r\\n\\tpublic static void adde(int u, int v, int id)\\r\\n\\t{\\r\\n\\t\\tnx[id]=hd[u];\\r\\n\\t\\thd[u]=id;\\r\\n\\t\\tto[id]=v;\\r\\n\\t}\\r\\n\\tpublic static void main(String... args)\\r\\n\\t{\\r\\n\\t\\tN=in.nextInt();\\r\\n\\t\\tM=in.nextInt();\\r\\n\\t\\tfor(int i=0,u,v;i<M;++i)\\r\\n\\t\\t{\\r\\n\\t\\t\\tu=in.nextInt();\\r\\n\\t\\t\\tv=in.nextInt();\\r\\n\\t\\t\\tadde(u,v,i*2+1);\\r\\n\\t\\t\\tadde(v,u,i*2+2);\\r\\n\\t\\t}\\r\\n\\t\\tfor(int i=1;!bad && i<=N;++i)\\r\\n\\t\\t\\tif(!vis[i])\\r\\n\\t\\t\\t\\tdfs(i, false);\\r\\n\\t\\tif(bad)\\r\\n\\t\\t\\tout.println(\\\"IMPOSSIBLE\\\");\\r\\n\\t\\telse\\r\\n\\t\\t\\tfor(int i=1;i<=N;++i)\\r\\n\\t\\t\\t{\\r\\n\\t\\t\\t\\tout.print(group[i] ? '1' : '2');\\r\\n\\t\\t\\t\\tif(i<N) out.print(' ');\\r\\n\\t\\t\\t\\telse out.println();\\r\\n\\t\\t\\t}\\r\\n\\t\\tout.close();\\r\\n\\t}\\r\\n}\\n\"\n          })\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"problems-1\",\n      children: [_jsx(_components.a, {\n        href: \"#problems-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"bip\",\n      hideSuggestProblemButton: true\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  redirects,\n  title,\n  author,\n  contributors,\n  prerequisites,\n  description,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"Depth First Search (DFS)","author":"Siyong Huang, Benjamin Qi","contributors":"Andrew Wang, Jason Chen","id":"dfs","prerequisites":["intro-graphs","complete-rec"],"description":"Recursively traversing a graph.","frequency":4},"parent":{"name":"DFS","relativePath":"3_Silver/DFS.mdx"},"fields":{"division":"silver"},"toc":{"cpp":[{"depth":2,"value":"Application - Connected Components","slug":"application---connected-components"},{"depth":3,"value":"Solution - Building Roads","slug":"solution---building-roads"},{"depth":3,"value":"Problems","slug":"problems"},{"depth":2,"value":"Application - Graph Two-Coloring","slug":"application---graph-two-coloring"},{"depth":3,"value":"Solution - Building Teams","slug":"solution---building-teams"},{"depth":3,"value":"Problems","slug":"problems-1"}],"java":[{"depth":2,"value":"Application - Connected Components","slug":"application---connected-components"},{"depth":3,"value":"Solution - Building Roads","slug":"solution---building-roads"},{"depth":3,"value":"Problems","slug":"problems"},{"depth":2,"value":"Application - Graph Two-Coloring","slug":"application---graph-two-coloring"},{"depth":3,"value":"Solution - Building Teams","slug":"solution---building-teams"},{"depth":3,"value":"Problems","slug":"problems-1"}],"py":[{"depth":2,"value":"Application - Connected Components","slug":"application---connected-components"},{"depth":3,"value":"Solution - Building Roads","slug":"solution---building-roads"},{"depth":3,"value":"Problems","slug":"problems"},{"depth":2,"value":"Application - Graph Two-Coloring","slug":"application---graph-two-coloring"},{"depth":3,"value":"Solution - Building Teams","slug":"solution---building-teams"},{"depth":3,"value":"Problems","slug":"problems-1"}]}},"moduleProblemLists":{"problemLists":[{"listId":"sample","problems":[{"uniqueId":"cses-1666","name":"Building Roads","url":"https://cses.fi/problemset/task/1666","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["Connected Components"],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/silver/dfs#problem-cses-1666","sketch":null}}]},{"listId":"general","problems":[{"uniqueId":"usaco-644","name":"Closing the Farm","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=644","source":"Silver","difficulty":"Easy","isStarred":false,"tags":["Connected Components"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-668","name":"Moocast","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=668","source":"Silver","difficulty":"Easy","isStarred":true,"tags":[],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-944","name":"Fence Planning","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=944","source":"Silver","difficulty":"Easy","isStarred":true,"tags":["Connected Components"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"kattis-birthday","name":"Birthday Party","url":"https://open.kattis.com/problems/birthday","source":"Kattis","difficulty":"Easy","isStarred":false,"tags":["Connected Components"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"dmoj-rank","name":"Rank","url":"https://dmoj.ca/problem/acsl1p4","source":"DMOJ","difficulty":"Easy","isStarred":false,"tags":["DFS"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cses-1682","name":"Flight Routes Check","url":"https://cses.fi/problemset/task/1682","source":"CSES","difficulty":"Normal","isStarred":true,"tags":[],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-669","name":"Moocast","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=669","source":"Gold","difficulty":"Normal","isStarred":false,"tags":["Connected Components","Binary Search"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-992","name":"Wormhole Sort","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=992","source":"Silver","difficulty":"Normal","isStarred":true,"tags":["Connected Components","Binary Search"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1159","name":"Connecting Two Barns","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1159","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["Connected Components","2P","Binary Search"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1206","name":"Redistributing Gifts","url":"http://usaco.org/index.php?page=viewproblem2&cpid=1206","source":"Silver","difficulty":"Normal","isStarred":false,"tags":["SCC"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_prob1_silver_feb22.html","sketch":null}},{"uniqueId":"cf-920E","name":"Connected Components?","url":"https://codeforces.com/problemset/problem/920/E","source":"CF","difficulty":"Hard","isStarred":false,"tags":["DFS","Sorted Set"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"kattis-LaneSwitching","name":"Lane Switching","url":"https://open.kattis.com/contests/acpc17open/problems/laneswitching","source":"Kattis","difficulty":"Very Hard","isStarred":false,"tags":["Connected Components","Binary Search"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-1184","name":"Cereal 2","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=1184","source":"Silver","difficulty":"Very Hard","isStarred":false,"tags":["Spanning Tree","Constructive","Cycles"],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_prob3_silver_jan22.html","sketch":null}}]},{"listId":"bipsample","problems":[{"uniqueId":"cses-1668","name":"Building Teams","url":"https://cses.fi/problemset/task/1668","source":"CSES","difficulty":"Easy","isStarred":false,"tags":["Bipartite"],"solution":{"kind":"link","label":"In Module","labelTooltip":null,"url":"https://usaco.guide/silver/dfs#problem-cses-1668","sketch":null}}]},{"listId":"bip","problems":[{"uniqueId":"cf-862B","name":"Bipartiteness","url":"https://codeforces.com/contest/862/problem/B","source":"CF","difficulty":"Easy","isStarred":false,"tags":["Bipartite"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"usaco-920","name":"The Great Revegetation","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=920","source":"Silver","difficulty":"Easy","isStarred":true,"tags":["Bipartite"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-1176E","name":"Cover it!","url":"https://codeforces.com/problemset/problem/1176/E","source":"CF","difficulty":"Easy","isStarred":false,"tags":["Bipartite"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"baltic-20-graph","name":"2020 - Graph","url":"https://codeforces.com/contest/1387/problem/A","source":"Baltic OI","difficulty":"Hard","isStarred":false,"tags":["DFS","Median"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cc-AMONGUS2","name":"Among Us","url":"https://www.codechef.com/INOIPRAC/problems/AMONGUS2","source":"CC","difficulty":"Hard","isStarred":false,"tags":["DFS","Bipartite"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"apio-11-TableColoring","name":"2011 - Table Coloring","url":"https://dmoj.ca/problem/apio11p1","source":"APIO","difficulty":"Very Hard","isStarred":false,"tags":["Bipartite"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}}]}]}},"pageContext":{"id":"dfs"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}