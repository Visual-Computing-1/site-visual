{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/adv/string-suffix",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*https://codeforces.com/edu/course/2/lesson/2/2/practice/contest/269103/submission/85759835*/\n/*https://codeforces.com/edu/course/2/lesson/2/2/practice/contest/269103/submission/85759835 - This submission contains both*/\n/*Checked via USACO Practice*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"string-suffix\", title = \"String Suffix Structures\", author = \"Siyong Huang, Benjamin Qi\", description = \"Suffix Automata, Suffix Trees, and Palindromic Trees\", prerequisites = [\"string-search\"], frequency = 0;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    a: \"a\",\n    strong: \"strong\",\n    h3: \"h3\",\n    em: \"em\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    MATHSPAN: _missingComponent(\"MATHSPAN\"),\n    Spoiler: _missingComponent(\"Spoiler\"),\n    LanguageSection: _missingComponent(\"LanguageSection\"),\n    CPPSection: _missingComponent(\"CPPSection\"),\n    Info: _missingComponent(\"Info\"),\n    Problems: _missingComponent(\"Problems\")\n  }, _props.components), {HeaderLink, Resources, Resource, MATHSPAN, Spoiler, LanguageSection, CPPSection, Info, Problems, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"A lot of problems can be solved with Suffix Arrays, Suffix Automata, or Suffix\\r\\nTrees. The solution may just be slightly easier/harder with the various data\\r\\nstructures.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"suffix-automaton\",\n      children: [_jsx(_components.a, {\n        href: \"#suffix-automaton\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Suffix Automaton\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.strong, {\n        children: \"Suffix Automaton\"\n      }), \" is a directed acyclic word graph (DAWG), such that each\\r\\npath in the graph traces out a distinct substring of the original string.\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CF\",\n        title: \"A short guide to suffix automata\",\n        url: \"20861\",\n        children: _jsx(_components.p, {\n          children: \"Explanation of Suffix Automata\"\n        })\n      }), _jsx(Resource, {\n        source: \"cp-algo\",\n        title: \"Suffix Automaton\",\n        url: \"string/suffix-automaton.html\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"Excellent Suffix Automaton tutorial\"\n        })\n      }), _jsx(Resource, {\n        source: \"CF\",\n        title: \"adamant - history of recurring problem\",\n        url: \"62331\",\n        children: _jsx(_components.p, {\n          children: \"More problems!\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsx(Resources, {\n      children: _jsx(Resource, {\n        source: \"Benq\",\n        title: \"Suffix Automaton\",\n        url: \"https://github.com/bqi343/USACO/blob/master/Implementations/content/strings%20(14)/Heavy/SuffixAutomaton.h\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"suffix-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#suffix-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Suffix Tree\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.strong, {\n        children: \"Suffix Tree\"\n      }), \" is a trie that contains all suffixes of a string. Naively,\\r\\nthis would take up \", _jsx(MATHSPAN, {\n        className: \"math math-inline\",\n        latex: \"\\\\mathcal{O}(N^2)\",\n        children: \"<span class=\\\"katex\\\"><span class=\\\"katex-mathml\\\"><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><semantics><mrow><mi mathvariant=\\\"script\\\">O</mi><mo stretchy=\\\"false\\\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\\\"false\\\">)</mo></mrow><annotation encoding=\\\"application/x-tex\\\">\\\\mathcal{O}(N^2)</annotation></semantics></math></span><span class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"><span class=\\\"base\\\"><span class=\\\"strut\\\" style=\\\"height:1.0641em;vertical-align:-0.25em;\\\"></span><span class=\\\"mord mathcal\\\" style=\\\"margin-right:0.02778em;\\\">O</span><span class=\\\"mopen\\\">(</span><span class=\\\"mord\\\"><span class=\\\"mord mathnormal\\\" style=\\\"margin-right:0.10903em;\\\">N</span><span class=\\\"msupsub\\\"><span class=\\\"vlist-t\\\"><span class=\\\"vlist-r\\\"><span class=\\\"vlist\\\" style=\\\"height:0.8141em;\\\"><span style=\\\"top:-3.063em;margin-right:0.05em;\\\"><span class=\\\"pstrut\\\" style=\\\"height:2.7em;\\\"></span><span class=\\\"sizing reset-size6 size3 mtight\\\"><span class=\\\"mord mtight\\\">2</span></span></span></span></span></span></span></span><span class=\\\"mclose\\\">)</span></span></span></span>\"\n      }), \" memory, but \", _jsx(_components.em, {\n        children: \"path compression\"\n      }), \" enables it\\r\\nto be represented and computed in linear memory.\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"SO\",\n        title: \"Ukkonen's suffix tree algorithm in plain English\",\n        url: \"https://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"example + diagrams\"\n        })\n      }), _jsx(Resource, {\n        source: \"CF\",\n        title: \"Suffix Tree. Ukkonen's algorithm\",\n        url: \"16780\",\n        starred: true,\n        children: _jsx(_components.p, {\n          children: \"brief explanation of Ukkonen's Algorithm + code\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation-1\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"Benq\",\n        title: \"Suffix Tree\",\n        url: \"https://github.com/bqi343/USACO/blob/master/Implementations/content/strings%20(14)/Heavy/SuffixTree.h\",\n        children: _jsx(_components.p, {\n          children: \"based off adamant's above\"\n        })\n      }), _jsx(Resource, {\n        source: \"cp-algo\",\n        title: \"Suffix Tree. Ukkonen's Algorithm\",\n        url: \"string/suffix-tree-ukkonen.html\",\n        children: _jsx(_components.p, {\n          children: \"implementation of Ukkonen's Algorithm\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"generate-suffix-array-from-suffix-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#generate-suffix-array-from-suffix-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Generate Suffix Array from Suffix Tree\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A suffix array can be generated by the suffix tree by taking the dfs traversal\\r\\nof the suffix tree.\"\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"Sample Code: Suffix Array from Suffix Tree\",\n      children: _jsx(LanguageSection, {\n        children: _jsx(CPPSection, {\n          children: _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-cpp\",\n              children: \"int N, sa[MN], ctr;//length of string, suffix array, counter\\r\\n\\r\\nstruct Edge\\r\\n{\\r\\npublic:\\r\\n\\tint n, l, r;//node, edge covers s[l..r]\\r\\n\\texplicit operator bool() const {return n!=-1;}\\r\\n} c[MN*2][26]; // edges of a suffix tree\\r\\n\\r\\nvoid dfs(int n=0, int d=0)\\r\\n{\\r\\n\\tbool c=0;// Has child. If false, then this node is a leaf\\r\\n\\tfor(int i=0;i<26;++i)\\r\\n\\t\\tif(c[n][i])\\r\\n\\t\\t{\\r\\n\\t\\t\\tc=1;\\r\\n\\t\\t\\tdfs(c[n][i].n, d+c[n][i].r-c[n][i].l);\\r\\n\\t\\t}\\r\\n\\tif(!c)\\r\\n\\t\\tsa[ctr++]=N-d;\\r\\n}\\n\"\n            })\n          })\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"generate-suffix-tree-from-suffix-array\",\n      children: [_jsx(_components.a, {\n        href: \"#generate-suffix-tree-from-suffix-array\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Generate Suffix Tree from Suffix Array\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Of course, the above operation can be reversed as well. Each element in the\\r\\nsuffix array corresponds to a leaf in the suffix tree. The LCP array stores\\r\\ninformation about the Lowest Common Ancestor of two adjacent elements in the\\r\\nsuffix array. Using these two pieces of information, we can construct the suffix\\r\\ntree from the suffix array in linear time.\"\n    }), \"\\n\", _jsx(Info, {\n      title: \"Pro Tip!\",\n      children: _jsxs(_components.p, {\n        children: [\"Frequently, string suffix structures are greatly simplified by adding a\\r\\n'terminator' character, such as \", _jsx(_components.code, {\n          children: \"$\"\n        }), \" or \", _jsx(_components.code, {\n          children: \"-\"\n        }), \", to the end of the string. In the\\r\\nfollowing samples, these terminators will be explicitly added.\"]\n      })\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"Sample Code: Suffix Tree from Suffix Array\",\n      children: _jsx(LanguageSection, {\n        children: _jsx(CPPSection, {\n          children: _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-cpp\",\n              children: \"int N;\\r\\nchar s[MN];\\r\\nint sa[MN]; //suffix array\\r\\nint lcp[MN]; //lcp[i] stores the longest common prefix between s[sa[i-1]..] and s[sa[i]..]\\r\\n\\r\\nEdge c[MN*2][MK]; // edges of suffix tree\\r\\nint d[MN*2];//length of string corresponding to a node in the suffix tree\\r\\nint q[MN*2], Q, ctr, rm[MN];//q is used as stack. ctr counts number of nodes in tree\\r\\nstd::stack<int> ins[MN];\\r\\nvoid build_tree()\\r\\n{\\r\\n\\tq[0]=N; Q=0;\\r\\n\\tfor(int i=N-1;i>=1;--i)\\r\\n\\t{\\r\\n\\t\\twhile(Q&&lcp[q[Q]]>lcp[i])--Q;\\r\\n\\t\\tif(lcp[q[Q]]!=lcp[i]) ++rm[q[Q]];//Right bound of the range where lcp is the longest common prefix\\r\\n\\t\\tq[++Q]=i;\\r\\n\\t}\\r\\n\\tq[0]=0, Q=0;\\r\\n\\tfor(int i=1;i<N;++i)\\r\\n\\t{\\r\\n\\t\\twhile(Q&&lcp[q[Q]]>lcp[i])--Q;\\r\\n\\t\\tif(lcp[q[Q]]!=lcp[i]) ins[q[Q]].push(i);//Left bound of the range where lcp first becomes a longest common prefix\\r\\n\\t\\tq[++Q]=i;\\r\\n\\t}\\r\\n\\t//The left and right bounds computed above can be interpreted as the dfs preorder and postorder\\r\\n\\tq[0]=0, Q=0;//This q array now holds the stack of ancestors for every new node created\\r\\n\\tauto nn=[&](int l, int dd)\\r\\n\\t{\\r\\n\\t\\t++ctr;\\r\\n\\t\\td[ctr]=dd;\\r\\n\\t\\tint p=q[Q];\\r\\n\\t\\t// p is the parent of this node, per definition of stack q\\r\\n\\t\\tint r=l+dd;\\r\\n\\t\\t//s[l..r] is the string corresponding to the node that we are inserting\\r\\n\\t\\tl+=d[p];\\r\\n\\t\\t//d[p] is the length of the parent, so s[l..l+d[p]] would have already been covered by the node's ancestors\\r\\n\\t\\tc[p][s[l]]={ctr,l,r};\\r\\n\\t\\treturn ctr;\\r\\n\\t};\\r\\n\\tfor(int i=0;i<N;++i)\\r\\n\\t{\\r\\n\\t\\tQ-=rm[i];\\r\\n\\t\\tfor(int x;!ins[i].empty();ins[i].pop())\\r\\n\\t\\t{\\r\\n\\t\\t\\tx=ins[i].top();\\r\\n\\t\\t\\tx=nn(sa[x], lcp[x]);\\r\\n\\t\\t\\t//   sa[x+1] would be equivalent, per definition of lcp\\r\\n\\t\\t\\tq[++Q]=x;\\r\\n\\t\\t}\\r\\n\\t\\tnn(sa[i], N-sa[i]);\\r\\n\\t}\\r\\n}\\n\"\n            })\n          })\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"generate-suffix-tree-from-suffix-automaton\",\n      children: [_jsx(_components.a, {\n        href: \"#generate-suffix-tree-from-suffix-automaton\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Generate Suffix Tree from Suffix Automaton\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One interesting thing about Suffix Trees and Suffix Automata is that the link\\r\\ntree of a Suffix Automaton is equivalent to the Suffix Tree of the reversed\\r\\nstring. Since Suffix Automata are much easier to create than Suffix Trees, we\\r\\ncan use this as an alternate method to build a Suffix Tree, all in linear time\\r\\ntoo!\"\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"Sample Code: Suffix Tree from Suffix Automaton\",\n      children: _jsx(LanguageSection, {\n        children: _jsx(CPPSection, {\n          children: _jsx(_components.pre, {\n            children: _jsx(_components.code, {\n              className: \"language-cpp\",\n              children: \"char s[MN]; //string\\r\\nint ord[MN]; // nodes representing prefixes of the string s\\r\\nint u[MN*2]; // whether the node has already been created\\r\\nint l[MN*2]; // link in suffix automaton\\r\\nEdge c[MN*2][27]; // edge of suffix tree (not automaton; structure of automaton is not necessary to build stree)\\r\\nvoid build_tree()\\r\\n{\\r\\n\\ts[N] = 26; // terminator\\r\\n\\tfor(int i=N;i>=0;--i) ord[i]=append(ord[i+1], s[i]);\\r\\n\\tfor(int i=0,x,r,l;i<=N;++i)\\r\\n\\t{\\r\\n\\t\\tx=ord[i], r=N+1;\\r\\n\\t\\tfor(;x&&!u[x];x=l[x])\\r\\n\\t\\t{\\r\\n\\t\\t\\tl=r-d[x]+d[l[x]];\\r\\n\\t\\t\\tc[l[x]][s[l]]={x, l, r};\\r\\n\\t\\t\\tr=l;\\r\\n\\t\\t\\tu[x]=1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n            })\n          })\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"example---standing-out\",\n      children: [_jsx(_components.a, {\n        href: \"#example---standing-out\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Example - Standing Out\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"auto\"\n    }), \"\\n\", _jsx(Spoiler, {\n      title: \"With Suffix Automaton\",\n      children: _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-cpp\",\n          children: \"#include <cstdio>\\r\\n#include <cstring>\\r\\n#include <vector>\\r\\n\\r\\nFILE * IN, * OUT;\\r\\ntypedef long long ll;\\r\\nconst int MN = 1e5+10, MM = MN*2;\\r\\nchar s[MN];\\r\\nstd::vector<int> down[MM];\\r\\nint N, v[MM], c[MM][26], l[MM], d[MM], topo[MM], T, X;\\r\\nll f[MN], cnt[MM];\\r\\nbool u[MM];\\r\\n\\r\\n/*\\r\\nKey Variables:\\r\\n\\r\\ns: input strings\\r\\ndown: link tree of automaton\\r\\nv: information regarding which cow each node belongs to\\r\\nc: child array of automaton\\r\\nl: link (of automaton)\\r\\nd: depth (of automaton)\\r\\ntopo: toposort (of automaton)\\r\\nT, X: counters for toposort and automaton\\r\\nf: answer\\r\\ncnt: number of ways to reach a node from the root\\r\\nu: visited array for toposort\\r\\n*/\\r\\n\\r\\n//add cow b to value a\\r\\n//value = -1: no cow assigned\\r\\n//value = -2: multiple cows assigned\\r\\n//value = 0..N: cow id\\r\\nvoid merge(int& a, int b)\\r\\n{\\r\\n\\tif(!~a) a=b;\\r\\n\\telse if(~b&&a!=b) a=-2;\\r\\n}\\r\\n\\r\\n//template automaton code\\r\\nint append(int p, char x)\\r\\n{\\r\\n\\tif(~c[p][x])\\r\\n\\t{\\r\\n\\t\\tint q=c[p][x];\\r\\n\\t\\tif(d[q]==d[p]+1)\\r\\n\\t\\t\\treturn q;\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\t++X;\\r\\n\\t\\t\\tfor(int i=0;i<26;++i) c[X][i]=c[q][i];\\r\\n\\t\\t\\tl[X]=l[q], d[X]=d[p]+1;\\r\\n\\t\\t\\tl[q]=X;\\r\\n\\t\\t\\tfor(;~p&&c[p][x]==q;p=l[p])\\r\\n\\t\\t\\t\\tc[p][x]=l[q];\\r\\n\\t\\t\\treturn l[q];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tint n = ++X;\\r\\n\\td[n]=d[p]+1;\\r\\n\\tfor(;~p&&!~c[p][x];p=l[p])\\r\\n\\t\\tc[p][x]=n;\\r\\n\\tif(!~p)\\r\\n\\t\\tl[n]=0;\\r\\n\\telse\\r\\n\\t{\\r\\n\\t\\tint q=c[p][x];\\r\\n\\t\\tif(d[q]==d[p]+1)\\r\\n\\t\\t\\tl[n]=q;\\r\\n\\t\\telse\\r\\n\\t\\t{\\r\\n\\t\\t\\t++X;\\r\\n\\t\\t\\tfor(int i=0;i<26;++i) c[X][i]=c[q][i];\\r\\n\\t\\t\\tl[X]=l[q], d[X]=d[p]+1;\\r\\n\\t\\t\\tl[n]=l[q]=X;\\r\\n\\t\\t\\tfor(;~p&&c[p][x]==q;p=l[p])\\r\\n\\t\\t\\t\\tc[p][x]=l[q];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\treturn n;\\r\\n}\\r\\n\\r\\n//DFS along links\\r\\nvoid dfs2(int n=0)\\r\\n{\\r\\n\\tfor(int x:down[n])\\r\\n\\t{\\r\\n\\t\\tdfs2(x);\\r\\n\\t\\tmerge(v[n], v[x]);\\r\\n\\t}\\r\\n}\\r\\n//DFS along suffix automaton. This builds the toposort\\r\\nvoid dfs(int n=0)\\r\\n{\\r\\n\\tu[n]=1;\\r\\n\\tfor(int i=0;i<26;++i)\\r\\n\\t{\\r\\n\\t\\tint y=c[n][i];\\r\\n\\t\\tif(~y && !u[y]) dfs(y);\\r\\n\\t}\\r\\n\\ttopo[T++] = n;\\r\\n}\\r\\n\\r\\nint main(void)\\r\\n{\\r\\n\\tIN = fopen(\\\"standingout.in\\\", \\\"r\\\"), OUT = fopen(\\\"standingout.out\\\", \\\"w\\\");\\r\\n\\tmemset(v, -1, sizeof v);\\r\\n\\tmemset(c, -1, sizeof c);\\r\\n\\tfscanf(IN, \\\"%d\\\", &N);\\r\\n\\td[0]=0, l[0]=-1;\\r\\n\\tfor(int i=0;i<N;++i)\\r\\n\\t{\\r\\n\\t\\tfscanf(IN, \\\" %s\\\", s);\\r\\n\\t\\tint n=0;\\r\\n\\t\\tfor(int j=0;s[j];++j)\\r\\n\\t\\t{\\r\\n\\t\\t\\tn = append(n, s[j]-'a'); //build automaton\\r\\n\\t\\t\\tmerge(v[n], i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t//build link tree\\r\\n\\tfor(int i=1;i<=X;++i)\\r\\n\\t\\tdown[l[i]].push_back(i);\\r\\n\\tdfs();//dfs link tree\\r\\n\\tdfs2();//dfs automaton\\r\\n\\tcnt[0]=1;\\r\\n\\tfor(int i=T-1, x;i>=0;--i)\\r\\n\\t{\\r\\n\\t\\tx=topo[i];\\r\\n\\t\\tfor(int j=0;j<26;++j)\\r\\n\\t\\t\\tif(~c[x][j])\\r\\n\\t\\t\\t\\tcnt[c[x][j]]+=cnt[x];//count number of paths from root to a node\\r\\n\\t\\tif(v[x]>=0)\\r\\n\\t\\t\\tf[v[x]]+=cnt[x];//if this node is associated with a unique cow, add to answer\\r\\n\\t}\\r\\n\\tfor(int i=0;i<N;++i)\\r\\n\\t\\tfprintf(OUT, \\\"%lld\\\\n\\\", f[i]);\\r\\n\\treturn 0;\\r\\n}\\n\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"suffix-structure-problems-array-automaton-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#suffix-structure-problems-array-automaton-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Suffix Structure Problems (Array, Automaton, Tree)\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"general_suffix\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"extending-palindromic-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#extending-palindromic-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Extending Palindromic Tree\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        source: \"CF\",\n        title: \"A bit more about palindromes\",\n        url: \"19193\"\n      }), _jsx(Resource, {\n        source: \"CF\",\n        title: \"Palindromic tree: Behind the Scenes\",\n        url: \"13959\"\n      })]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"paltree\"\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  title,\n  author,\n  description,\n  prerequisites,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"String Suffix Structures","author":"Siyong Huang, Benjamin Qi","contributors":null,"id":"string-suffix","prerequisites":["string-search"],"description":"Suffix Automata, Suffix Trees, and Palindromic Trees","frequency":0},"parent":{"name":"String_Suffix","relativePath":"6_Advanced/String_Suffix.mdx"},"fields":{"division":"adv"},"toc":{"cpp":[{"depth":2,"value":"Suffix Automaton","slug":"suffix-automaton"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Suffix Tree","slug":"suffix-tree"},{"depth":3,"value":"Implementation","slug":"implementation-1"},{"depth":3,"value":"Generate Suffix Array from Suffix Tree","slug":"generate-suffix-array-from-suffix-tree"},{"depth":3,"value":"Generate Suffix Tree from Suffix Array","slug":"generate-suffix-tree-from-suffix-array"},{"depth":3,"value":"Generate Suffix Tree from Suffix Automaton","slug":"generate-suffix-tree-from-suffix-automaton"},{"depth":3,"value":"Example - Standing Out","slug":"example---standing-out"},{"depth":2,"value":"Suffix Structure Problems (Array, Automaton, Tree)","slug":"suffix-structure-problems-array-automaton-tree"},{"depth":2,"value":"Extending Palindromic Tree","slug":"extending-palindromic-tree"},{"depth":3,"value":"Problems","slug":"problems"}],"java":[{"depth":2,"value":"Suffix Automaton","slug":"suffix-automaton"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Suffix Tree","slug":"suffix-tree"},{"depth":3,"value":"Implementation","slug":"implementation-1"},{"depth":3,"value":"Generate Suffix Array from Suffix Tree","slug":"generate-suffix-array-from-suffix-tree"},{"depth":3,"value":"Generate Suffix Tree from Suffix Array","slug":"generate-suffix-tree-from-suffix-array"},{"depth":3,"value":"Generate Suffix Tree from Suffix Automaton","slug":"generate-suffix-tree-from-suffix-automaton"},{"depth":3,"value":"Example - Standing Out","slug":"example---standing-out"},{"depth":2,"value":"Suffix Structure Problems (Array, Automaton, Tree)","slug":"suffix-structure-problems-array-automaton-tree"},{"depth":2,"value":"Extending Palindromic Tree","slug":"extending-palindromic-tree"},{"depth":3,"value":"Problems","slug":"problems"}],"py":[{"depth":2,"value":"Suffix Automaton","slug":"suffix-automaton"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":2,"value":"Suffix Tree","slug":"suffix-tree"},{"depth":3,"value":"Implementation","slug":"implementation-1"},{"depth":3,"value":"Generate Suffix Array from Suffix Tree","slug":"generate-suffix-array-from-suffix-tree"},{"depth":3,"value":"Generate Suffix Tree from Suffix Array","slug":"generate-suffix-tree-from-suffix-array"},{"depth":3,"value":"Generate Suffix Tree from Suffix Automaton","slug":"generate-suffix-tree-from-suffix-automaton"},{"depth":3,"value":"Example - Standing Out","slug":"example---standing-out"},{"depth":2,"value":"Suffix Structure Problems (Array, Automaton, Tree)","slug":"suffix-structure-problems-array-automaton-tree"},{"depth":2,"value":"Extending Palindromic Tree","slug":"extending-palindromic-tree"},{"depth":3,"value":"Problems","slug":"problems"}]}},"moduleProblemLists":{"problemLists":[{"listId":"auto","problems":[{"uniqueId":"usaco-768","name":"Standing Out from the Herd","url":"http://www.usaco.org/index.php?page=viewproblem2&cpid=768","source":"Plat","difficulty":"Hard","isStarred":false,"tags":[],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"http://www.usaco.org/current/data/sol_standingout_platinum_dec17.html","sketch":null}}]},{"listId":"general_suffix","problems":[{"uniqueId":"cf-2A","name":"Suffix Array","url":"https://codeforces.com/edu/course/2/lesson/2/2/practice/contest/269103/problem/A","source":"CF","difficulty":"Easy","isStarred":true,"tags":["Suffix Structures"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"kattis-stringmultimatching","name":"String Multimatching","url":"https://open.kattis.com/problems/stringmultimatching","source":"Kattis","difficulty":"Easy","isStarred":false,"tags":[],"solution":{"kind":"sketch","label":null,"labelTooltip":null,"url":null,"sketch":"Try solving it using Suffix Tree or Suffix Automaton!"}},{"uniqueId":"onlinejudgeorg-ILoveStrings","name":"I Love Strings!!","url":"https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=18&page=show_problem&problem=1620","source":"onlinejudge.org","difficulty":"Easy","isStarred":false,"tags":[],"solution":null},{"uniqueId":"spoj-LexicographicalStringSearch","name":"Lexicographical String Search","url":"https://www.spoj.com/problems/SUBLEX","source":"SPOJ","difficulty":"Easy","isStarred":true,"tags":["Suffix Structures"],"solution":{"kind":"sketch","label":null,"labelTooltip":null,"url":null,"sketch":"Remember, each path (starting from the root) in a suffix automaton is a distinct substring!"}},{"uniqueId":"cf-547E","name":"Mike & Friends","url":"https://codeforces.com/contest/547/problem/E","source":"CF","difficulty":"Easy","isStarred":false,"tags":[],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"he-PowerOfString3","name":"Power of String 3","url":"https://www.hackerearth.com/practice/data-structures/advanced-data-structures/suffix-trees/practice-problems/algorithm/power-of-string-3/description/","source":"HE","difficulty":"Normal","isStarred":false,"tags":["Suffix Structures"],"solution":null},{"uniqueId":"cf-235C","name":"Cyclical Quest","url":"https://codeforces.com/contest/235/problem/C","source":"CF","difficulty":"Normal","isStarred":false,"tags":["Suffix Structures"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"balkan-15-clarkson","name":"2015 - Clarkson","url":"https://www.acmicpc.net/problem/11555","source":"Balkan OI","difficulty":"Normal","isStarred":false,"tags":["Suffix Structures","DP"],"solution":{"kind":"internal","label":null,"labelTooltip":null,"url":null,"sketch":null}},{"uniqueId":"cf-653F","name":"Paper Task","url":"https://codeforces.com/contest/653/problem/F","source":"CF","difficulty":"Hard","isStarred":false,"tags":["Suffix Structures"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1073G","name":"Yet Another LCP Problem","url":"https://codeforces.com/contest/1073/problem/G","source":"CF","difficulty":"Hard","isStarred":false,"tags":["Suffix Structures"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1207G","name":"Indie Album","url":"https://codeforces.com/contest/1207/problem/G","source":"CF","difficulty":"Hard","isStarred":false,"tags":["Suffix Structures"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1063F","name":"String Journey","url":"https://codeforces.com/contest/1063/problem/F","source":"CF","difficulty":"Very Hard","isStarred":false,"tags":["Suffix Structures","DP"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1037H","name":"Security","url":"https://codeforces.com/contest/1037/problem/H","source":"CF","difficulty":"Very Hard","isStarred":false,"tags":["Suffix Tree"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cfgym-102129I","name":"Incomparable Pairs","url":"https://codeforces.com/gym/102129/problem/I","source":"CF","difficulty":"Very Hard","isStarred":false,"tags":["Suffix Structures"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}}]},{"listId":"paltree","problems":[{"uniqueId":"cf-932G","name":"Palindromic Partition","url":"https://codeforces.com/contest/932/problem/G","source":"CF","difficulty":"Very Hard","isStarred":false,"tags":["Palindromic Tree"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-1081H","name":"Palindromic Magic","url":"https://codeforces.com/contest/1081/problem/H","source":"CF","difficulty":"Insane","isStarred":false,"tags":["Palindromic Tree"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}}]}]}},"pageContext":{"id":"string-suffix"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}