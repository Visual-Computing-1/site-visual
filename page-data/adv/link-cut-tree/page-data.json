{
    "componentChunkName": "component---src-templates-module-template-tsx",
    "path": "/adv/link-cut-tree",
    "result": {"data":{"xdm":{"body":"/*@jsxRuntime automatic @jsxImportSource react*/\n/*We can use a Link-Cut Tree to process dynamic connectivity queries in*/\n/*$\\mathcal{O}(\\log N)$ time.*/\n/*\n\n### USACO Camp\n\n(Maybe add descriptions since problems not publicly viewable.)\n\n* [The Applicant](https://probgate.org/viewproblem.php?pid=578)\n* tree + one edge\n* [Cows Play on a Tree](https://probgate.org/viewproblem.php?pid=259)\n* reverse tree paths\n* HLD + Treap\n* or two LCTs, one for real tree labels and one for query labels\n\n*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _missingComponent(name) {\n  return function () {\n    throw new Error(\"Component `\" + name + \"` was not imported, exported, or given\");\n  };\n}\nconst id = \"link-cut-tree\", redirects = [\"/adv/LCT\"], title = \"Link Cut Tree\", author = \"Benjamin Qi, Neo Wang\", description = \"Dynamic operations on a rooted forest\", prerequisites = [\"offline-del\", \"treaps\"], frequency = 1;\nfunction MDXContent(_props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    a: \"a\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    HeaderLink: _missingComponent(\"HeaderLink\"),\n    Resources: _missingComponent(\"Resources\"),\n    Resource: _missingComponent(\"Resource\"),\n    FocusProblem: _missingComponent(\"FocusProblem\"),\n    Problems: _missingComponent(\"Problems\")\n  }, _props.components), {HeaderLink, Resources, Resource, FocusProblem, Problems, wrapper: MDXLayout} = _components;\n  const _content = _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"splay-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#splay-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Splay Tree\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"tutorial\",\n      children: [_jsx(_components.a, {\n        href: \"#tutorial\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Tutorial\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        starred: true,\n        source: \"MIT\",\n        title: \"Splay Tree Notes\",\n        url: \"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-854j-advanced-algorithms-fall-2008/lecture-notes/lec6.pdf\"\n      }), _jsx(Resource, {\n        source: \"Stanford\",\n        title: \"Splay Tree Presentation\",\n        url: \"https://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/08/Slides08.pdf\"\n      }), _jsx(Resource, {\n        source: \"CMU\",\n        title: \"Splay Tree Paper\",\n        url: \"https://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf\"\n      }), _jsx(Resource, {\n        source: \"GH\",\n        title: \"Splay Tree Implementation\",\n        url: \"https://github.com/Bibeknam/algorithmtutorprograms/blob/master/data-structures/splay-trees/SplayTree.cpp\"\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"link-cut-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#link-cut-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Link Cut Tree\"]\n    }), \"\\n\", _jsxs(Resources, {\n      children: [_jsx(Resource, {\n        starred: true,\n        source: \"MIT\",\n        title: \"Dynamic Graphs Lecture - Link Cut Trees and HLD\",\n        url: \"https://courses.csail.mit.edu/6.851/spring21/lectures/L19.html\"\n      }), _jsx(Resource, {\n        starred: true,\n        source: \"MIT\",\n        title: \"Dynamic Graphs Scribe Notes\",\n        url: \"https://courses.csail.mit.edu/6.851/spring21/scribe/lec19.pdf\"\n      }), _jsx(Resource, {\n        source: \"CTSC\",\n        title: \"Link-Cut Tree Exploration\",\n        url: \"https://www.overleaf.com/read/zbbwngftkrkx?fbclid=IwAR1VJmGscfSZJHejVqU5_2Nlm8-R09pFlU7PpEg_i3CXEd0Qw-dzliSn5RI\"\n      }), _jsx(Resource, {\n        source: \"CF\",\n        title: \"Euler Tour Tree\",\n        url: \"https://codeforces.com/blog/entry/18369\"\n      }), _jsx(Resource, {\n        source: \"Benq\",\n        title: \"Link Cut Tree Implementation\",\n        url: \"https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Advanced/LCT.h\"\n      })]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"dynamic-connectivity\",\n      children: [_jsx(_components.a, {\n        href: \"#dynamic-connectivity\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Dynamic Connectivity\"]\n    }), \"\\n\", _jsx(FocusProblem, {\n      problem: \"conSam\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"with-link-cut-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#with-link-cut-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"With Link-Cut Tree\"]\n    }), \"\\n\", \"\\n\", \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"#include <bits/stdc++.h>\\r\\nusing namespace std;\\r\\n\\r\\n//BeginCodeSnip{Link Cut Tree}\\r\\nstruct Node {\\r\\n\\tint x;\\r\\n\\tNode *l = 0;\\r\\n\\tNode *r = 0;\\r\\n\\tNode *p = 0;\\r\\n\\tbool rev = false;\\r\\n\\r\\n\\tNode() = default;\\r\\n\\r\\n\\tNode(int v) {\\r\\n\\t\\tx = v;\\r\\n\\t}\\r\\n\\r\\n\\tvoid push() {\\r\\n\\t\\tif(rev) {\\r\\n\\t\\t\\trev = false;\\r\\n\\t\\t\\tswap(l, r);\\r\\n\\t\\t\\tif(l) l->rev ^= true;\\r\\n\\t\\t\\tif(r) r->rev ^= true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tbool is_root() {\\r\\n\\t\\treturn p == 0 || (p->l != this && this != p->r);\\r\\n\\t}\\r\\n};\\r\\n\\r\\nstruct LCT {\\r\\n\\tvector<Node> a;\\r\\n\\r\\n\\tLCT(int n) {\\r\\n\\t\\ta.resize(n+1);\\r\\n\\t\\tfor(int i = 1; i <= n; ++i)\\r\\n\\t\\ta[i].x = i;\\r\\n\\t}\\r\\n\\r\\n\\tvoid rot(Node* c) {\\r\\n\\t\\tauto p = c->p;\\r\\n\\t\\tauto g = p->p;\\r\\n\\r\\n\\t\\tif(!p->is_root())\\r\\n\\t\\t\\t(g->r == p ? g->r : g->l) = c;\\r\\n\\r\\n\\t\\tp->push();\\r\\n\\t\\tc->push();\\r\\n\\r\\n\\t\\tif(p->l == c) { // rtr\\r\\n\\t\\t\\tp->l = c->r;\\r\\n\\t\\t\\tc->r = p;\\r\\n\\t\\t\\tif(p->l) p->l->p = p;\\r\\n\\t\\t} else { // rtl\\r\\n\\t\\t\\tp->r = c->l;\\r\\n\\t\\t\\tc->l = p;\\r\\n\\t\\t\\tif(p->r) p->r->p = p;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tp->p = c;\\r\\n\\t\\tc->p = g;\\r\\n\\t}\\r\\n\\r\\n\\tvoid splay(Node* c) {\\r\\n\\t\\twhile(!c->is_root()) {\\r\\n\\t\\t\\tauto p = c->p;\\r\\n\\t\\t\\tauto g = p->p;\\r\\n\\t\\t\\tif(!p->is_root())\\r\\n\\t\\t\\t\\trot((g->r == p) == (p->r == c) ? p : c);\\r\\n\\t\\t\\trot(c);\\r\\n\\t\\t}\\r\\n\\t\\tc->push();\\r\\n\\t}\\r\\n\\r\\n\\tNode* access(int v) {\\r\\n\\t\\tNode* last = 0;\\r\\n\\t\\tNode* c = &a[v];\\r\\n\\t\\tfor(Node* p = c; p; p = p->p) {\\r\\n\\t\\t\\tsplay(p);\\r\\n\\t\\t\\tp->r = last;\\r\\n\\t\\t\\tlast = p;\\r\\n\\t\\t}\\r\\n\\t\\tsplay(c);\\r\\n\\t\\treturn last;\\r\\n\\t}\\r\\n\\r\\n\\tvoid make_root(int v) {\\r\\n\\t\\taccess(v);\\r\\n\\t\\tauto* c = &a[v];\\r\\n\\t\\tif(c->l)\\r\\n\\t\\t\\tc->l->rev ^= true, c->l = 0;\\r\\n\\t}\\r\\n\\r\\n\\tvoid link(int u, int v) {\\r\\n\\t\\tmake_root(v);\\r\\n\\t\\tNode* c = &a[v];\\r\\n\\t\\tc->p = &a[u];\\r\\n\\t}\\r\\n\\r\\n\\tvoid cut(int u, int v) {\\r\\n\\t\\tmake_root(u);\\r\\n\\t\\taccess(v);\\r\\n\\t\\tif(a[v].l) {\\r\\n\\t\\t\\ta[v].l->p = 0;\\r\\n\\t\\t\\ta[v].l = 0;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tbool connected(int u, int v) {\\r\\n\\t\\taccess(u);\\r\\n\\t\\taccess(v);\\r\\n\\t\\treturn a[u].p;\\r\\n\\t}\\r\\n};\\r\\n//EndCodeSnip\\r\\n\\r\\nint N, M;\\r\\n\\r\\nint main() {\\r\\n\\tcin.tie(0)->sync_with_stdio(0);\\r\\n\\r\\n\\tcin >> N >> M;\\r\\n\\r\\n\\tLCT lc(N);\\r\\n\\r\\n\\twhile(M--) {\\r\\n\\t\\tstring a; cin >> a;\\r\\n\\t\\tint b, c; cin >> b >> c;\\r\\n\\t\\tif(a == \\\"add\\\") {\\r\\n\\t\\t\\tlc.link(b, c);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif(a == \\\"rem\\\") {\\r\\n\\t\\t\\tlc.cut(b, c);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif(a == \\\"conn\\\") {\\r\\n\\t\\t\\tcout << (lc.connected(b, c) ? \\\"YES\\\" : \\\"NO\\\") << \\\"\\\\n\\\";\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"with-euler-tour-tree\",\n      children: [_jsx(_components.a, {\n        href: \"#with-euler-tour-tree\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"With Euler-Tour Tree\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-cpp\",\n        children: \"//BeginCodeSnip{Benq Template}\\n#include <bits/stdc++.h>\\nusing namespace std;\\n \\nusing ll = long long;\\nusing db = long double; // or double, if TL is tight\\nusing str = string; // yay python!\\n\\nusing pi = pair<int,int>;\\nusing pl = pair<ll,ll>;\\nusing pd = pair<db,db>;\\n\\nusing vi = vector<int>;\\nusing vb = vector<bool>;\\nusing vl = vector<ll>;\\nusing vd = vector<db>; \\nusing vs = vector<str>;\\nusing vpi = vector<pi>;\\nusing vpl = vector<pl>; \\nusing vpd = vector<pd>;\\n\\n#define tcT template<class T\\n#define tcTU tcT, class U\\n// ^ lol this makes everything look weird but I'll try it\\ntcT> using V = vector<T>; \\ntcT, size_t SZ> using AR = array<T,SZ>; \\ntcT> using PR = pair<T,T>;\\n\\n// pairs\\n#define mp make_pair\\n#define f first\\n#define s second\\n\\n// vectors\\n// oops size(x), rbegin(x), rend(x) need C++17\\n#define sz(x) int((x).size())\\n#define bg(x) begin(x)\\n#define all(x) bg(x), end(x)\\n#define rall(x) x.rbegin(), x.rend() \\n#define sor(x) sort(all(x)) \\n#define rsz resize\\n#define ins insert \\n#define ft front()\\n#define bk back()\\n#define pb push_back\\n#define eb emplace_back \\n#define pf push_front\\n#define rtn return\\n\\n#define lb lower_bound\\n#define ub upper_bound \\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\\n\\n// loops\\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\\n#define F0R(i,a) FOR(i,0,a)\\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\\n#define R0F(i,a) ROF(i,0,a)\\n#define rep(a) F0R(_,a)\\n#define each(a,x) for (auto& a: x)\\n\\nconst int MOD = 1e9+7; // 998244353;\\nconst int MX = 2e5+5;\\nconst ll INF = 1e18; // not too close to LLONG_MAX\\nconst db PI = acos((db)-1);\\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\\n\\n// bitwise ops\\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\\n\\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \\nconstexpr int p2(int x) { return 1<<x; }\\nconstexpr int msk2(int x) { return p2(x)-1; }\\n\\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\\n\\ntcT> bool ckmin(T& a, const T& b) {\\n\\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\\ntcT> bool ckmax(T& a, const T& b) {\\n\\treturn a < b ? a = b, 1 : 0; }\\n\\ntcTU> T fstTrue(T lo, T hi, U f) {\\n\\thi ++; assert(lo <= hi); // assuming f is increasing\\n\\twhile (lo < hi) { // find first index such that f is true \\n\\t\\tT mid = lo+(hi-lo)/2;\\n\\t\\tf(mid) ? hi = mid : lo = mid+1; \\n\\t} \\n\\treturn lo;\\n}\\ntcTU> T lstTrue(T lo, T hi, U f) {\\n\\tlo --; assert(lo <= hi); // assuming f is decreasing\\n\\twhile (lo < hi) { // find first index such that f is true \\n\\t\\tT mid = lo+(hi-lo+1)/2;\\n\\t\\tf(mid) ? lo = mid : hi = mid-1;\\n\\t} \\n\\treturn lo;\\n}\\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\\n\\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\\ntcTU> void erase(T& t, const U& u) { // don't erase\\n\\tauto it = t.find(u); assert(it != end(t));\\n\\tt.erase(it); } // element that doesn't exist from (multi)set\\n\\n#define tcTUU tcT, class ...U\\n\\ninline namespace Helpers {\\n\\t//////////// is_iterable\\n\\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\\n\\t// this gets used only when we can call begin() and end() on that type\\n\\ttcT, class = void> struct is_iterable : false_type {};\\n\\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\\n\\t                                  decltype(end(declval<T>()))\\n\\t                                 >\\n\\t                       > : true_type {};\\n\\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\\n\\n\\t//////////// is_readable\\n\\ttcT, class = void> struct is_readable : false_type {};\\n\\ttcT> struct is_readable<T,\\n\\t        typename std::enable_if_t<\\n\\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\\n\\t        >\\n\\t    > : true_type {};\\n\\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\\n\\n\\t//////////// is_printable\\n\\t// // https://nafe.es/posts/2020-02-29-is-printable/\\n\\ttcT, class = void> struct is_printable : false_type {};\\n\\ttcT> struct is_printable<T,\\n\\t        typename std::enable_if_t<\\n\\t            is_same_v<decltype(cout << declval<T>()), ostream&>\\n\\t        >\\n\\t    > : true_type {};\\n\\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\\n}\\n\\ninline namespace Input {\\n\\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\\n\\ttcTUU> void re(T& t, U&... u);\\n\\ttcTU> void re(pair<T,U>& p); // pairs\\n\\n\\t// re: read\\n\\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\\n\\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\\n\\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\\n\\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\\n\\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\\n\\t\\teach(x,i) re(x); }\\n\\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\\n\\n\\t// rv: resize and read vectors\\n\\tvoid rv(size_t) {}\\n\\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\\n\\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\\n\\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\\n\\t\\tt.rsz(N); re(t);\\n\\t\\trv(N,u...); }\\n\\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\\n\\t\\trv(N2,u...); }\\n\\n\\t// dumb shortcuts to read in ints\\n\\tvoid decrement() {} // subtract one from each\\n\\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\\n\\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\\n\\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\\n}\\n\\ninline namespace ToString {\\n\\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\\n\\n\\t// ts: string representation to print\\n\\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\\n\\t\\tstringstream ss; ss << fixed << setprecision(15) << v;\\n\\t\\treturn ss.str(); } // default\\n\\ttcT> str bit_vec(T t) { // bit vector to string\\n\\t\\tstr res = \\\"{\\\"; F0R(i,sz(t)) res += ts(t[i]);\\n\\t\\tres += \\\"}\\\"; return res; }\\n\\tstr ts(V<bool> v) { return bit_vec(v); }\\n\\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\\n\\ttcTU> str ts(pair<T,U> p); // pairs\\n\\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\\n\\ttcTU> str ts(pair<T,U> p) { return \\\"(\\\"+ts(p.f)+\\\", \\\"+ts(p.s)+\\\")\\\"; }\\n\\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\\n\\t\\t// convert container to string w/ separator sep\\n\\t\\tbool fst = 1; str res = \\\"\\\";\\n\\t\\tfor (const auto& x: v) {\\n\\t\\t\\tif (!fst) res += sep;\\n\\t\\t\\tfst = 0; res += ts(x);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\\n\\t\\treturn \\\"{\\\"+ts_sep(v,\\\", \\\")+\\\"}\\\"; }\\n\\n\\t// for nested DS\\n\\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \\n\\t  ts_lev(const T& v) { return {ts(v)}; }\\n\\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \\n\\t  ts_lev(const T& v) {\\n\\t\\tif (lev == 0 || !sz(v)) return {ts(v)};\\n\\t\\tvs res;\\n\\t\\tfor (const auto& t: v) {\\n\\t\\t\\tif (sz(res)) res.bk += \\\",\\\";\\n\\t\\t\\tvs tmp = ts_lev<lev-1>(t);\\n\\t\\t\\tres.ins(end(res),all(tmp));\\n\\t\\t}\\n\\t\\tF0R(i,sz(res)) {\\n\\t\\t\\tstr bef = \\\" \\\"; if (i == 0) bef = \\\"{\\\";\\n\\t\\t\\tres[i] = bef+res[i];\\n\\t\\t}\\n\\t\\tres.bk += \\\"}\\\";\\n\\t\\treturn res;\\n\\t}\\n}\\n\\ninline namespace Output {\\n\\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\\n\\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\\n\\t\\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\\n\\t// print w/ no spaces\\n\\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,\\\"\\\",t...); } \\n\\t// print w/ spaces, end with newline\\n\\tvoid ps() { cout << \\\"\\\\n\\\"; }\\n\\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,\\\" \\\",t...); ps(); } \\n\\t// debug to cerr\\n\\ttemplate<class ...T> void dbg_out(const T&... t) {\\n\\t\\tpr_sep(cerr,\\\" | \\\",t...); cerr << endl; }\\n\\tvoid loc_info(int line, str names) {\\n\\t\\tcerr << \\\"Line(\\\" << line << \\\") -> [\\\" << names << \\\"]: \\\"; }\\n\\ttemplate<int lev, class T> void dbgl_out(const T& t) {\\n\\t\\tcerr << \\\"\\\\n\\\\n\\\" << ts_sep(ts_lev<lev>(t),\\\"\\\\n\\\") << \\\"\\\\n\\\" << endl; }\\n\\t#ifdef LOCAL\\n\\t\\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\\n\\t\\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\\n\\t#else // don't actually submit with this\\n\\t\\t#define dbg(...) 0\\n\\t\\t#define dbgl(lev,x) 0\\n\\t#endif\\n}\\n\\ninline namespace FileIO {\\n\\tvoid setIn(str s)  { freopen(s.c_str(), \\\"r\\\", stdin); }\\n\\tvoid setOut(str s) { freopen(s.c_str(), \\\"w\\\", stdout); }\\n\\tvoid setIO(str s = \\\"\\\") {\\n\\t\\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\\n\\t\\t// cin.exceptions(cin.failbit);\\n\\t\\t// throws exception when do smth illegal\\n\\t\\t// ex. try to read letter into int\\n\\t\\tif (sz(s)) setIn(s+\\\".in\\\"), setOut(s+\\\".out\\\"); // for old USACO\\n\\t}\\n}\\n//EndCodeSnip\\n//BeginCodeSnip{Euler Tour Tree}\\r\\n/**\\r\\n * Description: Euler Tour Tree using treap, each edge is\\r\\n \\t* represented by two nodes. Supports reroot, insert edge,\\r\\n \\t* delete edge, get connected component. Can support\\r\\n \\t* aggregate over vertices in connected component by\\r\\n \\t* introducing self-loops.\\r\\n * Time: O(\\\\log N)\\r\\n * Source:\\r\\n \\t* https://codeforces.com/blog/entry/53265 (Rerooting dynamic Euler tour trees)\\r\\n \\t* https://codeforces.com/blog/entry/18369 (On Euler tour trees)\\r\\n * Verification:\\r\\n \\t* https://www.spoj.com/problems/DYNACON1/\\r\\n */\\r\\n\\r\\n// TREAP OPERATIONS\\r\\nint cnt, pri[MX], par[MX]; // ETT node for each edge\\r\\nAR<int,2> c[MX];\\r\\n\\r\\nint getRoot(int x) { // get top node in ETT\\r\\n\\twhile (par[x]) x = par[x];\\r\\n\\treturn x;\\r\\n}\\r\\nvoid link(int x, int d, int y) { // set d-th child of x to y\\r\\n\\tassert(x); assert(d == 0 || d == 1);\\r\\n\\tassert(!c[x][d]), c[x][d] = y;\\r\\n\\tif (y) assert(!par[y]), par[y] = x;\\r\\n}\\r\\nint dis(int x, int d) { // disconnected d-th child of x\\r\\n\\tassert(x); assert(d == 0 || d == 1);\\r\\n\\tint y = c[x][d]; c[x][d] = 0;\\r\\n\\tif (y) assert(par[y] == x), par[y] = 0;\\r\\n\\treturn y;\\r\\n}\\r\\npi split(int x) { // x and everything to right goes in p.s\\r\\n\\t// everything else goes in p.f\\r\\n\\tpi p = {dis(x,0),x};\\r\\n\\twhile (par[x]) {\\r\\n\\t\\tint y = par[x];\\r\\n\\t\\tif (c[y][0] == x) {\\r\\n\\t\\t\\tdis(y,0), link(y,0,p.s),  p.s = y;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tassert(c[y][1] == x);\\r\\n\\t\\t\\tdis(y,1), link(y,1,p.f); p.f = y;\\r\\n\\t\\t}\\r\\n\\t\\tx = y;\\r\\n\\t}\\r\\n\\tassert(!par[p.f] && !par[p.s]); return p;\\r\\n}\\r\\n\\r\\nint merge(int x, int y) {\\r\\n\\tassert(!par[x] && !par[y]);\\r\\n\\tif (!x || !y) return max(x,y);\\r\\n\\tif (pri[x] > pri[y]) {\\r\\n\\t\\tint X = dis(x,1);\\r\\n\\t\\tlink(x,1,merge(X,y));\\r\\n\\t\\treturn x;\\r\\n\\t} else {\\r\\n\\t\\tint Y = dis(y,0);\\r\\n\\t\\tlink(y,0,merge(x,Y));\\r\\n\\t\\treturn y;\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// int getFirst(int x) {\\r\\n// \\tif (!x) return 0;\\r\\n// \\twhile (c[x][0]) x = c[x][0];\\r\\n// \\treturn x;\\r\\n// }\\r\\nint makeFirst(int x) { // rotate ETT of x such that x is first\\r\\n\\tassert(x); pi p = split(x);\\r\\n\\treturn merge(p.s,p.f);\\r\\n}\\r\\nvoid remFirst(int x) { // remove first node of ETT rooted at x\\r\\n\\tassert(x && !par[x]);\\r\\n\\twhile (c[x][0]) x = c[x][0];\\r\\n\\tint y = dis(x,1), p = par[x];\\r\\n\\tif (p) dis(p,0), link(p,0,y);\\r\\n}\\r\\n\\r\\n// ETT OPERATIONS\\r\\nmap<int,int> adj[MX];\\r\\nint makeEdge(int a, int b) {\\r\\n\\tadj[a][b] = ++cnt; pri[cnt] = rng();\\r\\n\\treturn cnt;\\r\\n}\\r\\nint reroot(int x) { // make edge beginning with x\\r\\n\\tif (!sz(adj[x])) return 0;\\r\\n\\treturn makeFirst(begin(adj[x])->s);\\r\\n}\\r\\nbool con(int a, int b) {\\r\\n\\tif (!sz(adj[a]) || !sz(adj[b])) return 0;\\r\\n\\ta = begin(adj[a])->s, b = begin(adj[b])->s;\\r\\n\\treturn getRoot(a) == getRoot(b);\\r\\n}\\r\\nvoid add(int a, int b) { // connect A and B with edge\\r\\n\\tint ta = reroot(a), tb = reroot(b); if (ta||tb) assert(ta != tb);\\r\\n\\tint x = makeEdge(a,b), y = makeEdge(b,a); // make two nodes for new edge\\r\\n\\tmerge(merge(ta,x),merge(tb,y));\\r\\n}\\r\\nvoid rem(int a, int b) {\\r\\n\\tint x = adj[a][b], y = adj[b][a]; makeFirst(x);\\r\\n\\tpi p = split(y); // assert(getFirst(p.f) == x && getFirst(p.s) == y);\\r\\n\\tremFirst(p.f), remFirst(p.s);\\r\\n\\tadj[a].erase(b), adj[b].erase(a);\\r\\n}\\r\\n//EndCodeSnip\\r\\n\\r\\nint main() {\\r\\n\\tint N,M; re(N,M);\\r\\n\\tF0R(i,M) {\\r\\n\\t\\tstr s; int A,B; re(s,A,B);\\r\\n\\t\\tif (s == \\\"add\\\") {\\r\\n\\t\\t\\tadd(A,B);\\r\\n\\t\\t} else if (s == \\\"rem\\\") {\\r\\n\\t\\t\\trem(A,B);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tif (con(A,B)) ps(\\\"YES\\\");\\r\\n\\t\\t\\telse ps(\\\"NO\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"link-cut-tree---connectivity\",\n      children: [_jsx(_components.a, {\n        href: \"#link-cut-tree---connectivity\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Link Cut Tree - Connectivity\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"con\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"link-cut-tree---paths\",\n      children: [_jsx(_components.a, {\n        href: \"#link-cut-tree---paths\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Link Cut Tree - Paths\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"pathSam\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        href: \"#implementation\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"problems\",\n      children: [_jsx(_components.a, {\n        href: \"#problems\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"path\"\n    }), \"\\n\", \"\\n\", _jsxs(_components.h2, {\n      id: \"link-cut-tree---subtrees\",\n      children: [_jsx(_components.a, {\n        href: \"#link-cut-tree---subtrees\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Link Cut Tree - Subtrees\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"subSam\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"tutorial-1\",\n      children: [_jsx(_components.a, {\n        href: \"#tutorial-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Tutorial\"]\n    }), \"\\n\", _jsx(Resources, {\n      children: _jsx(Resource, {\n        source: \"CF\",\n        url: \"https://codeforces.com/blog/entry/67637\",\n        title: \"ouuan - Maintaining Subtree Info\",\n        starred: true\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"problems-1\",\n      children: [_jsx(_components.a, {\n        href: \"#problems-1\",\n        \"aria-hidden\": \"true\",\n        tabIndex: \"-1\",\n        className: \"anchor before\",\n        children: _jsx(HeaderLink, {})\n      }), \"Problems\"]\n    }), \"\\n\", _jsx(Problems, {\n      problems: \"sub\"\n    })]\n  });\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, _props, {\n    children: _content\n  })) : _content;\n}\nreturn {\n  id,\n  redirects,\n  title,\n  author,\n  description,\n  prerequisites,\n  frequency,\n  default: MDXContent\n};\n","frontmatter":{"title":"Link Cut Tree","author":"Benjamin Qi, Neo Wang","contributors":null,"id":"link-cut-tree","prerequisites":["offline-del","treaps"],"description":"Dynamic operations on a rooted forest","frequency":1},"parent":{"name":"LCT","relativePath":"6_Advanced/LCT.mdx"},"fields":{"division":"adv"},"toc":{"cpp":[{"depth":2,"value":"Splay Tree","slug":"splay-tree"},{"depth":3,"value":"Tutorial","slug":"tutorial"},{"depth":2,"value":"Link Cut Tree","slug":"link-cut-tree"},{"depth":2,"value":"Dynamic Connectivity","slug":"dynamic-connectivity"},{"depth":3,"value":"With Link-Cut Tree","slug":"with-link-cut-tree"},{"depth":3,"value":"With Euler-Tour Tree","slug":"with-euler-tour-tree"},{"depth":2,"value":"Link Cut Tree - Connectivity","slug":"link-cut-tree---connectivity"},{"depth":2,"value":"Link Cut Tree - Paths","slug":"link-cut-tree---paths"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Problems","slug":"problems"},{"depth":2,"value":"Link Cut Tree - Subtrees","slug":"link-cut-tree---subtrees"},{"depth":3,"value":"Tutorial","slug":"tutorial-1"},{"depth":3,"value":"Problems","slug":"problems-1"}],"java":[{"depth":2,"value":"Splay Tree","slug":"splay-tree"},{"depth":3,"value":"Tutorial","slug":"tutorial"},{"depth":2,"value":"Link Cut Tree","slug":"link-cut-tree"},{"depth":2,"value":"Dynamic Connectivity","slug":"dynamic-connectivity"},{"depth":3,"value":"With Link-Cut Tree","slug":"with-link-cut-tree"},{"depth":3,"value":"With Euler-Tour Tree","slug":"with-euler-tour-tree"},{"depth":2,"value":"Link Cut Tree - Connectivity","slug":"link-cut-tree---connectivity"},{"depth":2,"value":"Link Cut Tree - Paths","slug":"link-cut-tree---paths"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Problems","slug":"problems"},{"depth":2,"value":"Link Cut Tree - Subtrees","slug":"link-cut-tree---subtrees"},{"depth":3,"value":"Tutorial","slug":"tutorial-1"},{"depth":3,"value":"Problems","slug":"problems-1"}],"py":[{"depth":2,"value":"Splay Tree","slug":"splay-tree"},{"depth":3,"value":"Tutorial","slug":"tutorial"},{"depth":2,"value":"Link Cut Tree","slug":"link-cut-tree"},{"depth":2,"value":"Dynamic Connectivity","slug":"dynamic-connectivity"},{"depth":3,"value":"With Link-Cut Tree","slug":"with-link-cut-tree"},{"depth":3,"value":"With Euler-Tour Tree","slug":"with-euler-tour-tree"},{"depth":2,"value":"Link Cut Tree - Connectivity","slug":"link-cut-tree---connectivity"},{"depth":2,"value":"Link Cut Tree - Paths","slug":"link-cut-tree---paths"},{"depth":3,"value":"Implementation","slug":"implementation"},{"depth":3,"value":"Problems","slug":"problems"},{"depth":2,"value":"Link Cut Tree - Subtrees","slug":"link-cut-tree---subtrees"},{"depth":3,"value":"Tutorial","slug":"tutorial-1"},{"depth":3,"value":"Problems","slug":"problems-1"}]}},"moduleProblemLists":{"problemLists":[{"listId":"conSam","problems":[{"uniqueId":"spoj-DynamicConnectivity","name":"Dynamic Connectivity","url":"https://www.spoj.com/problems/DYNACON1","source":"SPOJ","difficulty":"Very Easy","isStarred":false,"tags":["LCT"],"solution":{"kind":"sketch","label":null,"labelTooltip":null,"url":null,"sketch":" LCT isn't needed because the queries are offline"}}]},{"listId":"con","problems":[{"uniqueId":"cf-1109F","name":"Silence's Sounds","url":"https://codeforces.com/contest/1109/problem/F","source":"CF","difficulty":"Easy","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"spoj-DynamicLCA","name":"Dynamic LCA","url":"https://www.spoj.com/problems/DYNALCA","source":"SPOJ","difficulty":"Normal","isStarred":false,"tags":["LCT"],"solution":null}]},{"listId":"pathSam","problems":[{"uniqueId":"ys-VertexAddPathSum","name":"Vertex Add Path Sum","url":"https://judge.yosupo.jp/problem/dynamic_tree_vertex_add_path_sum","source":"YS","difficulty":"Easy","isStarred":false,"tags":["LCT"],"solution":null}]},{"listId":"path","problems":[{"uniqueId":"ys-VertexAddPathComposite","name":"Vertex Add Path Composite","url":"https://judge.yosupo.jp/problem/dynamic_tree_vertex_set_path_composite","source":"YS","difficulty":"Easy","isStarred":false,"tags":["LCT"],"solution":null},{"uniqueId":"dmoj-SquirrelCities","name":"Squirrel Cities","url":"https://dmoj.ca/problem/wac4p7","source":"DMOJ","difficulty":"Normal","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check DMOJ","labelTooltip":"There might be a \"Read Editorial\" button on the right side of the page.","url":null,"sketch":null}},{"uniqueId":"hr-BalancedTokens","name":"Balanced Tokens","url":"https://www.hackerrank.com/contests/pwshpc-online-round/challenges/pwsh-tokens/problem","source":"HR","difficulty":"Normal","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check HR","labelTooltip":"The editorial tab should be right next to the discussions tab.","url":null,"sketch":null}},{"uniqueId":"ceoi-11-TreasureHunt","name":"2011 - Treasure Hunt","url":"https://cses.fi/174/list/","source":"CEOI","difficulty":"Normal","isStarred":false,"tags":["LCT"],"solution":null},{"uniqueId":"baltic-20-joker","name":"2020 - Joker","url":"https://codeforces.com/contest/1386/problem/C","source":"Baltic OI","difficulty":"Hard","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"dmoj-DynamicTreeTestEasy","name":"Dynamic Tree Test (Easy)","url":"https://dmoj.ca/problem/ds5easy","source":"DMOJ","difficulty":"Hard","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check DMOJ","labelTooltip":"There might be a \"Read Editorial\" button on the right side of the page.","url":null,"sketch":null}},{"uniqueId":"cf-1344E","name":"Train Tracking","url":"https://codeforces.com/contest/1344/problem/E","source":"CF","difficulty":"Hard","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cf-117E","name":"Tree or not Tree","url":"https://codeforces.com/contest/117/problem/E","source":"CF","difficulty":"Hard","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"cfgym-101620101620","name":"CERC 17 D","url":"https://codeforces.com/gym/101620","source":"CF","difficulty":"Hard","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"ioi-11-DancingElephants","name":"2011 - Dancing Elephants","url":"https://oj.uz/problem/view/IOI11_elephants","source":"IOI","difficulty":"Hard","isStarred":false,"tags":[],"solution":{"kind":"link","label":"External Sol","labelTooltip":null,"url":"https://ioinformatics.org/page/ioi-2011/37","sketch":null}}]},{"listId":"subSam","problems":[{"uniqueId":"ys-VertexAddSubtreeSum","name":"Vertex Add Subtree Sum","url":"https://judge.yosupo.jp/problem/dynamic_tree_vertex_add_subtree_sum","source":"YS","difficulty":"Normal","isStarred":false,"tags":["LCT"],"solution":null}]},{"listId":"sub","problems":[{"uniqueId":"cf-603E","name":"Pastoral Oddities","url":"https://codeforces.com/contest/603/problem/E","source":"CF","difficulty":"Normal","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"ys-SubtreeAddSubtreeSum","name":"Subtree Add Subtree Sum","url":"https://judge.yosupo.jp/problem/dynamic_tree_subtree_add_subtree_sum","source":"YS","difficulty":"Hard","isStarred":false,"tags":["LCT"],"solution":null},{"uniqueId":"cf-1172E","name":"Old Driver Tree","url":"https://codeforces.com/contest/1172/problem/E","source":"CF","difficulty":"Very Hard","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check CF","labelTooltip":"Check contest materials, located to the right of the problem statement.","url":null,"sketch":null}},{"uniqueId":"dmoj-DynamicTreeTest","name":"Dynamic Tree Test","url":"https://dmoj.ca/problem/ds5","source":"DMOJ","difficulty":"Very Hard","isStarred":false,"tags":["LCT"],"solution":{"kind":"label","label":"Check DMOJ","labelTooltip":"There might be a \"Read Editorial\" button on the right side of the page.","url":null,"sketch":null}}]}]}},"pageContext":{"id":"link-cut-tree"}},
    "staticQueryHashes": ["2753100047","3245546052","745520438"]}